2024.01.12 12:37:58 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\scalaTAP' for client Visual Studio Code 1.85.1.
2024.01.12 12:37:59 WARN  Build server is not auto-connectable.
2024.01.12 12:38:09 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala
2024.01.12 12:38:11 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.12 12:38:13 INFO  time: code lens generation in 1.71s
2024.01.12 12:38:13 INFO  time: code lens generation in 2.86s
2024.01.12 12:46:16 INFO  Shutting down server
2024.01.12 12:46:16 INFO  shutting down Metals
2024.01.12 12:46:16 INFO  Exiting server
2024.01.12 12:51:45 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\scalaTAP' for client Visual Studio Code 1.85.1.
2024.01.12 12:51:46 WARN  Build server is not auto-connectable.
2024.01.12 12:51:46 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala
2024.01.12 12:51:49 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.12 12:51:51 INFO  time: code lens generation in 4.28s
2024.01.12 12:51:51 INFO  time: code lens generation in 3.95s
2024.01.12 12:51:53 INFO  running 'C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals1600741332812743875\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.01.12 12:51:55 INFO  [info] welcome to sbt 1.9.7 (Oracle Corporation Java 21.0.1)
2024.01.12 12:51:56 INFO  [info] loading settings for project scalatap-build-build from metals.sbt ...
2024.01.12 12:51:56 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\scalaTAP\project\project
2024.01.12 12:51:58 INFO  [info] loading settings for project scalatap-build from metals.sbt ...
2024.01.12 12:51:58 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\scalaTAP\project
2024.01.12 12:52:00 INFO  [success] Generated .bloop\scalatap-build.json
2024.01.12 12:52:00 INFO  [info] compiling 1 Scala source to C:\URV\Progra\RepositorioGitHub\scalaTAP\project\target\scala-2.12\sbt-1.0\classes ...
2024.01.12 12:52:03 INFO  [info] done compiling
2024.01.12 12:52:03 INFO  [success] Total time: 4 s, completed 12 ene 2024, 12:52:03
2024.01.12 12:52:04 INFO  [info] loading settings for project root from build.sbt ...
2024.01.12 12:52:04 INFO  [info] set current project to Scala Seed Project (in build file:/C:/URV/Progra/RepositorioGitHub/scalaTAP/)
2024.01.12 12:52:04 INFO  [success] Generated .bloop\root-test.json
2024.01.12 12:52:04 INFO  [success] Generated .bloop\root.json
2024.01.12 12:52:04 INFO  [success] Total time: 1 s, completed 12 ene 2024, 12:52:05
2024.01.12 12:52:05 INFO  time: ran 'sbt bloopInstall' in 11s
2024.01.12 12:52:05 INFO  Attempting to connect to the build server...
2024.01.12 12:52:05 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.12 12:52:08 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.12 12:52:08 INFO  Attempting to connect to the build server...
2024.01.12 12:52:08 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.12 12:52:08 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.12 12:52:08 INFO  time: Connected to build server in 3.52s
2024.01.12 12:52:08 INFO  Connected to Build server: Bloop v1.5.13
2024.01.12 12:52:09 INFO  time: Imported build in 0.14s
2024.01.12 12:52:13 INFO  time: indexed workspace in 3.81s
2024.01.12 12:52:13 INFO  compiling root (1 scala source)
2024.01.12 12:52:16 INFO  compiling root-test (1 scala source)
2024.01.12 12:52:16 INFO  time: compiled root in 2.91s
2024.01.12 12:52:16 INFO  time: compiled root-test in 0.63s
ene 12, 2024 12:54:17 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.01.12 13:09:01 INFO  compiling root (1 scala source)
2024.01.12 13:09:01 INFO  time: compiled root in 0.22s
2024.01.12 13:09:08 INFO  compiling root (1 scala source)
2024.01.12 13:09:08 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 16m 59.236s)
2024.01.12 13:09:08 INFO  compiling root (1 scala source)
2024.01.12 13:09:08 INFO  time: compiled root in 0.19s
2024.01.12 13:09:13 INFO  compiling root (1 scala source)
2024.01.12 13:09:13 INFO  time: compiled root in 0.13s
2024.01.12 13:09:42 INFO  compiling root (1 scala source)
2024.01.12 13:09:42 INFO  time: compiled root in 0.1s
2024.01.12 13:09:43 INFO  compiling root (1 scala source)
2024.01.12 13:09:43 INFO  time: compiled root in 0.14s
2024.01.12 13:11:31 INFO  compiling root (1 scala source)
2024.01.12 13:11:31 INFO  time: compiled root in 0.13s
ene 12, 2024 1:11:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 225
2024.01.12 13:11:42 INFO  compiling root (1 scala source)
2024.01.12 13:11:42 INFO  time: compiled root in 99ms
2024.01.12 13:11:43 WARN  Using indexes to guess the definition of instance
ene 12, 2024 1:11:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 244
ene 12, 2024 1:11:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 245
Exception in thread "pool-6-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 12, 2024 1:11:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 248
2024.01.12 13:11:43 WARN  Using indexes to guess the definition of invoker
ene 12, 2024 1:11:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 253
2024.01.12 13:11:44 INFO  compiling root (1 scala source)
2024.01.12 13:11:44 INFO  time: compiled root in 0.12s
2024.01.12 13:11:49 INFO  compiling root (1 scala source)
2024.01.12 13:11:49 INFO  time: compiled root in 91ms
2024.01.12 13:11:50 WARN  Using indexes to guess the definition of instance
2024.01.12 13:11:51 WARN  Using indexes to guess the definition of SingletonController
2024.01.12 13:11:52 INFO  compiling root (1 scala source)
2024.01.12 13:11:52 INFO  time: compiled root in 99ms
2024.01.12 13:12:12 INFO  compiling root (1 scala source)
2024.01.12 13:12:12 INFO  time: compiled root in 0.1s
2024.01.12 13:12:17 INFO  compiling root (1 scala source)
2024.01.12 13:12:17 INFO  time: compiled root in 0.11s
2024.01.12 13:12:24 WARN  Using indexes to guess the definition of SimplePolicy
2024.01.12 13:12:25 WARN  Using indexes to guess the definition of SimplePolicy
ene 12, 2024 1:12:25 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 407
Exception in thread "pool-6-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:12:29 WARN  Using indexes to guess the definition of getInstance
2024.01.12 13:12:29 INFO  compiling root (1 scala source)
2024.01.12 13:12:29 INFO  time: compiled root in 87ms
2024.01.12 13:12:33 INFO  compiling root (1 scala source)
2024.01.12 13:12:33 INFO  time: compiled root in 93ms
2024.01.12 13:12:41 INFO  compiling root (1 scala source)
2024.01.12 13:12:41 INFO  time: compiled root in 77ms
2024.01.12 13:12:48 INFO  compiling root (1 scala source)
2024.01.12 13:12:48 INFO  time: compiled root in 98ms
2024.01.12 13:12:51 WARN  Using indexes to guess the definition of ControllerInstance
2024.01.12 13:12:51 INFO  compiling root (1 scala source)
2024.01.12 13:12:51 INFO  time: compiled root in 82ms
2024.01.12 13:12:53 WARN  Using indexes to guess the definition of ControllerInstance
2024.01.12 13:12:54 WARN  Using indexes to guess the definition of ControllerInstance
2024.01.12 13:12:55 WARN  Using indexes to guess the definition of ControllerInstance
2024.01.12 13:12:55 WARN  Using indexes to guess the definition of ControllerInstance
2024.01.12 13:12:56 WARN  Using indexes to guess the definition of ControllerInstance
2024.01.12 13:12:57 INFO  compiling root (1 scala source)
2024.01.12 13:12:57 INFO  time: compiled root in 74ms
2024.01.12 13:13:08 INFO  compiling root (1 scala source)
2024.01.12 13:13:08 INFO  time: compiled root in 86ms
2024.01.12 13:13:10 INFO  compiling root (1 scala source)
2024.01.12 13:13:10 INFO  time: compiled root in 74ms
2024.01.12 13:13:12 INFO  compiling root (1 scala source)
2024.01.12 13:13:12 INFO  time: compiled root in 77ms
2024.01.12 13:13:22 WARN  Using indexes to guess the definition of SimpleController
2024.01.12 13:13:23 WARN  Using indexes to guess the definition of SimpleController
2024.01.12 13:13:23 INFO  compiling root (1 scala source)
2024.01.12 13:13:23 INFO  time: compiled root in 0.1s
2024.01.12 13:13:25 WARN  Using indexes to guess the definition of SimpleController
2024.01.12 13:13:28 INFO  compiling root (1 scala source)
2024.01.12 13:13:28 INFO  time: compiled root in 67ms
2024.01.12 13:13:31 WARN  Using indexes to guess the definition of SimpleController
Exception in thread "pool-6-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:13:49 INFO  compiling root (1 scala source)
2024.01.12 13:13:49 INFO  time: compiled root in 0.1s
2024.01.12 13:13:53 INFO  compiling root (1 scala source)
2024.01.12 13:13:53 INFO  time: compiled root in 80ms
2024.01.12 13:14:03 INFO  compiling root (1 scala source)
2024.01.12 13:14:03 INFO  time: compiled root in 72ms
2024.01.12 13:14:40 INFO  compiling root (1 scala source)
2024.01.12 13:14:40 INFO  time: compiled root in 0.16s
2024.01.12 13:14:46 INFO  compiling root (1 scala source)
2024.01.12 13:14:46 INFO  time: compiled root in 0.11s
ene 12, 2024 1:14:49 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 803
2024.01.12 13:14:49 INFO  compiling root (1 scala source)
Exception in thread "pool-6-thread-4" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:14:49 INFO  time: compiled root in 0.12s
2024.01.12 13:15:09 INFO  compiling root (1 scala source)
2024.01.12 13:15:09 INFO  time: compiled root in 78ms
2024.01.12 13:15:09 INFO  compiling root (1 scala source)
2024.01.12 13:15:09 INFO  time: compiled root in 81ms
2024.01.12 13:15:09 INFO  compiling root (1 scala source)
2024.01.12 13:15:09 INFO  time: compiled root in 52ms
2024.01.12 13:15:12 INFO  compiling root (1 scala source)
2024.01.12 13:15:12 INFO  time: compiled root in 64ms
2024.01.12 13:15:14 INFO  compiling root (1 scala source)
2024.01.12 13:15:14 INFO  time: compiled root in 60ms
2024.01.12 13:15:59 INFO  compiling root (1 scala source)
2024.01.12 13:15:59 INFO  time: compiled root in 56ms
2024.01.12 13:16:04 INFO  compiling root (1 scala source)
2024.01.12 13:16:04 INFO  time: compiled root in 67ms
2024.01.12 13:16:40 INFO  compiling root (1 scala source)
2024.01.12 13:16:40 INFO  time: compiled root in 67ms
2024.01.12 13:17:01 INFO  compiling root (1 scala source)
2024.01.12 13:17:01 INFO  time: compiled root in 66ms
2024.01.12 13:17:30 INFO  compiling root (1 scala source)
2024.01.12 13:17:30 INFO  time: compiled root in 54ms
2024.01.12 13:17:33 INFO  compiling root (1 scala source)
2024.01.12 13:17:33 INFO  time: compiled root in 30ms
2024.01.12 13:17:35 INFO  compiling root (1 scala source)
2024.01.12 13:17:35 INFO  time: compiled root in 41ms
2024.01.12 13:17:39 INFO  compiling root (1 scala source)
2024.01.12 13:17:39 INFO  time: compiled root in 50ms
2024.01.12 13:17:41 INFO  compiling root (1 scala source)
2024.01.12 13:17:41 INFO  time: compiled root in 44ms
2024.01.12 13:17:45 INFO  compiling root (1 scala source)
2024.01.12 13:17:45 INFO  time: compiled root in 31ms
2024.01.12 13:17:53 INFO  compiling root (1 scala source)
2024.01.12 13:17:53 INFO  time: compiled root in 39ms
2024.01.12 13:17:55 INFO  compiling root (1 scala source)
2024.01.12 13:17:55 INFO  time: compiled root in 32ms
2024.01.12 13:17:59 INFO  compiling root (1 scala source)
2024.01.12 13:17:59 INFO  time: compiled root in 43ms
2024.01.12 13:18:04 INFO  compiling root (1 scala source)
2024.01.12 13:18:04 INFO  time: compiled root in 39ms
2024.01.12 13:18:15 INFO  compiling root (1 scala source)
2024.01.12 13:18:15 INFO  time: compiled root in 0.44s
2024.01.12 13:18:33 INFO  compiling root (1 scala source)
2024.01.12 13:18:33 INFO  time: compiled root in 35ms
2024.01.12 13:18:35 INFO  compiling root (1 scala source)
2024.01.12 13:18:35 INFO  time: compiled root in 0.39s
2024.01.12 13:18:41 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:18:41 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:18:41 INFO  compiling root (1 scala source)
2024.01.12 13:18:41 INFO  time: compiled root in 37ms
2024.01.12 13:18:41 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:18:41 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:18:41 WARN  Using indexes to guess the definition of AdderAction
2024.01.12 13:18:41 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:18:43 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:18:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:18:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:18:44 INFO  compiling root (1 scala source)
2024.01.12 13:18:44 INFO  time: compiled root in 0.42s
2024.01.12 13:19:05 INFO  compiling root-test (1 scala source)
2024.01.12 13:19:05 INFO  time: compiled root-test in 67ms
2024.01.12 13:19:05 INFO  compiling root (1 scala source)
2024.01.12 13:19:05 INFO  time: compiled root in 0.38s
2024.01.12 13:19:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
Exception in thread "pool-6-thread-5" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:19:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:13 INFO  compiling root (1 scala source)
2024.01.12 13:19:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:13 INFO  time: compiled root in 40ms
2024.01.12 13:19:16 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:17 INFO  compiling root (1 scala source)
2024.01.12 13:19:17 INFO  time: compiled root in 39ms
2024.01.12 13:19:21 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:22 INFO  compiling root (1 scala source)
2024.01.12 13:19:22 INFO  time: compiled root in 38ms
2024.01.12 13:19:25 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:26 INFO  compiling root (1 scala source)
2024.01.12 13:19:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:19:26 INFO  time: compiled root in 0.41s
2024.01.12 13:19:55 INFO  compiling root-test (1 scala source)
2024.01.12 13:19:55 INFO  time: compiled root-test in 65ms
2024.01.12 13:20:01 INFO  compiling root-test (1 scala source)
2024.01.12 13:20:01 INFO  time: compiled root-test in 0.34s
2024.01.12 13:20:06 INFO  compiling root-test (1 scala source)
2024.01.12 13:20:06 INFO  time: compiled root-test in 0.46s
2024.01.12 13:20:09 INFO  compiling root-test (1 scala source)
2024.01.12 13:20:09 INFO  time: compiled root-test in 0.33s
2024.01.12 13:20:30 INFO  compiling root (1 scala source)
2024.01.12 13:20:30 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 28m 21.629s)
2024.01.12 13:20:30 INFO  compiling root (1 scala source)
2024.01.12 13:20:30 INFO  time: compiled root in 0.37s
2024.01.12 13:20:30 INFO  compiling root (1 scala source)
2024.01.12 13:20:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:20:31 INFO  time: compiled root in 0.12s
2024.01.12 13:20:32 INFO  compiling root (1 scala source)
2024.01.12 13:20:32 INFO  time: compiled root in 0.4s
2024.01.12 13:20:34 INFO  compiling root (1 scala source)
2024.01.12 13:20:34 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:20:34 INFO  time: compiled root in 0.42s
2024.01.12 13:24:47 INFO  compiling root (1 scala source)
2024.01.12 13:24:47 INFO  time: compiled root in 0.19s
2024.01.12 13:25:18 INFO  compiling root (1 scala source)
2024.01.12 13:25:18 INFO  time: compiled root in 93ms
ene 12, 2024 1:25:24 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set3.foreach(Set.scala:261)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 12, 2024 1:25:24 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set3.foreach(Set.scala:261)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 12, 2024 1:25:24 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set3.foreach(Set.scala:261)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 12, 2024 1:25:24 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set3.foreach(Set.scala:261)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

Exception in thread "pool-6-thread-6" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 12, 2024 1:25:25 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1706
Exception in thread "pool-6-thread-7" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-6-thread-8" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-6-thread-9" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:25:31 INFO  compiling root (1 scala source)
2024.01.12 13:25:31 INFO  time: compiled root in 0.11s
ene 12, 2024 1:27:11 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set3.foreach(Set.scala:261)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.$anonfun$hover$1(HoverProvider.scala:20)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:20)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 12, 2024 1:27:11 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\Hello.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set3.foreach(Set.scala:261)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.$anonfun$hover$1(HoverProvider.scala:20)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:20)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 12, 2024 1:27:11 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set3.foreach(Set.scala:261)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.$anonfun$hover$1(HoverProvider.scala:20)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:20)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 12, 2024 1:27:11 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set3.foreach(Set.scala:261)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.$anonfun$hover$1(HoverProvider.scala:20)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:20)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

2024.01.12 13:27:34 INFO  compiling root (1 scala source)
2024.01.12 13:27:34 INFO  time: compiled root in 77ms
2024.01.12 13:27:48 INFO  compiling root (1 scala source)
2024.01.12 13:27:48 INFO  time: compiled root in 77ms
2024.01.12 13:27:48 INFO  compiling root (1 scala source)
2024.01.12 13:27:48 INFO  time: compiled root in 35ms
2024.01.12 13:27:53 INFO  compiling root (1 scala source)
2024.01.12 13:27:53 INFO  time: compiled root in 44ms
2024.01.12 13:27:55 INFO  compiling root (1 scala source)
2024.01.12 13:27:55 INFO  time: compiled root in 43ms
Exception in thread "pool-6-thread-10" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-6-thread-11" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-6-thread-12" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:27:57 INFO  compiling root (1 scala source)
2024.01.12 13:27:57 INFO  time: compiled root in 41ms
2024.01.12 13:28:00 INFO  compiling root (1 scala source)
2024.01.12 13:28:00 INFO  time: compiled root in 34ms
2024.01.12 13:28:02 INFO  compiling root (1 scala source)
2024.01.12 13:28:02 INFO  time: compiled root in 36ms
2024.01.12 13:28:04 INFO  compiling root (1 scala source)
2024.01.12 13:28:04 INFO  time: compiled root in 37ms
2024.01.12 13:28:04 INFO  compiling root (1 scala source)
2024.01.12 13:28:04 INFO  time: compiled root in 52ms
Exception in thread "pool-6-thread-13" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:28:10 WARN  Using indexes to guess the definition of SimpleController
Exception in thread "pool-6-thread-14" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-6-thread-15" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-6-thread-16" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:28:59 INFO  compiling root (1 scala source)
2024.01.12 13:28:59 INFO  time: compiled root in 48ms
Exception in thread "pool-6-thread-17" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:29:04 INFO  compiling root (1 scala source)
2024.01.12 13:29:04 INFO  time: compiled root in 49ms
2024.01.12 13:29:10 INFO  compiling root (1 scala source)
2024.01.12 13:29:10 INFO  time: compiled root in 90ms
2024.01.12 13:29:25 INFO  compiling root (1 scala source)
2024.01.12 13:29:25 INFO  time: compiled root in 72ms
2024.01.12 13:29:34 INFO  compiling root (1 scala source)
2024.01.12 13:29:34 INFO  time: compiled root in 72ms
2024.01.12 13:29:35 INFO  compiling root (1 scala source)
2024.01.12 13:29:35 INFO  time: compiled root in 53ms
2024.01.12 13:29:37 INFO  compiling root (1 scala source)
2024.01.12 13:29:37 INFO  time: compiled root in 69ms
2024.01.12 13:29:59 INFO  compiling root (1 scala source)
2024.01.12 13:29:59 INFO  time: compiled root in 0.52s
2024.01.12 13:30:39 INFO  compiling root (1 scala source)
2024.01.12 13:30:39 INFO  time: compiled root in 40ms
2024.01.12 13:30:44 INFO  compiling root (1 scala source)
2024.01.12 13:30:44 INFO  time: compiled root in 45ms
2024.01.12 13:30:54 INFO  compiling root (1 scala source)
2024.01.12 13:30:54 INFO  time: compiled root in 0.62s
2024.01.12 13:31:05 INFO  compiling root (1 scala source)
2024.01.12 13:31:05 INFO  time: compiled root in 93ms
2024.01.12 13:31:10 INFO  compiling root (1 scala source)
2024.01.12 13:31:10 INFO  time: compiled root in 64ms
2024.01.12 13:31:24 INFO  compiling root (1 scala source)
2024.01.12 13:31:24 INFO  time: compiled root in 35ms
Exception in thread "pool-6-thread-18" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:31:35 INFO  compiling root (1 scala source)
2024.01.12 13:31:35 INFO  time: compiled root in 38ms
2024.01.12 13:31:39 INFO  compiling root (1 scala source)
2024.01.12 13:31:39 INFO  time: compiled root in 36ms
2024.01.12 13:31:50 INFO  compiling root (1 scala source)
2024.01.12 13:31:50 INFO  time: compiled root in 69ms
2024.01.12 13:31:53 INFO  compiling root (1 scala source)
2024.01.12 13:31:53 INFO  time: compiled root in 0.51s
2024.01.12 13:31:53 INFO  compiling root (1 scala source)
2024.01.12 13:31:53 INFO  time: compiled root in 0.14s
2024.01.12 13:32:03 INFO  compiling root (1 scala source)
Exception in thread "pool-6-thread-19" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:32:03 INFO  time: compiled root in 0.5s
Exception in thread "pool-6-thread-20" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:32:05 WARN  Using indexes to guess the definition of Seq
2024.01.12 13:32:08 INFO  compiling root (1 scala source)
2024.01.12 13:32:08 INFO  time: compiled root in 0.58s
2024.01.12 13:32:12 INFO  compiling root (1 scala source)
2024.01.12 13:32:12 INFO  time: compiled root in 0.56s
2024.01.12 13:32:17 INFO  compiling root (1 scala source)
2024.01.12 13:32:17 INFO  time: compiled root in 0.59s
2024.01.12 13:32:19 INFO  compiling root (1 scala source)
2024.01.12 13:32:19 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 40m 10.357s)
2024.01.12 13:32:19 INFO  compiling root (1 scala source)
2024.01.12 13:32:19 INFO  time: compiled root in 0.1s
2024.01.12 13:33:28 INFO  compiling root (1 scala source)
2024.01.12 13:33:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:33:28 INFO  time: compiled root in 0.71s
ene 12, 2024 1:34:28 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2363
2024.01.12 13:34:28 INFO  compiling root (1 scala source)
2024.01.12 13:34:28 INFO  time: compiled root in 78ms
2024.01.12 13:34:30 INFO  compiling root (1 scala source)
2024.01.12 13:34:30 INFO  time: compiled root in 59ms
2024.01.12 13:34:47 INFO  compiling root (1 scala source)
2024.01.12 13:34:47 INFO  time: compiled root in 0.53s
2024.01.12 13:34:47 INFO  compiling root (1 scala source)
2024.01.12 13:34:47 INFO  time: compiled root in 0.12s
2024.01.12 13:34:50 INFO  compiling root (1 scala source)
2024.01.12 13:34:50 INFO  time: compiled root in 0.5s
2024.01.12 13:34:51 INFO  compiling root (1 scala source)
2024.01.12 13:34:51 INFO  time: compiled root in 0.1s
2024.01.12 13:35:15 INFO  compiling root (1 scala source)
2024.01.12 13:35:15 INFO  time: compiled root in 0.53s
ene 12, 2024 1:35:19 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2440
2024.01.12 13:35:19 INFO  compiling root (1 scala source)
2024.01.12 13:35:19 INFO  compiling root (1 scala source)
2024.01.12 13:35:19 INFO  time: compiled root in 19ms
2024.01.12 13:35:19 WARN  failed to generate semanticdb for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala:
C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala:140: error: end of file expected but } found
}
^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:421)
	at scala.meta.internal.parsers.ScalametaParser.expect(ScalametaParser.scala:423)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:427)
	at scala.meta.internal.parsers.ScalametaParser.parseRuleAfterBOF(ScalametaParser.scala:63)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:54)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:132)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.parsers.Parse$$anon$1.apply(Parse.scala:36)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:206)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:54)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.saveSemanticdbForCompilationUnit(SemanticdbPipeline.scala:59)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.apply(SemanticdbPipeline.scala:65)
	at scala.tools.nsc.Global$GlobalPhase.applyPhase(Global.scala:480)
	at scala.tools.nsc.Global$GlobalPhase.run(Global.scala:427)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.run(SemanticdbPipeline.scala:75)
	at scala.tools.nsc.Global$Run.compileUnitsInternal(Global.scala:1546)
	at scala.tools.nsc.Global$Run.compileUnits(Global.scala:1530)
	at scala.tools.nsc.Global$Run.compileSources(Global.scala:1522)
	at scala.tools.nsc.Global$Run.compileFiles(Global.scala:1635)
	at scala.tools.xsbt.CachedCompiler0.run(CompilerBridge.scala:176)
	at scala.tools.xsbt.CachedCompiler0.run(CompilerBridge.scala:139)
	at scala.tools.xsbt.CompilerBridge.run(CompilerBridge.scala:43)
	at sbt.internal.inc.AnalyzingCompiler.compile(AnalyzingCompiler.scala:91)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.compileSources$1(BloopHighLevelCompiler.scala:133)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$7(BloopHighLevelCompiler.scala:159)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$1(BloopHighLevelCompiler.scala:71)
	at bloop.tracing.NoopTracer$.trace(BraveTracer.scala:53)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.timed$1(BloopHighLevelCompiler.scala:70)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$6(BloopHighLevelCompiler.scala:159)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at monix.eval.internal.TaskRunLoop$.startFull(TaskRunLoop.scala:81)
	at monix.eval.internal.TaskRestartCallback.syncOnSuccess(TaskRestartCallback.scala:101)
	at monix.eval.internal.TaskRestartCallback.onSuccess(TaskRestartCallback.scala:74)
	at monix.eval.internal.TaskExecuteOn$AsyncRegister$$anon$1.run(TaskExecuteOn.scala:71)
	at java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1423)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:387)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1312)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1843)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1808)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:188)

2024.01.12 13:35:22 INFO  compiling root (1 scala source)
2024.01.12 13:35:22 INFO  time: compiled root in 0.55s
2024.01.12 13:35:22 INFO  compiling root (1 scala source)
2024.01.12 13:35:22 INFO  time: compiled root in 0.19s
2024.01.12 13:35:31 INFO  compiling root (1 scala source)
2024.01.12 13:35:31 INFO  time: compiled root in 0.56s
2024.01.12 13:35:34 INFO  compiling root (1 scala source)
2024.01.12 13:35:34 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:35:34 INFO  time: compiled root in 0.55s
Exception in thread "pool-6-thread-21" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:36:53 INFO  compiling root (1 scala source)
2024.01.12 13:36:53 INFO  time: compiled root in 0.71s
2024.01.12 13:36:56 INFO  compiling root (1 scala source)
2024.01.12 13:36:56 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:36:56 INFO  time: compiled root in 0.54s
2024.01.12 13:37:05 INFO  compiling root (1 scala source)
2024.01.12 13:37:05 INFO  time: compiled root in 0.62s
2024.01.12 13:37:07 INFO  compiling root (1 scala source)
2024.01.12 13:37:07 INFO  time: compiled root in 0.52s
2024.01.12 13:37:14 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 45m 5.525s)
2024.01.12 13:37:14 INFO  compiling root (1 scala source)
2024.01.12 13:37:14 INFO  compiling root (1 scala source)
ene 12, 2024 1:37:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2620
2024.01.12 13:37:14 INFO  time: compiled root in 0.56s
2024.01.12 13:37:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:37:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:37:17 INFO  compiling root (1 scala source)
2024.01.12 13:37:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:37:17 INFO  time: compiled root in 0.56s
2024.01.12 13:37:19 INFO  compiling root (1 scala source)
2024.01.12 13:37:19 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 45m 11.186s)
2024.01.12 13:37:19 INFO  compiling root (1 scala source)
2024.01.12 13:37:19 INFO  time: compiled root in 0.19s
2024.01.12 13:37:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:37:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:37:22 INFO  compiling root (1 scala source)
2024.01.12 13:37:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:37:22 INFO  time: compiled root in 0.63s
2024.01.12 13:37:25 INFO  compiling root (1 scala source)
2024.01.12 13:37:25 INFO  time: compiled root in 0.54s
2024.01.12 13:38:25 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 46m 16.642s)
2024.01.12 13:38:25 INFO  compiling root (1 scala source)
2024.01.12 13:38:25 INFO  compiling root (1 scala source)
2024.01.12 13:38:25 INFO  time: compiled root in 0.71s
2024.01.12 13:38:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:38:31 INFO  compiling root (1 scala source)
2024.01.12 13:38:31 INFO  time: compiled root in 0.53s
2024.01.12 13:38:33 INFO  compiling root (1 scala source)
2024.01.12 13:38:33 INFO  time: compiled root in 0.54s
2024.01.12 13:38:38 INFO  compiling root (1 scala source)
2024.01.12 13:38:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:38:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:38:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:38:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:38:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:38:38 INFO  time: compiled root in 0.53s
2024.01.12 13:38:42 INFO  compiling root (1 scala source)
2024.01.12 13:38:42 INFO  time: compiled root in 0.56s
2024.01.12 13:38:44 INFO  compiling root (1 scala source)
2024.01.12 13:38:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:38:44 INFO  time: compiled root in 0.53s
2024.01.12 13:40:21 INFO  compiling root (1 scala source)
2024.01.12 13:40:21 INFO  time: compiled root in 0.61s
2024.01.12 13:40:23 INFO  compiling root (1 scala source)
2024.01.12 13:40:23 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:40:23 INFO  time: compiled root in 0.62s
2024.01.12 13:40:25 INFO  compiling root (1 scala source)
2024.01.12 13:40:25 INFO  time: compiled root in 0.55s
Exception in thread "pool-6-thread-22" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:40:53 INFO  compiling root (1 scala source)
2024.01.12 13:40:53 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
2024.01.12 13:40:53 INFO  time: compiled root in 0.54s
2024.01.12 13:40:55 INFO  compiling root (1 scala source)
2024.01.12 13:40:55 INFO  time: compiled root in 38ms
2024.01.12 13:40:56 INFO  compiling root (1 scala source)
2024.01.12 13:40:56 INFO  time: compiled root in 43ms
ene 12, 2024 1:40:58 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2914
Exception in thread "pool-6-thread-23" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:41:04 INFO  compiling root (1 scala source)
2024.01.12 13:41:04 INFO  time: compiled root in 49ms
2024.01.12 13:41:08 INFO  compiling root (1 scala source)
2024.01.12 13:41:08 INFO  time: compiled root in 39ms
2024.01.12 13:41:12 INFO  compiling root (1 scala source)
2024.01.12 13:41:12 INFO  time: compiled root in 0.2s
2024.01.12 13:41:14 INFO  compiling root (1 scala source)
2024.01.12 13:41:14 INFO  time: compiled root in 37ms
2024.01.12 13:41:14 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 49m 6.093s)
2024.01.12 13:41:14 INFO  compiling root (1 scala source)
2024.01.12 13:41:14 INFO  compiling root (1 scala source)
2024.01.12 13:41:14 INFO  time: compiled root in 25ms
2024.01.12 13:41:17 INFO  compiling root (1 scala source)
2024.01.12 13:41:17 INFO  time: compiled root in 36ms
2024.01.12 13:41:24 INFO  compiling root (1 scala source)
2024.01.12 13:41:24 INFO  time: compiled root in 45ms
2024.01.12 13:41:33 INFO  compiling root (1 scala source)
2024.01.12 13:41:33 INFO  time: compiled root in 0.57s
2024.01.12 13:41:35 INFO  compiling root (1 scala source)
2024.01.12 13:41:35 INFO  time: compiled root in 0.53s
2024.01.12 13:43:00 INFO  compiling root (1 scala source)
2024.01.12 13:43:00 INFO  time: compiled root in 65ms
2024.01.12 13:45:56 INFO  compiling root (1 scala source)
2024.01.12 13:45:56 INFO  time: compiled root in 63ms
2024.01.12 13:45:59 INFO  compiling root (1 scala source)
2024.01.12 13:45:59 INFO  time: compiled root in 61ms
2024.01.12 13:45:59 INFO  compiling root (1 scala source)
2024.01.12 13:45:59 INFO  time: compiled root in 50ms
ene 12, 2024 1:45:59 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.01.12 13:45:59 INFO  compiling root (1 scala source)
2024.01.12 13:45:59 INFO  time: compiled root in 76ms
ene 12, 2024 1:46:06 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 12, 2024 1:46:06 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

2024.01.12 13:46:34 INFO  compiling root (1 scala source)
2024.01.12 13:46:34 INFO  time: compiled root in 69ms
2024.01.12 13:46:44 INFO  compiling root (1 scala source)
2024.01.12 13:46:44 INFO  time: compiled root in 68ms
2024.01.12 13:46:53 WARN  Using indexes to guess the definition of distributeActions
2024.01.12 13:46:53 INFO  compiling root (1 scala source)
2024.01.12 13:46:53 INFO  time: compiled root in 48ms
2024.01.12 13:47:05 INFO  compiling root (1 scala source)
2024.01.12 13:47:05 INFO  time: compiled root in 41ms
2024.01.12 13:47:08 INFO  compiling root (1 scala source)
2024.01.12 13:47:08 INFO  time: compiled root in 92ms
2024.01.12 13:47:14 INFO  compiling root (1 scala source)
2024.01.12 13:47:14 INFO  time: compiled root in 42ms
2024.01.12 13:47:18 INFO  compiling root (1 scala source)
2024.01.12 13:47:18 INFO  time: compiled root in 0.12s
2024.01.12 13:47:35 INFO  compiling root (1 scala source)
2024.01.12 13:47:35 INFO  time: compiled root in 93ms
2024.01.12 13:47:35 INFO  compiling root (1 scala source)
2024.01.12 13:47:35 INFO  time: compiled root in 61ms
ene 12, 2024 1:47:50 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3419
2024.01.12 13:48:05 WARN  Using indexes to guess the definition of invoke
2024.01.12 13:48:05 WARN  Using indexes to guess the definition of invoke
2024.01.12 13:49:08 INFO  compiling root (1 scala source)
2024.01.12 13:49:08 INFO  time: compiled root in 80ms
2024.01.12 13:49:19 INFO  compiling root (1 scala source)
2024.01.12 13:49:19 INFO  time: compiled root in 75ms
2024.01.12 13:49:23 INFO  compiling root (1 scala source)
2024.01.12 13:49:23 INFO  time: compiled root in 77ms
2024.01.12 13:49:26 INFO  compiling root (1 scala source)
2024.01.12 13:49:26 INFO  time: compiled root in 81ms
2024.01.12 13:50:12 WARN  Using indexes to guess the definition of empty
2024.01.12 13:50:13 INFO  compiling root (1 scala source)
2024.01.12 13:50:13 INFO  time: compiled root in 0.69s
2024.01.12 13:54:59 INFO  compiling root (1 scala source)
2024.01.12 13:54:59 INFO  time: compiled root in 0.6s
Exception in thread "pool-6-thread-24" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.12 13:55:14 INFO  compiling root (1 scala source)
2024.01.12 13:55:14 INFO  time: compiled root in 0.56s
2024.01.12 13:55:17 INFO  compiling root (1 scala source)
2024.01.12 13:55:17 INFO  time: compiled root in 0.6s
2024.01.12 13:56:32 INFO  compiling root (1 scala source)
2024.01.12 13:56:32 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala
2024.01.12 13:56:32 INFO  time: compiled root in 68ms
2024.01.12 13:56:32 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala
ene 12, 2024 1:56:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3697
ene 12, 2024 1:56:49 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 12, 2024 1:56:49 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\APIs.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

2024.01.12 13:56:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala
2024.01.12 13:56:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala
2024.01.12 13:56:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala
2024.01.12 13:56:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala
2024.01.12 13:56:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala
2024.01.12 13:56:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala
2024.01.12 13:56:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala
2024.01.12 14:00:29 INFO  Shutting down server
2024.01.12 14:00:29 INFO  shutting down Metals
2024.01.12 14:00:29 INFO  Shut down connection with build server.
2024.01.12 14:00:29 INFO  Shut down connection with build server.
2024.01.12 14:00:29 INFO  Exiting server
2024.01.13 14:59:58 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\scalaTAP' for client Visual Studio Code 1.85.1.
2024.01.13 15:00:00 INFO  Attempting to connect to the build server...
2024.01.13 15:00:00 INFO  skipping build import with status 'Installed'
2024.01.13 15:00:00 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.13 15:00:03 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.13 15:00:04 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.13 15:00:04 INFO  Attempting to connect to the build server...
2024.01.13 15:00:04 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.13 15:00:04 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.13 15:00:04 INFO  time: Connected to build server in 4.28s
2024.01.13 15:00:04 INFO  Connected to Build server: Bloop v1.5.13
2024.01.13 15:00:04 INFO  time: Imported build in 0.14s
2024.01.13 15:00:06 INFO  time: indexed workspace in 2.26s
2024.01.13 15:05:03 INFO  compiling root (1 scala source)
2024.01.13 15:05:05 INFO  compiling root (1 scala source)
2024.01.13 15:05:06 INFO  time: compiled root in 1.31s
2024.01.13 15:05:20 INFO  compiling root (1 scala source)
2024.01.13 15:05:20 INFO  time: compiled root in 0.98s
2024.01.13 15:05:30 INFO  compiling root (1 scala source)
2024.01.13 15:05:31 INFO  time: compiled root in 1.07s
ene 13, 2024 3:05:31 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 140
2024.01.13 15:05:34 INFO  compiling root (1 scala source)
2024.01.13 15:05:34 INFO  time: compiled root in 0.85s
2024.01.13 15:05:44 INFO  compiling root (1 scala source)
2024.01.13 15:05:44 INFO  time: compiled root in 0.82s
2024.01.13 15:06:07 INFO  compiling root (1 scala source)
2024.01.13 15:06:07 INFO  time: compiled root in 0.79s
2024.01.13 15:06:23 INFO  compiling root (1 scala source)
2024.01.13 15:06:23 INFO  time: compiled root in 0.86s
2024.01.13 15:06:27 INFO  compiling root (1 scala source)
2024.01.13 15:06:27 INFO  time: compiled root in 0.73s
2024.01.13 15:06:34 INFO  compiling root (1 scala source)
2024.01.13 15:06:34 INFO  time: compiled root in 0.71s
2024.01.13 15:06:37 INFO  compiling root (1 scala source)
2024.01.13 15:06:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\scalaTAP\src\main\scala\example\MacroWorkSpace.scala
2024.01.13 15:06:37 INFO  time: compiled root in 0.67s
2024.01.13 15:07:03 INFO  compiling root (1 scala source)
2024.01.13 15:07:03 INFO  time: compiled root in 0.11s
2024.01.13 15:07:06 INFO  compiling root (1 scala source)
2024.01.13 15:07:06 INFO  time: compiled root in 0.67s
2024.01.13 15:07:07 INFO  compiling root (1 scala source)
2024.01.13 15:07:07 INFO  time: compiled root in 0.27s
ene 13, 2024 3:07:16 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.01.13 15:07:52 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.13 15:07:52 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.13 15:07:52 INFO  Starting debug proxy for [example.Tests()]
2024.01.13 15:07:53 INFO  Trying to attach to remote debuggee VM 127.0.0.1:63541 .
2024.01.13 15:07:53 INFO  Attaching to debuggee VM succeeded.
2024.01.13 15:07:53 INFO  Canceling debug proxy for [example.Tests()]
2024.01.13 15:07:53 INFO  Closing debug server tcp://0.0.0.0:63536
2024.01.13 15:08:12 INFO  compiling root-test (1 scala source)
2024.01.13 15:08:12 INFO  time: compiled root-test in 0.48s
2024.01.13 15:08:14 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.13 15:08:14 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.13 15:08:14 INFO  Starting debug proxy for [example.Tests()]
2024.01.13 15:08:14 INFO  Trying to attach to remote debuggee VM 127.0.0.1:63551 .
2024.01.13 15:08:14 INFO  Attaching to debuggee VM succeeded.
2024.01.13 15:08:14 INFO  Canceling debug proxy for [example.Tests()]
2024.01.13 15:08:14 INFO  Closing debug server tcp://0.0.0.0:63548
2024.01.13 15:08:22 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.13 15:08:22 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.13 15:08:22 INFO  Starting debug proxy for [example.Tests()]
2024.01.13 15:08:22 INFO  Trying to attach to remote debuggee VM 127.0.0.1:63561 .
2024.01.13 15:08:22 INFO  Attaching to debuggee VM succeeded.
2024.01.13 15:08:22 INFO  Canceling debug proxy for [example.Tests()]
2024.01.13 15:08:22 INFO  Closing debug server tcp://0.0.0.0:63558
2024.01.13 15:24:36 INFO  compiling root-test (1 scala source)
2024.01.13 15:24:36 INFO  time: compiled root-test in 69ms
2024.01.13 15:24:39 INFO  compiling root-test (1 scala source)
2024.01.13 15:24:39 INFO  time: compiled root-test in 68ms
2024.01.13 15:24:51 INFO  compiling root (1 scala source)
2024.01.13 15:24:51 INFO  time: compiled root in 98ms
2024.01.13 15:24:54 INFO  compiling root (1 scala source)
2024.01.13 15:24:54 INFO  time: compiled root in 0.13s
2024.01.13 15:24:59 INFO  compiling root (1 scala source)
2024.01.13 15:24:59 INFO  time: compiled root in 0.69s
2024.01.13 15:24:59 INFO  compiling root (1 scala source)
2024.01.13 15:24:59 INFO  time: compiled root in 0.25s
2024.01.13 15:25:05 INFO  compiling root (1 scala source)
2024.01.13 15:25:05 INFO  time: compiled root in 80ms
2024.01.13 15:25:07 INFO  compiling root (1 scala source)
2024.01.13 15:25:07 INFO  time: compiled root in 78ms
2024.01.13 15:25:09 INFO  compiling root (1 scala source)
2024.01.13 15:25:09 INFO  time: compiled root in 82ms
2024.01.13 15:25:16 INFO  compiling root (1 scala source)
2024.01.13 15:25:16 INFO  time: compiled root in 45ms
2024.01.13 15:25:18 INFO  compiling root (1 scala source)
2024.01.13 15:25:18 INFO  time: compiled root in 79ms
2024.01.13 15:25:19 INFO  compiling root (1 scala source)
2024.01.13 15:25:19 INFO  time: compiled root in 95ms
2024.01.13 15:25:19 INFO  compiling root (1 scala source)
2024.01.13 15:25:19 INFO  time: compiled root in 62ms
2024.01.13 15:25:23 INFO  compiling root (1 scala source)
2024.01.13 15:25:23 INFO  time: compiled root in 74ms
2024.01.13 15:25:36 INFO  compiling root (1 scala source)
2024.01.13 15:25:36 INFO  time: compiled root in 74ms
2024.01.13 15:25:42 INFO  compiling root (1 scala source)
2024.01.13 15:25:42 INFO  time: compiled root in 0.64s
2024.01.13 15:44:22 INFO  compiling root-test (1 scala source)
2024.01.13 15:44:22 INFO  time: compiled root-test in 71ms
2024.01.13 15:44:31 INFO  compiling root-test (1 scala source)
2024.01.13 15:44:31 INFO  time: compiled root-test in 0.37s
2024.01.13 15:44:32 INFO  compiling root-test (1 scala source)
2024.01.13 15:44:32 INFO  time: compiled root-test in 99ms
2024.01.13 15:44:36 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.13 15:44:36 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\scalaTAP\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.13 15:44:36 INFO  Starting debug proxy for [example.Tests()]
2024.01.13 15:44:36 INFO  Trying to attach to remote debuggee VM 127.0.0.1:64256 .
2024.01.13 15:44:36 INFO  Attaching to debuggee VM succeeded.
2024.01.13 15:44:37 INFO  Canceling debug proxy for [example.Tests()]
2024.01.13 15:44:36 INFO  Closing debug server tcp://0.0.0.0:64253
2024.01.13 15:44:39 INFO  Shutting down server
2024.01.13 15:44:39 INFO  shutting down Metals
2024.01.13 15:44:39 INFO  Shut down connection with build server.
2024.01.13 15:44:39 INFO  Shut down connection with build server.
2024.01.13 15:44:39 INFO  Exiting server
2024.01.23 14:11:32 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.23 14:11:33 INFO  Attempting to connect to the build server...
2024.01.23 14:11:33 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 14:11:33 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
ene 23, 2024 2:11:33 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1
ene 23, 2024 2:11:33 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2
2024.01.23 14:11:33 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:11:35 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:11:36 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.23 14:11:37 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 14:11:37 INFO  Attempting to connect to the build server...
2024.01.23 14:11:37 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 14:11:37 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 14:11:37 INFO  time: Connected to build server in 4.38s
2024.01.23 14:11:37 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 14:11:38 INFO  time: Imported build in 0.14s
2024.01.23 14:11:39 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.23 14:11:40 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala. Using presentation compiler with project's scala-library version: 2.13.12
2024.01.23 14:11:40 INFO  time: indexed workspace in 2.88s
2024.01.23 14:11:40 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:11:40 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:11:41 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:11:44 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:11:45 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:11:48 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:11:51 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:12:03 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:12:06 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
ene 23, 2024 2:12:07 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
ene 23, 2024 2:12:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 100
ene 23, 2024 2:12:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 106
2024.01.23 14:23:18 INFO  Shutting down server
2024.01.23 14:23:18 INFO  shutting down Metals
2024.01.23 14:23:18 INFO  Shut down connection with build server.
2024.01.23 14:23:18 INFO  Shut down connection with build server.
2024.01.23 14:23:18 INFO  Exiting server
2024.01.23 14:26:00 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.23 14:26:00 INFO  Attempting to connect to the build server...
2024.01.23 14:26:00 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 14:26:00 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 14:26:00 INFO  Attempting to connect to the build server...
2024.01.23 14:26:00 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 14:26:00 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 14:26:00 INFO  time: Connected to build server in 0.33s
2024.01.23 14:26:00 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 14:26:03 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala. Using presentation compiler with project's scala-library version: 2.13.12
2024.01.23 14:26:03 INFO  time: indexed workspace in 2.8s
2024.01.23 14:26:03 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:26:56 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
ene 23, 2024 2:27:01 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-27-01-063.md
ene 23, 2024 2:27:02 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-27-02-810.md
ene 23, 2024 2:27:03 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-27-03-342.md
ene 23, 2024 2:27:03 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-27-03-901.md
ene 23, 2024 2:27:06 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-27-06-034.md
2024.01.23 14:27:06 ERROR Failed to tokenize input for semantic tokens for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
scala.meta.tokenizers.TokenizeException: <input>:4: error: unclosed comment
/*WordCount
^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1583)

ene 23, 2024 2:27:06 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-27-06-644.md
ene 23, 2024 2:27:06 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-27-06-991.md
ene 23, 2024 2:27:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: file:///C:/URV/Progra/RepositorioGitHub/Scala-Projects/src/main/scala/example/MacroWorkSpace.scala:4: error: unclosed comment
/*WordCount
^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.mtags.ScalaToplevelMtags.loop(ScalaToplevelMtags.scala:436)
	at scala.meta.internal.mtags.ScalaToplevelMtags.indexRoot(ScalaToplevelMtags.scala:56)
	at scala.meta.internal.mtags.MtagsIndexer.index(MtagsIndexer.scala:19)
	at scala.meta.internal.mtags.MtagsIndexer.index$(MtagsIndexer.scala:18)
	at scala.meta.internal.mtags.ScalaToplevelMtags.index(ScalaToplevelMtags.scala:43)
	at scala.meta.internal.mtags.Mtags$.allToplevels(Mtags.scala:125)
	at scala.meta.internal.metals.DefinitionProvider.fromMtags(DefinitionProvider.scala:384)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$4(DefinitionProvider.scala:304)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$1(DefinitionProvider.scala:304)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.positionOccurrence(DefinitionProvider.scala:296)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionOrReferences$1(MetalsLspService.scala:2524)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:2520)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:1409)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:1408)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:373)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more

ene 23, 2024 2:27:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 58
ene 23, 2024 2:27:07 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-27-07-045.md
ene 23, 2024 2:27:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: file:///C:/URV/Progra/RepositorioGitHub/Scala-Projects/src/main/scala/example/MacroWorkSpace.scala:4: error: unclosed comment
/*WordCount
^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.mtags.ScalaToplevelMtags.loop(ScalaToplevelMtags.scala:436)
	at scala.meta.internal.mtags.ScalaToplevelMtags.indexRoot(ScalaToplevelMtags.scala:56)
	at scala.meta.internal.mtags.MtagsIndexer.index(MtagsIndexer.scala:19)
	at scala.meta.internal.mtags.MtagsIndexer.index$(MtagsIndexer.scala:18)
	at scala.meta.internal.mtags.ScalaToplevelMtags.index(ScalaToplevelMtags.scala:43)
	at scala.meta.internal.mtags.Mtags$.allToplevels(Mtags.scala:125)
	at scala.meta.internal.metals.DefinitionProvider.fromMtags(DefinitionProvider.scala:384)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$4(DefinitionProvider.scala:304)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$1(DefinitionProvider.scala:304)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.positionOccurrence(DefinitionProvider.scala:296)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionOrReferences$1(MetalsLspService.scala:2524)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:2520)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:1409)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:1408)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:373)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more

2024.01.23 14:27:07 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
ene 23, 2024 2:27:07 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-27-07-121.md
2024.01.23 14:27:06 ERROR Failed to tokenize input for semantic tokens for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
scala.meta.tokenizers.TokenizeException: <input>:4: error: unclosed comment
/*WordCount
^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1583)

ene 23, 2024 2:27:07 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-27-07-173.md
ene 23, 2024 2:27:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: file:///C:/URV/Progra/RepositorioGitHub/Scala-Projects/src/main/scala/example/MacroWorkSpace.scala:4: error: unclosed comment
/*WordCount
^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.mtags.ScalaToplevelMtags.loop(ScalaToplevelMtags.scala:436)
	at scala.meta.internal.mtags.ScalaToplevelMtags.indexRoot(ScalaToplevelMtags.scala:56)
	at scala.meta.internal.mtags.MtagsIndexer.index(MtagsIndexer.scala:19)
	at scala.meta.internal.mtags.MtagsIndexer.index$(MtagsIndexer.scala:18)
	at scala.meta.internal.mtags.ScalaToplevelMtags.index(ScalaToplevelMtags.scala:43)
	at scala.meta.internal.mtags.Mtags$.allToplevels(Mtags.scala:125)
	at scala.meta.internal.metals.DefinitionProvider.fromMtags(DefinitionProvider.scala:384)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$4(DefinitionProvider.scala:304)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$1(DefinitionProvider.scala:304)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.positionOccurrence(DefinitionProvider.scala:296)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionOrReferences$1(MetalsLspService.scala:2524)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:2520)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:1409)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:1408)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:373)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more

2024.01.23 14:27:12 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
ene 23, 2024 2:27:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 72
2024.01.23 14:27:18 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:27:28 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:27:34 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:27:37 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:27:48 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:27:54 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
ene 23, 2024 2:28:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-41-035.md
ene 23, 2024 2:28:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-41-197.md
Exception in thread "pool-4-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:28:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-41-335.md
ene 23, 2024 2:28:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-41-478.md
Exception in thread "pool-4-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:28:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-41-596.md
ene 23, 2024 2:28:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-41-683.md
Exception in thread "pool-4-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:28:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-41-790.md
ene 23, 2024 2:28:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-41-869.md
Exception in thread "pool-4-thread-4" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:28:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-41-966.md
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-052.md
Exception in thread "pool-4-thread-5" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-169.md
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-256.md
Exception in thread "pool-4-thread-6" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-335.md
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-410.md
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-489.md
Exception in thread "pool-4-thread-7" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-563.md
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-639.md
Exception in thread "pool-4-thread-8" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-721.md
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-799.md
2024.01.23 14:28:42 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
ene 23, 2024 2:28:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-42-993.md
Exception in thread "pool-4-thread-9" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:28:43 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-43-072.md
ene 23, 2024 2:28:43 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-43-152.md
2024.01.23 14:28:43 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
ene 23, 2024 2:28:43 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-43-217.md
ene 23, 2024 2:28:43 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-43-303.md
ene 23, 2024 2:28:43 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-28-43-367.md
ene 23, 2024 2:28:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 229
ene 23, 2024 2:28:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 235
2024.01.23 14:28:43 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:28:43 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:28:44 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
Exception in thread "pool-4-thread-10" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:28:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 243
ene 23, 2024 2:28:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 247
2024.01.23 14:28:43 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:29:04 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
ene 23, 2024 2:29:05 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-29-05-590.md
ene 23, 2024 2:29:05 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-29-05-646.md
ene 23, 2024 2:29:05 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-29-05-701.md
2024.01.23 14:29:05 ERROR Failed to tokenize input for semantic tokens for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: unclosed string literal
  val texto = "Este es un ejemplo de texto. En este texto, vamos a contar el número de palabras
              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1583)

ene 23, 2024 2:29:05 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-29-05-819.md
ene 23, 2024 2:29:05 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-29-05-888.md
2024.01.23 14:29:06 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:29:07 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
ene 23, 2024 2:29:19 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_14-29-19-565.md
2024.01.23 14:29:19 ERROR Failed to tokenize input for semantic tokens for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: unclosed string literal
  val texto = "Este es un ejemplo de texto. En este texto, 
              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1583)

2024.01.23 14:29:21 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:31:36 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:32:00 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:32:01 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:32:02 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
ene 23, 2024 2:32:02 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 401
2024.01.23 14:32:03 WARN  Using indexes to guess the definition of countWords
2024.01.23 14:32:03 WARN  Using indexes to guess the definition of countWords
2024.01.23 14:32:03 WARN  Using indexes to guess the definition of wordCount
2024.01.23 14:32:03 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:32:05 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:32:06 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:32:07 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:33:04 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
Exception in thread "pool-4-thread-11" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 14:33:04 WARN  Using indexes to guess the definition of sampleText
2024.01.23 14:33:05 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:33:08 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:33:41 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:33:41 WARN  Using indexes to guess the definition of wordCount
2024.01.23 14:33:41 WARN  Using indexes to guess the definition of sampleText
2024.01.23 14:34:04 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:34:09 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:35:39 INFO  {
  "jsonrpc": "2.0",
  "id": "47",
  "error": {
    "code": -32600,
    "message": "No project associated with Uri(file:/C:/URV/Progra/RepositorioGitHub/scalaTAP/project?id\u003dscalatap-build)"
  }
}
2024.01.23 14:35:49 INFO  {
  "jsonrpc": "2.0",
  "id": "51",
  "error": {
    "code": -32600,
    "message": "No project associated with Uri(file:/C:/URV/Progra/RepositorioGitHub/scalaTAP/project?id\u003dscalatap-build)"
  }
}
2024.01.23 14:35:54 INFO  running 'C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals14529051608544091049\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.01.23 14:35:56 INFO  [info] welcome to sbt 1.9.7 (Oracle Corporation Java 21.0.1)
2024.01.23 14:35:56 INFO  skipping build import with status 'Dismissed'
2024.01.23 14:35:56 INFO  {
  "jsonrpc": "2.0",
  "id": "55",
  "error": {
    "code": -32600,
    "message": "No project associated with Uri(file:/C:/URV/Progra/RepositorioGitHub/scalaTAP/project?id\u003dscalatap-build)"
  }
}
2024.01.23 14:35:56 INFO  [info] loading settings for project scala-projects-build-build from metals.sbt ...
2024.01.23 14:35:57 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\project
2024.01.23 14:35:57 INFO  [info] loading settings for project scala-projects-build from metals.sbt ...
2024.01.23 14:35:57 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\Scala-Projects\project
2024.01.23 14:36:00 INFO  [success] Generated .bloop\scala-projects-build.json
2024.01.23 14:36:00 INFO  [success] Total time: 2 s, completed 23 ene 2024, 14:36:00
2024.01.23 14:36:02 INFO  [info] loading settings for project root from build.sbt ...
2024.01.23 14:36:02 INFO  [info] set current project to P2 TAP (in build file:/C:/URV/Progra/RepositorioGitHub/Scala-Projects/)
2024.01.23 14:36:02 INFO  [success] Generated .bloop\root-test.json
2024.01.23 14:36:02 INFO  [success] Generated .bloop\root.json
2024.01.23 14:36:02 INFO  [success] Total time: 0 s, completed 23 ene 2024, 14:36:02
2024.01.23 14:36:03 INFO  time: ran 'sbt bloopInstall' in 8.19s
2024.01.23 14:36:03 INFO  Disconnecting from Bloop session...
2024.01.23 14:36:03 INFO  Shut down connection with build server.
2024.01.23 14:36:03 INFO  Shut down connection with build server.
2024.01.23 14:36:03 INFO  Attempting to connect to the build server...
2024.01.23 14:36:03 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 14:36:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 14:36:03 INFO  Attempting to connect to the build server...
2024.01.23 14:36:03 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 14:36:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 14:36:03 INFO  time: Connected to build server in 84ms
2024.01.23 14:36:03 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 14:36:04 INFO  time: indexed workspace in 1.5s
2024.01.23 14:36:05 INFO  compiling root (1 scala source)
2024.01.23 14:36:05 INFO  compiling scala-projects-build (1 scala source)
2024.01.23 14:36:06 INFO  time: code lens generation in 1.3s
2024.01.23 14:36:08 INFO  skipping build import with status 'Dismissed'
2024.01.23 14:36:08 INFO  Deduplicating compilation of scala-projects-build from bsp client 'Metals 1.2.0' (since 5.24s)
ene 23, 2024 2:36:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 567
2024.01.23 14:36:08 INFO  compiling scala-projects-build (1 scala source)
2024.01.23 14:36:09 INFO  skipping build import with status 'Dismissed'
2024.01.23 14:36:10 INFO  compiling root-test (1 scala source)
2024.01.23 14:36:10 INFO  time: compiled root-test in 0.24s
2024.01.23 14:36:10 INFO  time: compiled root in 4.4s
2024.01.23 14:36:12 INFO  skipping build import with status 'Dismissed'
2024.01.23 14:36:16 INFO  time: compiled scala-projects-build in 7.71s
2024.01.23 14:36:16 WARN  Using indexes to guess the definition of sampleText
2024.01.23 14:36:20 INFO  compiling root-test (1 scala source)
2024.01.23 14:36:20 INFO  time: compiled root-test in 0.12s
2024.01.23 14:36:27 WARN  Using indexes to guess the definition of FunSuite
2024.01.23 14:36:27 WARN  Using indexes to guess the definition of FunSuite
2024.01.23 14:36:27 WARN  Using indexes to guess the definition of wordCount
2024.01.23 14:36:27 WARN  Using indexes to guess the definition of sampleText
2024.01.23 14:36:27 WARN  Using indexes to guess the definition of sampleText
2024.01.23 14:36:28 INFO  compiling root-test (1 scala source)
2024.01.23 14:36:28 WARN  Using indexes to guess the definition of sampleText
2024.01.23 14:36:28 INFO  time: compiled root-test in 0.12s
2024.01.23 14:36:38 INFO  skipping build import with status 'Dismissed'
2024.01.23 14:36:41 WARN  Using indexes to guess the definition of sampleText
2024.01.23 14:36:41 INFO  compiling root-test (1 scala source)
2024.01.23 14:36:41 INFO  time: compiled root-test in 0.12s
2024.01.23 14:36:55 INFO  compiling root-test (1 scala source)
2024.01.23 14:36:55 INFO  time: compiled root-test in 53ms
2024.01.23 14:37:01 INFO  compiling root-test (1 scala source)
2024.01.23 14:37:01 INFO  time: compiled root-test in 0.1s
2024.01.23 14:37:12 INFO  compiling root-test (1 scala source)
2024.01.23 14:37:12 INFO  time: compiled root-test in 0.17s
ene 23, 2024 2:37:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 774
2024.01.23 14:37:23 WARN  Using indexes to guess the definition of wordCount
2024.01.23 14:37:23 INFO  compiling root-test (1 scala source)
2024.01.23 14:37:23 INFO  time: compiled root-test in 77ms
2024.01.23 14:37:47 INFO  compiling root (1 scala source)
2024.01.23 14:37:47 INFO  time: compiled root in 99ms
2024.01.23 14:37:49 INFO  compiling root (1 scala source)
2024.01.23 14:37:49 INFO  time: compiled root in 0.68s
2024.01.23 14:37:52 INFO  compiling root (1 scala source)
2024.01.23 14:37:52 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:37:52 INFO  time: compiled root in 0.53s
2024.01.23 14:37:53 INFO  compiling root (1 scala source)
2024.01.23 14:37:53 INFO  time: compiled root in 0.17s
2024.01.23 14:37:53 INFO  compiling root-test (1 scala source)
2024.01.23 14:37:53 INFO  time: compiled root-test in 55ms
2024.01.23 14:37:56 INFO  compiling root-test (1 scala source)
2024.01.23 14:37:56 INFO  time: compiled root-test in 80ms
2024.01.23 14:37:59 INFO  compiling root-test (1 scala source)
2024.01.23 14:37:59 INFO  time: compiled root-test in 64ms
2024.01.23 14:38:13 INFO  compiling root-test (1 scala source)
2024.01.23 14:38:13 INFO  time: compiled root-test in 63ms
2024.01.23 14:39:12 INFO  compiling root-test (1 scala source)
2024.01.23 14:39:12 INFO  time: compiled root-test in 63ms
2024.01.23 14:39:14 INFO  compiling root-test (1 scala source)
2024.01.23 14:39:14 INFO  time: compiled root-test in 62ms
2024.01.23 14:39:36 INFO  compiling root-test (1 scala source)
2024.01.23 14:39:36 INFO  time: compiled root-test in 53ms
2024.01.23 14:39:42 INFO  compiling root-test (1 scala source)
2024.01.23 14:39:42 INFO  time: compiled root-test in 37ms
2024.01.23 14:39:42 INFO  compiling root-test (1 scala source)
2024.01.23 14:39:43 INFO  time: compiled root-test in 52ms
2024.01.23 14:39:45 WARN  Using indexes to guess the definition of MacroWorkSpaceTests
2024.01.23 14:39:47 INFO  compiling root-test (1 scala source)
2024.01.23 14:39:47 INFO  time: compiled root-test in 62ms
Exception in thread "pool-10-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-10-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 14:39:49 WARN  Using indexes to guess the definition of wordCount
2024.01.23 14:40:25 INFO  compiling root-test (1 scala source)
2024.01.23 14:40:25 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 2:40:25 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * This method does not do any precondition checks on its arguments.\n     * \u003cp\u003e\n     * Important: parameter order of this method is deliberately changed in order to\n     * disambiguate it against other similar methods of this class.\n     */\n    @SuppressWarnings(\"removal\")\n    private String(Charset charset, byte[] bytes, int offset, int length) {\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     *\n     * @param  noShare\n     *         {@code true} if the resulting string MUST NOT share the byte array,\n     *         {@code false} if the byte array can be exclusively used to construct\n     *         the string and is not modified or used for any other purpose.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                if (noShare || length !\u003d bytes.length) {\n                    return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n                } else {\n                    return new String(bytes, LATIN1);\n                }\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return val.clone();\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            int positives \u003d StringCoding.countPositives(val, 0, val.length);\n            byte[] dst \u003d val.clone();\n            if (positives \u003c dst.length) {\n                replaceNegatives(dst, positives);\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static void replaceNegatives(byte[] val, int fromIndex) {\n        for (int i \u003d fromIndex; i \u003c val.length; i++) {\n            if (val[i] \u003c 0) {\n                val[i] \u003d \u0027?\u0027;\n            }\n        }\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return val.clone();\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16) {\n            return encodeUTF8_UTF16(val, doReplace);\n        }\n\n        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n            return val.clone();\n        }\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(Charset.defaultCharset(), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(Charset.defaultCharset(), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger than the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            return v1.length \u003c\u003d v2.length \u0026\u0026 ArraysSupport.mismatch(v1, v2, v1.length) \u003c 0;\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte[] v1 \u003d s1.value;\n            byte[] v2 \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n                ooffset \u003c\u003c\u003d UTF16;\n                len \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(tv, toffset,\n                    ov, ooffset, len) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte[] ta \u003d value;\n        byte[] pa \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(ta, toffset,\n                    pa, 0, pc) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code ch} in the string.\n     * If stricter behavior is needed, {@link #indexOf(int, int, int)}\n     * should be considered instead.\n     * On a {@link String} {@code s}, for example,\n     * {@code s.indexOf(ch, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, length())\n                : StringUTF16.indexOf(value, ch, fromIndex, length());\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at {@code beginIndex} and\n     * stopping before {@code endIndex}.\n     *\n     * \u003cp\u003eIf a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code beginIndex} but smaller than\n     * {@code endIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code beginIndex} and before position\n     * {@code endIndex}, then {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code beginIndex} and less than {@code endIndex},\n     *          or {@code -1} if the character does not occur.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(int ch, int beginIndex, int endIndex) {\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return isLatin1() ? StringLatin1.indexOf(value, ch, beginIndex, endIndex)\n                : StringUTF16.indexOf(value, ch, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code str} in the string.\n     * If stricter behavior is needed, {@link #indexOf(String, int, int)}\n     * should be considered instead.\n     * On {@link String} {@code s} and a non-empty {@code str}, for example,\n     * {@code s.indexOf(str, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified substring\n     * within the specified index range of {@code this} string.\n     *\n     * \u003cp\u003eThis method returns the same result as the one of the invocation\n     * \u003cpre\u003e{@code\n     *     s.substring(beginIndex, endIndex).indexOf(str) + beginIndex\n     * }\u003c/pre\u003e\n     * if the index returned by {@link #indexOf(String)} is non-negative,\n     * and returns -1 otherwise.\n     * (No substring is instantiated, though.)\n     *\n     * @param   str         the substring to search for.\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the specified substring\n     *          within the specified index range,\n     *          or {@code -1} if there is no such occurrence.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(String str, int beginIndex, int endIndex) {\n        if (str.length() \u003d\u003d 1) {\n            /* Simple optimization, can be omitted without behavioral impact */\n            return indexOf(str.charAt(0), beginIndex, endIndex);\n        }\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return indexOf(value, coder(), endIndex, str, beginIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  last index (exclusive) in the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        fromIndex \u003d Math.clamp(fromIndex, 0, srcCount);\n        int tgtCount \u003d tgtStr.length();\n        if (tgtCount \u003e srcCount - fromIndex) {\n            return -1;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        return split(regex, limit, false);\n    }\n\n    /**\n     * Splits this string around matches of the given regular expression and\n     * returns both the strings and the matching delimiters.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.\n     * Each substring is immediately followed by the subsequence (the delimiter)\n     * that matches the given expression, \u003cem\u003eexcept\u003c/em\u003e for the last\n     * substring, which is not followed by anything.\n     * The substrings in the array and the delimiters are in the order in which\n     * they occur in the input.\n     * If the expression does not match any part of the input then the resulting\n     * array has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring nor the empty delimiter.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than 2 \u0026times; \u003ci\u003elimit\u003c/i\u003e - 1, and the array\u0027s last\n     *    entry will contain all input beyond the last matched delimiter.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The input {@code \"boo:::and::foo\"}, for example, yields the following\n     * results with these parameters:\n     *\n     * \u003ctable class\u003d\"plain\" style\u003d\"margin-left:2em;\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:+\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and::foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @apiNote An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code splitWithDelimiters(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#splitWithDelimiters(CharSequence,int) splitWithDelimiters}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression, alternating\n     *          substrings and matching delimiters\n     *\n     * @since   21\n     */\n    public String[] splitWithDelimiters(String regex, int limit) {\n        return split(regex, limit, true);\n    }\n\n    private String[] split(String regex, int limit, boolean withDelimiters) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n                \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n                (regex.length() \u003d\u003d 2 \u0026\u0026\n                        regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n                        (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n                (ch \u003c Character.MIN_HIGH_SURROGATE ||\n                        ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            // All the checks above can potentially be constant folded by\n            // a JIT/AOT compiler when the regex is a constant string.\n            // That requires method inlining of the checks, which is only\n            // possible when the actual split logic is in a separate method\n            // because the large split loop can usually not be inlined.\n            return split(ch, limit, withDelimiters);\n        }\n        Pattern pattern \u003d Pattern.compile(regex);\n        return withDelimiters\n                ? pattern.splitWithDelimiters(this, limit)\n                : pattern.split(this, limit);\n    }\n\n    private String[] split(char ch, int limit, boolean withDelimiters) {\n        int matchCount \u003d 0;\n        int off \u003d 0;\n        int next;\n        boolean limited \u003d limit \u003e 0;\n        ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        String del \u003d withDelimiters ? String.valueOf(ch) : null;\n        while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n            if (!limited || matchCount \u003c limit - 1) {\n                list.add(substring(off, next));\n                if (withDelimiters) {\n                    list.add(del);\n                }\n                off \u003d next + 1;\n                ++matchCount;\n            } else {    // last one\n                int last \u003d length();\n                list.add(substring(off, last));\n                off \u003d last;\n                ++matchCount;\n                break;\n            }\n        }\n        // If no match was found, return this\n        if (off \u003d\u003d 0)\n            return new String[] {this};\n\n        // Add remaining segment\n        if (!limited || matchCount \u003c limit)\n            list.add(substring(off, length()));\n\n        // Construct result\n        int resultSize \u003d list.size();\n        if (limit \u003d\u003d 0) {\n            while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                resultSize--;\n            }\n        }\n        String[] result \u003d new String[resultSize];\n        return list.subList(0, resultSize).toArray(result);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0, false);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a {@linkplain\n     * Character##unicode surrogate code point} is passed through\n     * uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        repeatCopyRest(multiple, 0, limit, len);\n        return new String(multiple, coder);\n    }\n\n    /**\n     * Used to perform copying after the initial insertion. Copying is optimized\n     * by using power of two duplication. First pass duplicates original copy,\n     * second pass then duplicates the original and the copy yielding four copies,\n     * third pass duplicates four copies yielding eight copies, and so on.\n     * Finally, the remainder is filled in with prior copies.\n     *\n     * @implNote The technique used here is significantly faster than hand-rolled\n     * loops or special casing small numbers due to the intensive optimization\n     * done by intrinsic {@code System.arraycopy}.\n     *\n     * @param buffer    destination buffer\n     * @param offset    offset in the destination buffer\n     * @param limit     total replicated including what is already in the buffer\n     * @param copied    number of bytes that have already in the buffer\n     */\n    static void repeatCopyRest(byte[] buffer, int offset, int limit, int copied) {\n        // Initial copy is in the buffer.\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            // Power of two duplicate.\n            System.arraycopy(buffer, offset, buffer, offset + copied, copied);\n        }\n        // Duplicate remainder.\n        System.arraycopy(buffer, offset, buffer, offset + copied, limit - copied);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @return  {@code offset} if the sub-range within bounds of the range\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static int checkBoundsOffCount(int offset, int count, int length) {\n        return Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 2:40:25 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 14:40:25 INFO  time: compiled root-test in 76ms
ene 23, 2024 2:40:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1088
ene 23, 2024 2:40:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1086
ene 23, 2024 2:40:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1096
ene 23, 2024 2:40:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1097
ene 23, 2024 2:40:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1101
2024.01.23 14:40:44 INFO  compiling root-test (1 scala source)
2024.01.23 14:40:44 INFO  time: compiled root-test in 63ms
2024.01.23 14:40:55 INFO  compiling root-test (1 scala source)
2024.01.23 14:40:55 INFO  time: compiled root-test in 0.52s
2024.01.23 14:40:58 INFO  compiling root-test (1 scala source)
2024.01.23 14:40:58 INFO  time: compiled root-test in 0.52s
2024.01.23 14:41:02 INFO  compiling root (1 scala source)
2024.01.23 14:41:02 INFO  time: compiled root in 0.44s
2024.01.23 14:41:05 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:41:05 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:41:05 INFO  Starting debug proxy for [example.Tests()]
2024.01.23 14:41:05 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53687 .
2024.01.23 14:41:05 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:41:06 INFO  Canceling debug proxy for [example.Tests()]
2024.01.23 14:41:05 INFO  Closing debug server tcp://0.0.0.0:53683
2024.01.23 14:44:26 INFO  skipping build import with status 'Installed'
2024.01.23 14:44:26 INFO  skipping build import with status 'Installed'
2024.01.23 14:45:06 INFO  compiling root-test (1 scala source)
2024.01.23 14:45:06 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\example\Tests.scala
2024.01.23 14:45:06 INFO  time: compiled root-test in 0.48s
2024.01.23 14:45:10 INFO  compiling root (1 scala source)
2024.01.23 14:45:10 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
2024.01.23 14:45:10 INFO  time: compiled root in 0.59s
2024.01.23 14:45:10 INFO  compiling root-test (1 scala source)
2024.01.23 14:45:10 INFO  time: compiled root-test in 66ms
2024.01.23 14:45:12 INFO  compiling root-test (1 scala source)
2024.01.23 14:45:12 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 9m 9.832s)
2024.01.23 14:45:12 INFO  compiling root-test (1 scala source)
2024.01.23 14:45:12 INFO  time: compiled root-test in 32ms
2024.01.23 14:45:33 INFO  compiling root (1 scala source)
2024.01.23 14:45:33 INFO  time: compiled root in 0.46s
2024.01.23 14:45:44 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\Tests.scala
2024.01.23 14:45:46 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\MacroWorkSpace.scala
2024.01.23 14:45:46 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\Tests.scala
2024.01.23 14:45:49 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\Tests.scala
ene 23, 2024 2:45:57 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1331
ene 23, 2024 2:46:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1337
ene 23, 2024 2:46:01 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1344
2024.01.23 14:46:09 INFO  compiling root-test (1 scala source)
2024.01.23 14:46:09 INFO  time: compiled root-test in 80ms
2024.01.23 14:46:12 INFO  compiling root-test (1 scala source)
2024.01.23 14:46:12 INFO  time: compiled root-test in 0.1s
ene 23, 2024 2:46:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.NoSuchFileException: c:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\Tests.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.metals.DefinitionProvider.fromMtags(DefinitionProvider.scala:384)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$4(DefinitionProvider.scala:304)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$1(DefinitionProvider.scala:304)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.positionOccurrence(DefinitionProvider.scala:296)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionOrReferences$1(MetalsLspService.scala:2524)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:2520)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:1409)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:1408)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:373)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more

ene 23, 2024 2:46:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.NoSuchFileException: c:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\Tests.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.metals.DefinitionProvider.fromMtags(DefinitionProvider.scala:384)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$4(DefinitionProvider.scala:304)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$1(DefinitionProvider.scala:304)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.positionOccurrence(DefinitionProvider.scala:296)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionOrReferences$1(MetalsLspService.scala:2524)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:2520)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:1409)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:1408)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:373)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more

ene 23, 2024 2:46:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.NoSuchFileException: c:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\Tests.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.metals.DefinitionProvider.fromMtags(DefinitionProvider.scala:384)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$4(DefinitionProvider.scala:304)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$1(DefinitionProvider.scala:304)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.positionOccurrence(DefinitionProvider.scala:296)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionOrReferences$1(MetalsLspService.scala:2524)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:2520)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:1409)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:1408)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:373)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more

2024.01.23 14:46:17 INFO  compiling root-test (1 scala source)
2024.01.23 14:46:17 INFO  time: compiled root-test in 0.16s
2024.01.23 14:46:17 INFO  compiling root-test (1 scala source)
2024.01.23 14:46:17 INFO  time: compiled root-test in 56ms
2024.01.23 14:46:19 INFO  compiling root-test (1 scala source)
2024.01.23 14:46:19 INFO  time: compiled root-test in 62ms
2024.01.23 14:46:26 INFO  compiling root-test (1 scala source)
2024.01.23 14:46:26 INFO  time: compiled root-test in 60ms
2024.01.23 14:46:26 INFO  compiling root-test (1 scala source)
2024.01.23 14:46:26 INFO  time: compiled root-test in 46ms
2024.01.23 14:46:34 INFO  compiling root (1 scala source)
2024.01.23 14:46:34 INFO  time: compiled root in 0.45s
2024.01.23 14:46:35 INFO  compiling root-test (1 scala source)
2024.01.23 14:46:35 INFO  time: compiled root-test in 0.2s
2024.01.23 14:47:19 INFO  compiling root (1 scala source)
2024.01.23 14:47:19 INFO  time: compiled root in 0.45s
2024.01.23 14:47:19 INFO  compiling root-test (1 scala source)
2024.01.23 14:47:19 INFO  time: compiled root-test in 0.21s
2024.01.23 14:47:32 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:47:32 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:47:32 INFO  Starting debug proxy for [example.Tests()]
2024.01.23 14:47:32 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53714 .
2024.01.23 14:47:32 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:47:32 INFO  Canceling debug proxy for [example.Tests()]
2024.01.23 14:47:32 INFO  Closing debug server tcp://0.0.0.0:53711
2024.01.23 14:47:40 INFO  compiling root-test (1 scala source)
2024.01.23 14:47:40 INFO  time: compiled root-test in 0.43s
2024.01.23 14:47:44 INFO  compiling root (1 scala source)
2024.01.23 14:47:44 INFO  time: compiled root in 0.41s
2024.01.23 14:47:45 INFO  compiling root-test (1 scala source)
2024.01.23 14:47:45 INFO  time: compiled root-test in 66ms
2024.01.23 14:47:52 INFO  compiling root-test (1 scala source)
2024.01.23 14:47:53 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:47:52 INFO  time: compiled root-test in 0.44s
Exception in thread "pool-10-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
ene 23, 2024 2:48:00 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.01.23 14:49:44 INFO  compiling root (1 scala source)
2024.01.23 14:49:44 INFO  time: compiled root in 0.43s
2024.01.23 14:49:56 INFO  compiling root-test (1 scala source)
2024.01.23 14:49:56 INFO  time: compiled root-test in 0.1s
ene 23, 2024 2:49:57 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definitions(OnDemandSymbolIndex.scala:58)
	at scala.meta.internal.metals.DestinationProvider.definition(DefinitionProvider.scala:475)
	at scala.meta.internal.metals.DestinationProvider.fromSymbol(DefinitionProvider.scala:513)
	at scala.meta.internal.metals.DestinationProvider.fromSymbol(DefinitionProvider.scala:554)
	at scala.meta.internal.metals.DefinitionProvider.definitionResult$1(DefinitionProvider.scala:366)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definitionFromSnapshot$2(DefinitionProvider.scala:372)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.definitionFromSnapshot(DefinitionProvider.scala:372)
	at scala.meta.internal.metals.DefinitionProvider.definition(DefinitionProvider.scala:95)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionResult$1(MetalsLspService.scala:2581)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.definitionResult(MetalsLspService.scala:2581)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:2552)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:1409)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:1408)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:373)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 23, 2024 2:49:57 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\example\MacroWorkSpace.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definitions(OnDemandSymbolIndex.scala:58)
	at scala.meta.internal.metals.DestinationProvider.definition(DefinitionProvider.scala:475)
	at scala.meta.internal.metals.DestinationProvider.fromSymbol(DefinitionProvider.scala:513)
	at scala.meta.internal.metals.DestinationProvider.fromSymbol(DefinitionProvider.scala:554)
	at scala.meta.internal.metals.DefinitionProvider.definitionResult$1(DefinitionProvider.scala:366)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definitionFromSnapshot$2(DefinitionProvider.scala:372)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.definitionFromSnapshot(DefinitionProvider.scala:372)
	at scala.meta.internal.metals.DefinitionProvider.definition(DefinitionProvider.scala:95)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionResult$1(MetalsLspService.scala:2581)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.definitionResult(MetalsLspService.scala:2581)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:2552)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:1409)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:1408)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:373)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

2024.01.23 14:49:57 INFO  compiling root-test (1 scala source)
2024.01.23 14:49:57 INFO  time: compiled root-test in 0.47s
2024.01.23 14:50:00 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:50:00 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:50:00 INFO  Starting debug proxy for [test.Tests()]
2024.01.23 14:50:00 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53758 .
2024.01.23 14:50:00 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:50:01 INFO  Canceling debug proxy for [test.Tests()]
2024.01.23 14:50:00 INFO  Closing debug server tcp://0.0.0.0:53755
2024.01.23 14:50:04 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:50:04 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:50:05 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 14:50:05 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53769 .
2024.01.23 14:50:05 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:50:05 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 14:50:05 INFO  Closing debug server tcp://0.0.0.0:53766
2024.01.23 14:50:47 INFO  compiling root-test (1 scala source)
2024.01.23 14:50:47 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:50:47 INFO  time: compiled root-test in 0.47s
2024.01.23 14:50:54 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:50:54 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:50:54 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 14:50:54 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53782 .
2024.01.23 14:50:54 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:50:55 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 14:50:54 INFO  Closing debug server tcp://0.0.0.0:53779
2024.01.23 14:51:00 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:51:00 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:51:00 INFO  Starting debug proxy for [test.Tests()]
2024.01.23 14:51:00 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53790 .
2024.01.23 14:51:00 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:51:00 INFO  Canceling debug proxy for [test.Tests()]
2024.01.23 14:51:00 INFO  Closing debug server tcp://0.0.0.0:53787
2024.01.23 14:51:08 INFO  compiling root-test (1 scala source)
2024.01.23 14:51:08 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 15m 5.096s)
2024.01.23 14:51:08 INFO  compiling root-test (1 scala source)
2024.01.23 14:51:08 INFO  time: compiled root-test in 0.39s
2024.01.23 14:51:08 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:51:08 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:51:08 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 14:51:08 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53798 .
2024.01.23 14:51:08 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:51:08 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 14:51:09 INFO  Closing debug server tcp://0.0.0.0:53795
2024.01.23 14:51:24 INFO  compiling root-test (1 scala source)
2024.01.23 14:51:24 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:51:25 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:51:25 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:51:25 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:51:25 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:51:25 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:51:25 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:51:24 INFO  time: compiled root-test in 0.45s
2024.01.23 14:51:28 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:51:28 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:51:28 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 14:51:28 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53806 .
2024.01.23 14:51:28 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:51:28 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 14:51:28 INFO  Closing debug server tcp://0.0.0.0:53803
2024.01.23 14:52:08 INFO  compiling root-test (1 scala source)
Exception in thread "pool-10-thread-4" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 14:52:08 INFO  time: compiled root-test in 0.47s
2024.01.23 14:52:10 INFO  compiling root-test (1 scala source)
2024.01.23 14:52:10 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:52:10 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:52:10 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:52:10 INFO  time: compiled root-test in 0.63s
2024.01.23 14:52:48 INFO  compiling root-test (1 scala source)
2024.01.23 14:52:48 INFO  time: compiled root-test in 0.43s
2024.01.23 14:52:52 INFO  compiling root-test (1 scala source)
2024.01.23 14:52:52 INFO  time: compiled root-test in 0.42s
2024.01.23 14:53:01 INFO  compiling root-test (1 scala source)
2024.01.23 14:53:01 INFO  time: compiled root-test in 0.43s
2024.01.23 14:53:01 INFO  compiling root-test (1 scala source)
2024.01.23 14:53:02 INFO  time: compiled root-test in 0.13s
2024.01.23 14:53:04 INFO  compiling root-test (1 scala source)
2024.01.23 14:53:04 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:53:04 INFO  time: compiled root-test in 0.42s
2024.01.23 14:53:05 INFO  compiling root-test (1 scala source)
2024.01.23 14:53:05 INFO  time: compiled root-test in 0.42s
2024.01.23 14:53:09 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:53:09 INFO  compiling root-test (1 scala source)
2024.01.23 14:53:09 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:53:09 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:53:09 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:53:09 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:53:09 INFO  time: compiled root-test in 0.43s
2024.01.23 14:53:11 INFO  compiling root-test (1 scala source)
2024.01.23 14:53:11 INFO  time: compiled root-test in 0.41s
2024.01.23 14:53:13 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:53:13 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:53:13 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 14:53:13 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53819 .
2024.01.23 14:53:13 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:53:13 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 14:53:13 INFO  Closing debug server tcp://0.0.0.0:53816
2024.01.23 14:53:25 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:53:25 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:53:25 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 14:53:25 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53829 .
2024.01.23 14:53:25 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:53:26 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 14:53:25 INFO  Closing debug server tcp://0.0.0.0:53826
2024.01.23 14:53:56 INFO  compiling root-test (1 scala source)
2024.01.23 14:53:56 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:53:56 INFO  time: compiled root-test in 0.45s
2024.01.23 14:53:59 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:53:59 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:53:59 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 14:53:59 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53838 .
2024.01.23 14:53:59 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:53:59 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 14:53:59 INFO  Closing debug server tcp://0.0.0.0:53835
2024.01.23 14:55:17 WARN  Using indexes to guess the definition of counts
2024.01.23 14:55:18 WARN  Using indexes to guess the definition of counts
2024.01.23 14:55:18 WARN  Using indexes to guess the definition of counts
2024.01.23 14:55:18 WARN  Using indexes to guess the definition of counts
2024.01.23 14:55:19 WARN  Using indexes to guess the definition of counts
2024.01.23 14:55:19 WARN  Using indexes to guess the definition of counts
2024.01.23 14:55:20 INFO  compiling root-test (1 scala source)
2024.01.23 14:55:20 INFO  time: compiled root-test in 0.44s
2024.01.23 14:55:26 WARN  Using indexes to guess the definition of totalWords
2024.01.23 14:55:26 INFO  compiling root-test (1 scala source)
2024.01.23 14:55:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:55:26 INFO  time: compiled root-test in 0.41s
2024.01.23 14:55:28 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:55:28 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:55:28 INFO  Starting debug proxy for [test.Tests()]
2024.01.23 14:55:28 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53869 .
2024.01.23 14:55:28 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:55:29 INFO  Canceling debug proxy for [test.Tests()]
2024.01.23 14:55:28 INFO  Closing debug server tcp://0.0.0.0:53866
2024.01.23 14:55:52 INFO  compiling root (1 scala source)
2024.01.23 14:55:52 INFO  time: compiled root in 0.41s
2024.01.23 14:56:36 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 14:56:36 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 14:56:36 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 14:56:36 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53925 .
2024.01.23 14:56:36 INFO  Attaching to debuggee VM succeeded.
2024.01.23 14:56:36 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 14:56:36 INFO  Closing debug server tcp://0.0.0.0:53922
2024.01.23 14:56:39 INFO  compiling root-test (1 scala source)
2024.01.23 14:56:39 INFO  time: compiled root-test in 0.42s
2024.01.23 14:56:39 INFO  compiling root-test (1 scala source)
2024.01.23 14:56:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 14:56:40 INFO  time: compiled root-test in 0.12s
2024.01.23 14:56:42 INFO  compiling root-test (1 scala source)
2024.01.23 14:56:42 INFO  time: compiled root-test in 0.43s
2024.01.23 14:57:10 INFO  compiling root-test (1 scala source)
2024.01.23 14:57:10 INFO  time: compiled root-test in 0.64s
2024.01.23 14:57:35 INFO  compiling root (1 scala source)
2024.01.23 14:57:35 INFO  time: compiled root in 0.4s
2024.01.23 14:57:47 INFO  compiling root (1 scala source)
2024.01.23 14:57:47 INFO  time: compiled root in 0.4s
2024.01.23 14:59:33 INFO  compiling root (1 scala source)
2024.01.23 14:59:33 INFO  time: compiled root in 66ms
2024.01.23 14:59:40 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 2:59:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * This method does not do any precondition checks on its arguments.\n     * \u003cp\u003e\n     * Important: parameter order of this method is deliberately changed in order to\n     * disambiguate it against other similar methods of this class.\n     */\n    @SuppressWarnings(\"removal\")\n    private String(Charset charset, byte[] bytes, int offset, int length) {\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     *\n     * @param  noShare\n     *         {@code true} if the resulting string MUST NOT share the byte array,\n     *         {@code false} if the byte array can be exclusively used to construct\n     *         the string and is not modified or used for any other purpose.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                if (noShare || length !\u003d bytes.length) {\n                    return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n                } else {\n                    return new String(bytes, LATIN1);\n                }\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return val.clone();\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            int positives \u003d StringCoding.countPositives(val, 0, val.length);\n            byte[] dst \u003d val.clone();\n            if (positives \u003c dst.length) {\n                replaceNegatives(dst, positives);\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static void replaceNegatives(byte[] val, int fromIndex) {\n        for (int i \u003d fromIndex; i \u003c val.length; i++) {\n            if (val[i] \u003c 0) {\n                val[i] \u003d \u0027?\u0027;\n            }\n        }\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return val.clone();\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16) {\n            return encodeUTF8_UTF16(val, doReplace);\n        }\n\n        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n            return val.clone();\n        }\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(Charset.defaultCharset(), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(Charset.defaultCharset(), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger than the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            return v1.length \u003c\u003d v2.length \u0026\u0026 ArraysSupport.mismatch(v1, v2, v1.length) \u003c 0;\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte[] v1 \u003d s1.value;\n            byte[] v2 \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n                ooffset \u003c\u003c\u003d UTF16;\n                len \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(tv, toffset,\n                    ov, ooffset, len) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte[] ta \u003d value;\n        byte[] pa \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(ta, toffset,\n                    pa, 0, pc) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code ch} in the string.\n     * If stricter behavior is needed, {@link #indexOf(int, int, int)}\n     * should be considered instead.\n     * On a {@link String} {@code s}, for example,\n     * {@code s.indexOf(ch, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, length())\n                : StringUTF16.indexOf(value, ch, fromIndex, length());\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at {@code beginIndex} and\n     * stopping before {@code endIndex}.\n     *\n     * \u003cp\u003eIf a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code beginIndex} but smaller than\n     * {@code endIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code beginIndex} and before position\n     * {@code endIndex}, then {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code beginIndex} and less than {@code endIndex},\n     *          or {@code -1} if the character does not occur.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(int ch, int beginIndex, int endIndex) {\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return isLatin1() ? StringLatin1.indexOf(value, ch, beginIndex, endIndex)\n                : StringUTF16.indexOf(value, ch, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code str} in the string.\n     * If stricter behavior is needed, {@link #indexOf(String, int, int)}\n     * should be considered instead.\n     * On {@link String} {@code s} and a non-empty {@code str}, for example,\n     * {@code s.indexOf(str, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified substring\n     * within the specified index range of {@code this} string.\n     *\n     * \u003cp\u003eThis method returns the same result as the one of the invocation\n     * \u003cpre\u003e{@code\n     *     s.substring(beginIndex, endIndex).indexOf(str) + beginIndex\n     * }\u003c/pre\u003e\n     * if the index returned by {@link #indexOf(String)} is non-negative,\n     * and returns -1 otherwise.\n     * (No substring is instantiated, though.)\n     *\n     * @param   str         the substring to search for.\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the specified substring\n     *          within the specified index range,\n     *          or {@code -1} if there is no such occurrence.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(String str, int beginIndex, int endIndex) {\n        if (str.length() \u003d\u003d 1) {\n            /* Simple optimization, can be omitted without behavioral impact */\n            return indexOf(str.charAt(0), beginIndex, endIndex);\n        }\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return indexOf(value, coder(), endIndex, str, beginIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  last index (exclusive) in the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        fromIndex \u003d Math.clamp(fromIndex, 0, srcCount);\n        int tgtCount \u003d tgtStr.length();\n        if (tgtCount \u003e srcCount - fromIndex) {\n            return -1;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        return split(regex, limit, false);\n    }\n\n    /**\n     * Splits this string around matches of the given regular expression and\n     * returns both the strings and the matching delimiters.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.\n     * Each substring is immediately followed by the subsequence (the delimiter)\n     * that matches the given expression, \u003cem\u003eexcept\u003c/em\u003e for the last\n     * substring, which is not followed by anything.\n     * The substrings in the array and the delimiters are in the order in which\n     * they occur in the input.\n     * If the expression does not match any part of the input then the resulting\n     * array has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring nor the empty delimiter.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than 2 \u0026times; \u003ci\u003elimit\u003c/i\u003e - 1, and the array\u0027s last\n     *    entry will contain all input beyond the last matched delimiter.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The input {@code \"boo:::and::foo\"}, for example, yields the following\n     * results with these parameters:\n     *\n     * \u003ctable class\u003d\"plain\" style\u003d\"margin-left:2em;\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:+\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and::foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @apiNote An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code splitWithDelimiters(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#splitWithDelimiters(CharSequence,int) splitWithDelimiters}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression, alternating\n     *          substrings and matching delimiters\n     *\n     * @since   21\n     */\n    public String[] splitWithDelimiters(String regex, int limit) {\n        return split(regex, limit, true);\n    }\n\n    private String[] split(String regex, int limit, boolean withDelimiters) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n                \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n                (regex.length() \u003d\u003d 2 \u0026\u0026\n                        regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n                        (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n                (ch \u003c Character.MIN_HIGH_SURROGATE ||\n                        ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            // All the checks above can potentially be constant folded by\n            // a JIT/AOT compiler when the regex is a constant string.\n            // That requires method inlining of the checks, which is only\n            // possible when the actual split logic is in a separate method\n            // because the large split loop can usually not be inlined.\n            return split(ch, limit, withDelimiters);\n        }\n        Pattern pattern \u003d Pattern.compile(regex);\n        return withDelimiters\n                ? pattern.splitWithDelimiters(this, limit)\n                : pattern.split(this, limit);\n    }\n\n    private String[] split(char ch, int limit, boolean withDelimiters) {\n        int matchCount \u003d 0;\n        int off \u003d 0;\n        int next;\n        boolean limited \u003d limit \u003e 0;\n        ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        String del \u003d withDelimiters ? String.valueOf(ch) : null;\n        while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n            if (!limited || matchCount \u003c limit - 1) {\n                list.add(substring(off, next));\n                if (withDelimiters) {\n                    list.add(del);\n                }\n                off \u003d next + 1;\n                ++matchCount;\n            } else {    // last one\n                int last \u003d length();\n                list.add(substring(off, last));\n                off \u003d last;\n                ++matchCount;\n                break;\n            }\n        }\n        // If no match was found, return this\n        if (off \u003d\u003d 0)\n            return new String[] {this};\n\n        // Add remaining segment\n        if (!limited || matchCount \u003c limit)\n            list.add(substring(off, length()));\n\n        // Construct result\n        int resultSize \u003d list.size();\n        if (limit \u003d\u003d 0) {\n            while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                resultSize--;\n            }\n        }\n        String[] result \u003d new String[resultSize];\n        return list.subList(0, resultSize).toArray(result);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0, false);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a {@linkplain\n     * Character##unicode surrogate code point} is passed through\n     * uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        repeatCopyRest(multiple, 0, limit, len);\n        return new String(multiple, coder);\n    }\n\n    /**\n     * Used to perform copying after the initial insertion. Copying is optimized\n     * by using power of two duplication. First pass duplicates original copy,\n     * second pass then duplicates the original and the copy yielding four copies,\n     * third pass duplicates four copies yielding eight copies, and so on.\n     * Finally, the remainder is filled in with prior copies.\n     *\n     * @implNote The technique used here is significantly faster than hand-rolled\n     * loops or special casing small numbers due to the intensive optimization\n     * done by intrinsic {@code System.arraycopy}.\n     *\n     * @param buffer    destination buffer\n     * @param offset    offset in the destination buffer\n     * @param limit     total replicated including what is already in the buffer\n     * @param copied    number of bytes that have already in the buffer\n     */\n    static void repeatCopyRest(byte[] buffer, int offset, int limit, int copied) {\n        // Initial copy is in the buffer.\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            // Power of two duplicate.\n            System.arraycopy(buffer, offset, buffer, offset + copied, copied);\n        }\n        // Duplicate remainder.\n        System.arraycopy(buffer, offset, buffer, offset + copied, limit - copied);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @return  {@code offset} if the sub-range within bounds of the range\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static int checkBoundsOffCount(int offset, int count, int length) {\n        return Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 2:59:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 14:59:40 INFO  compiling root (1 scala source)
2024.01.23 14:59:40 INFO  time: compiled root in 0.55s
2024.01.23 14:59:46 INFO  compiling root (1 scala source)
2024.01.23 14:59:46 INFO  time: compiled root in 0.45s
2024.01.23 15:00:02 INFO  compiling root (1 scala source)
2024.01.23 15:00:02 INFO  time: compiled root in 0.45s
2024.01.23 15:00:02 INFO  compiling root (1 scala source)
2024.01.23 15:00:03 INFO  time: compiled root in 0.11s
2024.01.23 15:00:04 INFO  compiling root (1 scala source)
2024.01.23 15:00:04 INFO  time: compiled root in 33ms
2024.01.23 15:00:06 INFO  compiling root (1 scala source)
2024.01.23 15:00:06 INFO  time: compiled root in 0.43s
2024.01.23 15:00:09 INFO  compiling root (1 scala source)
2024.01.23 15:00:09 INFO  time: compiled root in 0.43s
2024.01.23 15:00:09 INFO  compiling root (1 scala source)
2024.01.23 15:00:09 INFO  time: compiled root in 0.11s
2024.01.23 15:00:19 INFO  compiling root (1 scala source)
2024.01.23 15:00:19 INFO  time: compiled root in 0.43s
2024.01.23 15:00:20 INFO  compiling root (1 scala source)
2024.01.23 15:00:20 INFO  time: compiled root in 0.11s
2024.01.23 15:00:30 INFO  compiling root (1 scala source)
2024.01.23 15:00:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\MacroWorkSpace.scala
2024.01.23 15:00:30 INFO  time: compiled root in 0.44s
2024.01.23 15:01:18 INFO  compiling root-test (1 scala source)
2024.01.23 15:01:18 INFO  time: compiled root-test in 0.41s
2024.01.23 15:01:25 INFO  compiling root (1 scala source)
2024.01.23 15:01:25 INFO  time: compiled root in 0.46s
2024.01.23 15:01:26 INFO  compiling root-test (1 scala source)
2024.01.23 15:01:26 INFO  time: compiled root-test in 66ms
2024.01.23 15:01:30 INFO  compiling root (1 scala source)
2024.01.23 15:01:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\MacroWorkSpace.scala
2024.01.23 15:01:30 INFO  time: compiled root in 0.44s
2024.01.23 15:01:36 INFO  compiling root (1 scala source)
2024.01.23 15:01:36 INFO  time: compiled root in 0.44s
2024.01.23 15:01:41 INFO  compiling root-test (1 scala source)
2024.01.23 15:01:41 INFO  time: compiled root-test in 0.28s
2024.01.23 15:01:47 INFO  compiling root (1 scala source)
2024.01.23 15:01:47 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\MacroWorkSpace.scala
2024.01.23 15:01:47 INFO  time: compiled root in 0.45s
2024.01.23 15:01:50 INFO  compiling root (1 scala source)
2024.01.23 15:01:50 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 25m 47.456s)
2024.01.23 15:01:50 INFO  compiling root (1 scala source)
2024.01.23 15:01:50 INFO  time: compiled root in 0.43s
2024.01.23 15:01:54 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:01:54 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:01:55 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 15:01:55 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54084 .
2024.01.23 15:01:55 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:01:55 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 15:01:55 INFO  Closing debug server tcp://0.0.0.0:54081
Exception in thread "pool-10-thread-5" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:02:41 INFO  compiling root-test (1 scala source)
2024.01.23 15:02:41 INFO  time: compiled root-test in 0.1s
2024.01.23 15:02:44 INFO  compiling root-test (1 scala source)
2024.01.23 15:02:44 INFO  time: compiled root-test in 81ms
2024.01.23 15:02:47 INFO  compiling root-test (1 scala source)
2024.01.23 15:02:47 INFO  time: compiled root-test in 68ms
2024.01.23 15:02:51 INFO  compiling root-test (1 scala source)
2024.01.23 15:02:51 INFO  time: compiled root-test in 66ms
2024.01.23 15:02:51 INFO  compiling root-test (1 scala source)
2024.01.23 15:02:51 INFO  time: compiled root-test in 49ms
2024.01.23 15:02:56 INFO  compiling root-test (1 scala source)
2024.01.23 15:02:56 INFO  time: compiled root-test in 66ms
2024.01.23 15:02:58 INFO  compiling root-test (1 scala source)
2024.01.23 15:02:58 INFO  time: compiled root-test in 0.44s
2024.01.23 15:03:09 INFO  compiling root (1 scala source)
2024.01.23 15:03:09 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\MacroWorkSpace.scala
2024.01.23 15:03:09 WARN  1 deprecation (since 2.13.0); re-run with -deprecation for details
2024.01.23 15:03:09 INFO  time: compiled root in 0.44s
2024.01.23 15:03:15 INFO  compiling root (1 scala source)
2024.01.23 15:03:15 INFO  time: compiled root in 0.43s
2024.01.23 15:03:21 INFO  compiling root (1 scala source)
2024.01.23 15:03:21 INFO  time: compiled root in 0.43s
2024.01.23 15:03:39 INFO  compiling root (1 scala source)
2024.01.23 15:03:39 INFO  time: compiled root in 0.41s
2024.01.23 15:03:44 INFO  compiling root (1 scala source)
2024.01.23 15:03:44 INFO  time: compiled root in 0.42s
2024.01.23 15:03:46 INFO  compiling root (1 scala source)
2024.01.23 15:03:46 INFO  time: compiled root in 0.43s
2024.01.23 15:03:48 INFO  compiling root (1 scala source)
2024.01.23 15:03:48 INFO  time: compiled root in 0.41s
2024.01.23 15:03:49 INFO  compiling root (1 scala source)
2024.01.23 15:03:49 INFO  time: compiled root in 0.41s
2024.01.23 15:03:53 INFO  compiling root (1 scala source)
2024.01.23 15:03:53 INFO  time: compiled root in 0.43s
2024.01.23 15:04:03 INFO  compiling root (1 scala source)
2024.01.23 15:04:03 INFO  time: compiled root in 0.42s
2024.01.23 15:04:03 INFO  compiling root (1 scala source)
2024.01.23 15:04:03 INFO  time: compiled root in 97ms
2024.01.23 15:04:05 INFO  compiling root (1 scala source)
2024.01.23 15:04:05 INFO  time: compiled root in 0.62s
2024.01.23 15:04:09 INFO  compiling root-test (1 scala source)
2024.01.23 15:04:09 INFO  time: compiled root-test in 86ms
2024.01.23 15:04:14 INFO  compiling root-test (1 scala source)
2024.01.23 15:04:14 INFO  time: compiled root-test in 64ms
2024.01.23 15:04:14 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:21 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:24 INFO  compiling root-test (1 scala source)
2024.01.23 15:04:24 INFO  time: compiled root-test in 77ms
2024.01.23 15:04:24 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:26 INFO  compiling root-test (1 scala source)
2024.01.23 15:04:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:26 INFO  time: compiled root-test in 73ms
2024.01.23 15:04:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:31 INFO  compiling root-test (1 scala source)
2024.01.23 15:04:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:04:31 INFO  time: compiled root-test in 72ms
2024.01.23 15:04:32 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:05:11 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:05:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:05:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:05:17 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:05:17 INFO  time: compiled root-test in 65ms
2024.01.23 15:05:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
ene 23, 2024 3:05:20 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3362
2024.01.23 15:05:20 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:05:20 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:20 INFO  time: compiled root-test in 0.42s
2024.01.23 15:05:28 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:28 INFO  time: compiled root-test in 64ms
2024.01.23 15:05:32 ERROR Failed to tokenize input for semantic tokens for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
scala.meta.tokenizers.TokenizeException: <input>:37: error: unclosed quoted identifier
      java.nio.file.Paths.get(file`Path),
                                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getBackquotedIdent(LegacyScanner.scala:489)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:337)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1583)

2024.01.23 15:05:33 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:33 INFO  time: compiled root-test in 66ms
Exception in thread "pool-10-thread-6" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:05:35 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:35 INFO  time: compiled root-test in 68ms
2024.01.23 15:05:35 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:35 INFO  time: compiled root-test in 58ms
2024.01.23 15:05:35 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 29m 32.264s)
2024.01.23 15:05:35 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 29m 32.269s)
2024.01.23 15:05:35 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:35 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:35 INFO  time: compiled root-test in 59ms
2024.01.23 15:05:35 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:35 INFO  time: compiled root-test in 58ms
ene 23, 2024 3:05:36 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.01.23 15:05:35 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:36 INFO  time: compiled root-test in 0.4s
2024.01.23 15:05:40 INFO  compiling root-test (1 scala source)
2024.01.23 15:05:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:05:40 INFO  time: compiled root-test in 0.44s
2024.01.23 15:06:11 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:06:11 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:06:11 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 15:06:11 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54112 .
2024.01.23 15:06:11 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:06:12 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 15:06:11 INFO  Closing debug server tcp://0.0.0.0:54109
2024.01.23 15:06:24 INFO  compiling root-test (1 scala source)
2024.01.23 15:06:24 INFO  time: compiled root-test in 34ms
2024.01.23 15:06:25 INFO  compiling root-test (1 scala source)
2024.01.23 15:06:25 INFO  time: compiled root-test in 39ms
2024.01.23 15:06:27 INFO  compiling root-test (1 scala source)
2024.01.23 15:06:27 INFO  time: compiled root-test in 0.42s
2024.01.23 15:06:30 INFO  compiling root-test (1 scala source)
2024.01.23 15:06:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:06:30 INFO  time: compiled root-test in 0.43s
2024.01.23 15:06:32 INFO  compiling root-test (1 scala source)
2024.01.23 15:06:32 INFO  time: compiled root-test in 0.41s
2024.01.23 15:06:41 INFO  compiling root-test (1 scala source)
2024.01.23 15:06:41 INFO  time: compiled root-test in 0.42s
2024.01.23 15:07:03 INFO  compiling root-test (1 scala source)
2024.01.23 15:07:03 INFO  time: compiled root-test in 0.4s
2024.01.23 15:07:08 INFO  compiling root-test (1 scala source)
2024.01.23 15:07:08 INFO  time: compiled root-test in 0.41s
2024.01.23 15:07:12 INFO  compiling root-test (1 scala source)
2024.01.23 15:07:12 INFO  time: compiled root-test in 67ms
2024.01.23 15:07:17 INFO  compiling root-test (1 scala source)
2024.01.23 15:07:17 INFO  time: compiled root-test in 73ms
2024.01.23 15:07:25 INFO  compiling root-test (1 scala source)
2024.01.23 15:07:25 INFO  time: compiled root-test in 68ms
2024.01.23 15:07:28 INFO  compiling root-test (1 scala source)
2024.01.23 15:07:28 INFO  time: compiled root-test in 70ms
2024.01.23 15:10:15 INFO  compiling root (1 scala source)
2024.01.23 15:10:15 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 3:10:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * This method does not do any precondition checks on its arguments.\n     * \u003cp\u003e\n     * Important: parameter order of this method is deliberately changed in order to\n     * disambiguate it against other similar methods of this class.\n     */\n    @SuppressWarnings(\"removal\")\n    private String(Charset charset, byte[] bytes, int offset, int length) {\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     *\n     * @param  noShare\n     *         {@code true} if the resulting string MUST NOT share the byte array,\n     *         {@code false} if the byte array can be exclusively used to construct\n     *         the string and is not modified or used for any other purpose.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                if (noShare || length !\u003d bytes.length) {\n                    return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n                } else {\n                    return new String(bytes, LATIN1);\n                }\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return val.clone();\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            int positives \u003d StringCoding.countPositives(val, 0, val.length);\n            byte[] dst \u003d val.clone();\n            if (positives \u003c dst.length) {\n                replaceNegatives(dst, positives);\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static void replaceNegatives(byte[] val, int fromIndex) {\n        for (int i \u003d fromIndex; i \u003c val.length; i++) {\n            if (val[i] \u003c 0) {\n                val[i] \u003d \u0027?\u0027;\n            }\n        }\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return val.clone();\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16) {\n            return encodeUTF8_UTF16(val, doReplace);\n        }\n\n        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n            return val.clone();\n        }\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(Charset.defaultCharset(), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(Charset.defaultCharset(), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger than the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            return v1.length \u003c\u003d v2.length \u0026\u0026 ArraysSupport.mismatch(v1, v2, v1.length) \u003c 0;\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte[] v1 \u003d s1.value;\n            byte[] v2 \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n                ooffset \u003c\u003c\u003d UTF16;\n                len \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(tv, toffset,\n                    ov, ooffset, len) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte[] ta \u003d value;\n        byte[] pa \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(ta, toffset,\n                    pa, 0, pc) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code ch} in the string.\n     * If stricter behavior is needed, {@link #indexOf(int, int, int)}\n     * should be considered instead.\n     * On a {@link String} {@code s}, for example,\n     * {@code s.indexOf(ch, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, length())\n                : StringUTF16.indexOf(value, ch, fromIndex, length());\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at {@code beginIndex} and\n     * stopping before {@code endIndex}.\n     *\n     * \u003cp\u003eIf a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code beginIndex} but smaller than\n     * {@code endIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code beginIndex} and before position\n     * {@code endIndex}, then {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code beginIndex} and less than {@code endIndex},\n     *          or {@code -1} if the character does not occur.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(int ch, int beginIndex, int endIndex) {\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return isLatin1() ? StringLatin1.indexOf(value, ch, beginIndex, endIndex)\n                : StringUTF16.indexOf(value, ch, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code str} in the string.\n     * If stricter behavior is needed, {@link #indexOf(String, int, int)}\n     * should be considered instead.\n     * On {@link String} {@code s} and a non-empty {@code str}, for example,\n     * {@code s.indexOf(str, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified substring\n     * within the specified index range of {@code this} string.\n     *\n     * \u003cp\u003eThis method returns the same result as the one of the invocation\n     * \u003cpre\u003e{@code\n     *     s.substring(beginIndex, endIndex).indexOf(str) + beginIndex\n     * }\u003c/pre\u003e\n     * if the index returned by {@link #indexOf(String)} is non-negative,\n     * and returns -1 otherwise.\n     * (No substring is instantiated, though.)\n     *\n     * @param   str         the substring to search for.\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the specified substring\n     *          within the specified index range,\n     *          or {@code -1} if there is no such occurrence.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(String str, int beginIndex, int endIndex) {\n        if (str.length() \u003d\u003d 1) {\n            /* Simple optimization, can be omitted without behavioral impact */\n            return indexOf(str.charAt(0), beginIndex, endIndex);\n        }\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return indexOf(value, coder(), endIndex, str, beginIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  last index (exclusive) in the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        fromIndex \u003d Math.clamp(fromIndex, 0, srcCount);\n        int tgtCount \u003d tgtStr.length();\n        if (tgtCount \u003e srcCount - fromIndex) {\n            return -1;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        return split(regex, limit, false);\n    }\n\n    /**\n     * Splits this string around matches of the given regular expression and\n     * returns both the strings and the matching delimiters.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.\n     * Each substring is immediately followed by the subsequence (the delimiter)\n     * that matches the given expression, \u003cem\u003eexcept\u003c/em\u003e for the last\n     * substring, which is not followed by anything.\n     * The substrings in the array and the delimiters are in the order in which\n     * they occur in the input.\n     * If the expression does not match any part of the input then the resulting\n     * array has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring nor the empty delimiter.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than 2 \u0026times; \u003ci\u003elimit\u003c/i\u003e - 1, and the array\u0027s last\n     *    entry will contain all input beyond the last matched delimiter.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The input {@code \"boo:::and::foo\"}, for example, yields the following\n     * results with these parameters:\n     *\n     * \u003ctable class\u003d\"plain\" style\u003d\"margin-left:2em;\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:+\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and::foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @apiNote An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code splitWithDelimiters(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#splitWithDelimiters(CharSequence,int) splitWithDelimiters}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression, alternating\n     *          substrings and matching delimiters\n     *\n     * @since   21\n     */\n    public String[] splitWithDelimiters(String regex, int limit) {\n        return split(regex, limit, true);\n    }\n\n    private String[] split(String regex, int limit, boolean withDelimiters) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n                \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n                (regex.length() \u003d\u003d 2 \u0026\u0026\n                        regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n                        (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n                (ch \u003c Character.MIN_HIGH_SURROGATE ||\n                        ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            // All the checks above can potentially be constant folded by\n            // a JIT/AOT compiler when the regex is a constant string.\n            // That requires method inlining of the checks, which is only\n            // possible when the actual split logic is in a separate method\n            // because the large split loop can usually not be inlined.\n            return split(ch, limit, withDelimiters);\n        }\n        Pattern pattern \u003d Pattern.compile(regex);\n        return withDelimiters\n                ? pattern.splitWithDelimiters(this, limit)\n                : pattern.split(this, limit);\n    }\n\n    private String[] split(char ch, int limit, boolean withDelimiters) {\n        int matchCount \u003d 0;\n        int off \u003d 0;\n        int next;\n        boolean limited \u003d limit \u003e 0;\n        ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        String del \u003d withDelimiters ? String.valueOf(ch) : null;\n        while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n            if (!limited || matchCount \u003c limit - 1) {\n                list.add(substring(off, next));\n                if (withDelimiters) {\n                    list.add(del);\n                }\n                off \u003d next + 1;\n                ++matchCount;\n            } else {    // last one\n                int last \u003d length();\n                list.add(substring(off, last));\n                off \u003d last;\n                ++matchCount;\n                break;\n            }\n        }\n        // If no match was found, return this\n        if (off \u003d\u003d 0)\n            return new String[] {this};\n\n        // Add remaining segment\n        if (!limited || matchCount \u003c limit)\n            list.add(substring(off, length()));\n\n        // Construct result\n        int resultSize \u003d list.size();\n        if (limit \u003d\u003d 0) {\n            while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                resultSize--;\n            }\n        }\n        String[] result \u003d new String[resultSize];\n        return list.subList(0, resultSize).toArray(result);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0, false);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a {@linkplain\n     * Character##unicode surrogate code point} is passed through\n     * uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        repeatCopyRest(multiple, 0, limit, len);\n        return new String(multiple, coder);\n    }\n\n    /**\n     * Used to perform copying after the initial insertion. Copying is optimized\n     * by using power of two duplication. First pass duplicates original copy,\n     * second pass then duplicates the original and the copy yielding four copies,\n     * third pass duplicates four copies yielding eight copies, and so on.\n     * Finally, the remainder is filled in with prior copies.\n     *\n     * @implNote The technique used here is significantly faster than hand-rolled\n     * loops or special casing small numbers due to the intensive optimization\n     * done by intrinsic {@code System.arraycopy}.\n     *\n     * @param buffer    destination buffer\n     * @param offset    offset in the destination buffer\n     * @param limit     total replicated including what is already in the buffer\n     * @param copied    number of bytes that have already in the buffer\n     */\n    static void repeatCopyRest(byte[] buffer, int offset, int limit, int copied) {\n        // Initial copy is in the buffer.\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            // Power of two duplicate.\n            System.arraycopy(buffer, offset, buffer, offset + copied, copied);\n        }\n        // Duplicate remainder.\n        System.arraycopy(buffer, offset, buffer, offset + copied, limit - copied);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @return  {@code offset} if the sub-range within bounds of the range\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static int checkBoundsOffCount(int offset, int count, int length) {\n        return Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 3:10:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 15:10:15 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 3:10:16 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * This method does not do any precondition checks on its arguments.\n     * \u003cp\u003e\n     * Important: parameter order of this method is deliberately changed in order to\n     * disambiguate it against other similar methods of this class.\n     */\n    @SuppressWarnings(\"removal\")\n    private String(Charset charset, byte[] bytes, int offset, int length) {\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     *\n     * @param  noShare\n     *         {@code true} if the resulting string MUST NOT share the byte array,\n     *         {@code false} if the byte array can be exclusively used to construct\n     *         the string and is not modified or used for any other purpose.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                if (noShare || length !\u003d bytes.length) {\n                    return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n                } else {\n                    return new String(bytes, LATIN1);\n                }\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return val.clone();\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            int positives \u003d StringCoding.countPositives(val, 0, val.length);\n            byte[] dst \u003d val.clone();\n            if (positives \u003c dst.length) {\n                replaceNegatives(dst, positives);\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static void replaceNegatives(byte[] val, int fromIndex) {\n        for (int i \u003d fromIndex; i \u003c val.length; i++) {\n            if (val[i] \u003c 0) {\n                val[i] \u003d \u0027?\u0027;\n            }\n        }\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return val.clone();\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16) {\n            return encodeUTF8_UTF16(val, doReplace);\n        }\n\n        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n            return val.clone();\n        }\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(Charset.defaultCharset(), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(Charset.defaultCharset(), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger than the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            return v1.length \u003c\u003d v2.length \u0026\u0026 ArraysSupport.mismatch(v1, v2, v1.length) \u003c 0;\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte[] v1 \u003d s1.value;\n            byte[] v2 \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n                ooffset \u003c\u003c\u003d UTF16;\n                len \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(tv, toffset,\n                    ov, ooffset, len) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte[] ta \u003d value;\n        byte[] pa \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(ta, toffset,\n                    pa, 0, pc) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code ch} in the string.\n     * If stricter behavior is needed, {@link #indexOf(int, int, int)}\n     * should be considered instead.\n     * On a {@link String} {@code s}, for example,\n     * {@code s.indexOf(ch, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, length())\n                : StringUTF16.indexOf(value, ch, fromIndex, length());\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at {@code beginIndex} and\n     * stopping before {@code endIndex}.\n     *\n     * \u003cp\u003eIf a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code beginIndex} but smaller than\n     * {@code endIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code beginIndex} and before position\n     * {@code endIndex}, then {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code beginIndex} and less than {@code endIndex},\n     *          or {@code -1} if the character does not occur.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(int ch, int beginIndex, int endIndex) {\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return isLatin1() ? StringLatin1.indexOf(value, ch, beginIndex, endIndex)\n                : StringUTF16.indexOf(value, ch, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code str} in the string.\n     * If stricter behavior is needed, {@link #indexOf(String, int, int)}\n     * should be considered instead.\n     * On {@link String} {@code s} and a non-empty {@code str}, for example,\n     * {@code s.indexOf(str, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified substring\n     * within the specified index range of {@code this} string.\n     *\n     * \u003cp\u003eThis method returns the same result as the one of the invocation\n     * \u003cpre\u003e{@code\n     *     s.substring(beginIndex, endIndex).indexOf(str) + beginIndex\n     * }\u003c/pre\u003e\n     * if the index returned by {@link #indexOf(String)} is non-negative,\n     * and returns -1 otherwise.\n     * (No substring is instantiated, though.)\n     *\n     * @param   str         the substring to search for.\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the specified substring\n     *          within the specified index range,\n     *          or {@code -1} if there is no such occurrence.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(String str, int beginIndex, int endIndex) {\n        if (str.length() \u003d\u003d 1) {\n            /* Simple optimization, can be omitted without behavioral impact */\n            return indexOf(str.charAt(0), beginIndex, endIndex);\n        }\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return indexOf(value, coder(), endIndex, str, beginIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  last index (exclusive) in the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        fromIndex \u003d Math.clamp(fromIndex, 0, srcCount);\n        int tgtCount \u003d tgtStr.length();\n        if (tgtCount \u003e srcCount - fromIndex) {\n            return -1;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        return split(regex, limit, false);\n    }\n\n    /**\n     * Splits this string around matches of the given regular expression and\n     * returns both the strings and the matching delimiters.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.\n     * Each substring is immediately followed by the subsequence (the delimiter)\n     * that matches the given expression, \u003cem\u003eexcept\u003c/em\u003e for the last\n     * substring, which is not followed by anything.\n     * The substrings in the array and the delimiters are in the order in which\n     * they occur in the input.\n     * If the expression does not match any part of the input then the resulting\n     * array has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring nor the empty delimiter.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than 2 \u0026times; \u003ci\u003elimit\u003c/i\u003e - 1, and the array\u0027s last\n     *    entry will contain all input beyond the last matched delimiter.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The input {@code \"boo:::and::foo\"}, for example, yields the following\n     * results with these parameters:\n     *\n     * \u003ctable class\u003d\"plain\" style\u003d\"margin-left:2em;\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:+\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and::foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @apiNote An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code splitWithDelimiters(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#splitWithDelimiters(CharSequence,int) splitWithDelimiters}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression, alternating\n     *          substrings and matching delimiters\n     *\n     * @since   21\n     */\n    public String[] splitWithDelimiters(String regex, int limit) {\n        return split(regex, limit, true);\n    }\n\n    private String[] split(String regex, int limit, boolean withDelimiters) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n                \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n                (regex.length() \u003d\u003d 2 \u0026\u0026\n                        regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n                        (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n                (ch \u003c Character.MIN_HIGH_SURROGATE ||\n                        ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            // All the checks above can potentially be constant folded by\n            // a JIT/AOT compiler when the regex is a constant string.\n            // That requires method inlining of the checks, which is only\n            // possible when the actual split logic is in a separate method\n            // because the large split loop can usually not be inlined.\n            return split(ch, limit, withDelimiters);\n        }\n        Pattern pattern \u003d Pattern.compile(regex);\n        return withDelimiters\n                ? pattern.splitWithDelimiters(this, limit)\n                : pattern.split(this, limit);\n    }\n\n    private String[] split(char ch, int limit, boolean withDelimiters) {\n        int matchCount \u003d 0;\n        int off \u003d 0;\n        int next;\n        boolean limited \u003d limit \u003e 0;\n        ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        String del \u003d withDelimiters ? String.valueOf(ch) : null;\n        while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n            if (!limited || matchCount \u003c limit - 1) {\n                list.add(substring(off, next));\n                if (withDelimiters) {\n                    list.add(del);\n                }\n                off \u003d next + 1;\n                ++matchCount;\n            } else {    // last one\n                int last \u003d length();\n                list.add(substring(off, last));\n                off \u003d last;\n                ++matchCount;\n                break;\n            }\n        }\n        // If no match was found, return this\n        if (off \u003d\u003d 0)\n            return new String[] {this};\n\n        // Add remaining segment\n        if (!limited || matchCount \u003c limit)\n            list.add(substring(off, length()));\n\n        // Construct result\n        int resultSize \u003d list.size();\n        if (limit \u003d\u003d 0) {\n            while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                resultSize--;\n            }\n        }\n        String[] result \u003d new String[resultSize];\n        return list.subList(0, resultSize).toArray(result);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0, false);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a {@linkplain\n     * Character##unicode surrogate code point} is passed through\n     * uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        repeatCopyRest(multiple, 0, limit, len);\n        return new String(multiple, coder);\n    }\n\n    /**\n     * Used to perform copying after the initial insertion. Copying is optimized\n     * by using power of two duplication. First pass duplicates original copy,\n     * second pass then duplicates the original and the copy yielding four copies,\n     * third pass duplicates four copies yielding eight copies, and so on.\n     * Finally, the remainder is filled in with prior copies.\n     *\n     * @implNote The technique used here is significantly faster than hand-rolled\n     * loops or special casing small numbers due to the intensive optimization\n     * done by intrinsic {@code System.arraycopy}.\n     *\n     * @param buffer    destination buffer\n     * @param offset    offset in the destination buffer\n     * @param limit     total replicated including what is already in the buffer\n     * @param copied    number of bytes that have already in the buffer\n     */\n    static void repeatCopyRest(byte[] buffer, int offset, int limit, int copied) {\n        // Initial copy is in the buffer.\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            // Power of two duplicate.\n            System.arraycopy(buffer, offset, buffer, offset + copied, copied);\n        }\n        // Duplicate remainder.\n        System.arraycopy(buffer, offset, buffer, offset + copied, limit - copied);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @return  {@code offset} if the sub-range within bounds of the range\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static int checkBoundsOffCount(int offset, int count, int length) {\n        return Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 3:10:16 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 15:10:15 INFO  time: compiled root in 0.54s
2024.01.23 15:10:17 INFO  compiling root-test (1 scala source)
2024.01.23 15:10:17 INFO  time: compiled root-test in 90ms
2024.01.23 15:10:37 INFO  compiling root-test (1 scala source)
2024.01.23 15:10:37 INFO  time: compiled root-test in 0.43s
2024.01.23 15:10:40 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:10:40 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:10:40 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:10:40 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54137 .
2024.01.23 15:10:40 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:10:40 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:10:40 INFO  Closing debug server tcp://0.0.0.0:54134
2024.01.23 15:11:06 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:11:06 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:11:06 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:11:06 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54147 .
2024.01.23 15:11:06 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:11:07 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:11:06 INFO  Closing debug server tcp://0.0.0.0:54144
2024.01.23 15:12:14 INFO  compiling root-test (1 scala source)
2024.01.23 15:12:14 INFO  time: compiled root-test in 76ms
2024.01.23 15:12:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:15 WARN  Using indexes to guess the definition of readText
2024.01.23 15:12:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:20 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:21 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:12:22 INFO  compiling root-test (1 scala source)
2024.01.23 15:12:22 INFO  time: compiled root-test in 0.45s
2024.01.23 15:12:22 INFO  compiling root-test (1 scala source)
2024.01.23 15:12:22 INFO  time: compiled root-test in 0.13s
2024.01.23 15:12:49 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:12:49 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:12:49 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:12:49 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54168 .
2024.01.23 15:12:49 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:12:50 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:12:49 INFO  Closing debug server tcp://0.0.0.0:54165
2024.01.23 15:12:56 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:12:56 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:12:57 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:12:57 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54179 .
2024.01.23 15:12:57 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:12:57 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:12:57 INFO  Closing debug server tcp://0.0.0.0:54176
2024.01.23 15:13:59 WARN  Using indexes to guess the definition of FileNotFoundException
2024.01.23 15:13:59 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 3:13:59 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/io/FileNotFoundException.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.io;\n\n\n/**\n * Signals that an attempt to open the file denoted by a specified pathname\n * has failed.\n *\n * \u003cp\u003e This exception will be thrown by the {@link FileInputStream}, {@link\n * FileOutputStream}, and {@link RandomAccessFile} constructors when a file\n * with the specified pathname does not exist.  It will also be thrown by these\n * constructors if the file does exist but for some reason is inaccessible, for\n * example when an attempt is made to open a read-only file for writing.\n *\n * @since   1.0\n */\n\npublic class FileNotFoundException extends IOException {\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -897856973823710492L;\n\n    /**\n     * Constructs a {@code FileNotFoundException} with\n     * {@code null} as its error detail message.\n     */\n    public FileNotFoundException() {\n        super();\n    }\n\n    /**\n     * Constructs a {@code FileNotFoundException} with the\n     * specified detail message. The string {@code s} can be\n     * retrieved later by the\n     * {@link java.lang.Throwable#getMessage}\n     * method of class {@code java.lang.Throwable}.\n     *\n     * @param   s   the detail message.\n     */\n    public FileNotFoundException(String s) {\n        super(s);\n    }\n\n    /**\n     * Constructs a {@code FileNotFoundException} with a detail message\n     * consisting of the given pathname string followed by the given reason\n     * string.  If the {@code reason} argument is {@code null} then\n     * it will be omitted.  This private constructor is invoked only by native\n     * I/O methods.\n     *\n     * @since 1.2\n     */\n    private FileNotFoundException(String path, String reason) {\n        super(path + ((reason \u003d\u003d null)\n                      ? \"\"\n                      : \" (\" + reason + \")\"));\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 3:13:59 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/io/FileNotFoundException.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 15:13:59 INFO  compiling root (1 scala source)
2024.01.23 15:13:59 INFO  time: compiled root in 32ms
2024.01.23 15:14:02 INFO  compiling root (1 scala source)
2024.01.23 15:14:02 INFO  time: compiled root in 73ms
2024.01.23 15:14:14 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 3:14:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/io/FileNotFoundException.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.io;\n\n\n/**\n * Signals that an attempt to open the file denoted by a specified pathname\n * has failed.\n *\n * \u003cp\u003e This exception will be thrown by the {@link FileInputStream}, {@link\n * FileOutputStream}, and {@link RandomAccessFile} constructors when a file\n * with the specified pathname does not exist.  It will also be thrown by these\n * constructors if the file does exist but for some reason is inaccessible, for\n * example when an attempt is made to open a read-only file for writing.\n *\n * @since   1.0\n */\n\npublic class FileNotFoundException extends IOException {\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -897856973823710492L;\n\n    /**\n     * Constructs a {@code FileNotFoundException} with\n     * {@code null} as its error detail message.\n     */\n    public FileNotFoundException() {\n        super();\n    }\n\n    /**\n     * Constructs a {@code FileNotFoundException} with the\n     * specified detail message. The string {@code s} can be\n     * retrieved later by the\n     * {@link java.lang.Throwable#getMessage}\n     * method of class {@code java.lang.Throwable}.\n     *\n     * @param   s   the detail message.\n     */\n    public FileNotFoundException(String s) {\n        super(s);\n    }\n\n    /**\n     * Constructs a {@code FileNotFoundException} with a detail message\n     * consisting of the given pathname string followed by the given reason\n     * string.  If the {@code reason} argument is {@code null} then\n     * it will be omitted.  This private constructor is invoked only by native\n     * I/O methods.\n     *\n     * @since 1.2\n     */\n    private FileNotFoundException(String path, String reason) {\n        super(path + ((reason \u003d\u003d null)\n                      ? \"\"\n                      : \" (\" + reason + \")\"));\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 3:14:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/io/FileNotFoundException.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 15:14:14 INFO  compiling root (1 scala source)
2024.01.23 15:14:14 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 3:14:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/io/FileNotFoundException.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.io;\n\n\n/**\n * Signals that an attempt to open the file denoted by a specified pathname\n * has failed.\n *\n * \u003cp\u003e This exception will be thrown by the {@link FileInputStream}, {@link\n * FileOutputStream}, and {@link RandomAccessFile} constructors when a file\n * with the specified pathname does not exist.  It will also be thrown by these\n * constructors if the file does exist but for some reason is inaccessible, for\n * example when an attempt is made to open a read-only file for writing.\n *\n * @since   1.0\n */\n\npublic class FileNotFoundException extends IOException {\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -897856973823710492L;\n\n    /**\n     * Constructs a {@code FileNotFoundException} with\n     * {@code null} as its error detail message.\n     */\n    public FileNotFoundException() {\n        super();\n    }\n\n    /**\n     * Constructs a {@code FileNotFoundException} with the\n     * specified detail message. The string {@code s} can be\n     * retrieved later by the\n     * {@link java.lang.Throwable#getMessage}\n     * method of class {@code java.lang.Throwable}.\n     *\n     * @param   s   the detail message.\n     */\n    public FileNotFoundException(String s) {\n        super(s);\n    }\n\n    /**\n     * Constructs a {@code FileNotFoundException} with a detail message\n     * consisting of the given pathname string followed by the given reason\n     * string.  If the {@code reason} argument is {@code null} then\n     * it will be omitted.  This private constructor is invoked only by native\n     * I/O methods.\n     *\n     * @since 1.2\n     */\n    private FileNotFoundException(String path, String reason) {\n        super(path + ((reason \u003d\u003d null)\n                      ? \"\"\n                      : \" (\" + reason + \")\"));\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 3:14:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/io/FileNotFoundException.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/io/FileNotFoundException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 15:14:14 INFO  time: compiled root in 0.71s
2024.01.23 15:14:19 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:14:19 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:14:19 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:14:19 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54193 .
2024.01.23 15:14:19 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:14:19 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:14:19 INFO  Closing debug server tcp://0.0.0.0:54190
2024.01.23 15:14:36 INFO  compiling root-test (1 scala source)
2024.01.23 15:14:36 INFO  time: compiled root-test in 0.44s
2024.01.23 15:14:37 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:14:37 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:14:37 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:14:37 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54201 .
2024.01.23 15:14:37 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:14:37 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:14:37 INFO  Closing debug server tcp://0.0.0.0:54198
2024.01.23 15:14:42 INFO  compiling root-test (1 scala source)
2024.01.23 15:14:42 INFO  time: compiled root-test in 0.42s
2024.01.23 15:14:45 INFO  compiling root-test (1 scala source)
2024.01.23 15:14:45 INFO  time: compiled root-test in 0.43s
2024.01.23 15:14:45 INFO  compiling root-test (1 scala source)
2024.01.23 15:14:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:14:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:14:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:14:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:14:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:14:46 INFO  time: compiled root-test in 0.17s
2024.01.23 15:15:00 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:15:00 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:15:00 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:15:00 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54209 .
2024.01.23 15:15:00 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:15:00 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:15:00 INFO  Closing debug server tcp://0.0.0.0:54206
ene 23, 2024 3:15:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4098
2024.01.23 15:15:06 INFO  compiling root-test (1 scala source)
2024.01.23 15:15:06 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 39m 3.163s)
2024.01.23 15:15:06 INFO  compiling root-test (1 scala source)
Exception in thread "pool-10-thread-7" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:15:06 INFO  time: compiled root-test in 0.27s
2024.01.23 15:15:06 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:15:06 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:15:07 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:15:07 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54217 .
2024.01.23 15:15:07 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:15:07 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:15:07 INFO  Closing debug server tcp://0.0.0.0:54214
ene 23, 2024 3:15:21 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4120
ene 23, 2024 3:15:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4122
ene 23, 2024 3:15:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4123
ene 23, 2024 3:15:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4125
ene 23, 2024 3:15:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4124
2024.01.23 15:15:23 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:15:23 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:15:24 INFO  Starting debug proxy for [test.Tests()]
2024.01.23 15:15:24 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54245 .
2024.01.23 15:15:24 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:15:24 INFO  Closing debug server tcp://0.0.0.0:54242
2024.01.23 15:15:24 INFO  Canceling debug proxy for [test.Tests()]
2024.01.23 15:15:26 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:15:26 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:15:26 INFO  Starting debug proxy for [test.Tests(word count test)]
2024.01.23 15:15:26 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54262 .
2024.01.23 15:15:26 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:15:27 INFO  Canceling debug proxy for [test.Tests(word count test)]
2024.01.23 15:15:26 INFO  Closing debug server tcp://0.0.0.0:54258
2024.01.23 15:15:32 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:15:32 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:15:32 INFO  Starting debug proxy for [test.Tests()]
2024.01.23 15:15:32 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54271 .
2024.01.23 15:15:32 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:15:32 INFO  Canceling debug proxy for [test.Tests()]
2024.01.23 15:15:32 INFO  Closing debug server tcp://0.0.0.0:54268
2024.01.23 15:15:45 INFO  compiling root-test (1 scala source)
2024.01.23 15:15:45 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:15:45 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:15:45 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:15:45 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:15:46 WARN  Using indexes to guess the definition of Int
2024.01.23 15:15:45 INFO  time: compiled root-test in 0.56s
2024.01.23 15:15:45 INFO  compiling root-test (1 scala source)
2024.01.23 15:15:46 INFO  time: compiled root-test in 0.14s
2024.01.23 15:15:49 INFO  compiling root-test (1 scala source)
2024.01.23 15:15:49 INFO  time: compiled root-test in 0.42s
2024.01.23 15:16:05 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:16:05 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:16:05 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:16:05 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54285 .
2024.01.23 15:16:05 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:16:06 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:16:05 INFO  Closing debug server tcp://0.0.0.0:54282
2024.01.23 15:16:36 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:16:36 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:16:37 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:16:37 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54295 .
2024.01.23 15:16:37 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:16:37 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:16:37 INFO  Closing debug server tcp://0.0.0.0:54292
2024.01.23 15:16:48 INFO  compiling root-test (1 scala source)
2024.01.23 15:16:48 INFO  time: compiled root-test in 0.58s
2024.01.23 15:16:49 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:16:49 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:16:49 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:16:49 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54305 .
2024.01.23 15:16:49 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:16:49 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:16:49 INFO  Closing debug server tcp://0.0.0.0:54301
2024.01.23 15:17:10 INFO  compiling root-test (1 scala source)
2024.01.23 15:17:10 INFO  time: compiled root-test in 0.42s
2024.01.23 15:17:32 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:17:32 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:17:32 INFO  compiling root-test (1 scala source)
2024.01.23 15:17:32 INFO  time: compiled root-test in 0.42s
2024.01.23 15:17:33 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:17:33 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:17:33 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:17:33 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54314 .
2024.01.23 15:17:33 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:17:34 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:17:33 INFO  Closing debug server tcp://0.0.0.0:54311
ene 23, 2024 3:18:19 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4297
2024.01.23 15:18:19 INFO  compiling root-test (1 scala source)
2024.01.23 15:18:19 INFO  time: compiled root-test in 73ms
2024.01.23 15:18:24 INFO  compiling root-test (1 scala source)
2024.01.23 15:18:24 INFO  time: compiled root-test in 67ms
2024.01.23 15:18:27 INFO  compiling root-test (1 scala source)
2024.01.23 15:18:27 INFO  time: compiled root-test in 64ms
2024.01.23 15:18:30 INFO  compiling root-test (1 scala source)
2024.01.23 15:18:30 INFO  time: compiled root-test in 67ms
2024.01.23 15:18:42 INFO  compiling root-test (1 scala source)
2024.01.23 15:18:42 INFO  time: compiled root-test in 67ms
2024.01.23 15:18:51 INFO  compiling root-test (1 scala source)
2024.01.23 15:18:51 INFO  time: compiled root-test in 78ms
2024.01.23 15:18:54 INFO  compiling root-test (1 scala source)
2024.01.23 15:18:54 INFO  time: compiled root-test in 75ms
2024.01.23 15:18:58 INFO  compiling root-test (1 scala source)
2024.01.23 15:18:58 INFO  time: compiled root-test in 80ms
Exception in thread "pool-10-thread-8" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-10-thread-9" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-10-thread-10" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:19:02 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 3:19:02 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * This method does not do any precondition checks on its arguments.\n     * \u003cp\u003e\n     * Important: parameter order of this method is deliberately changed in order to\n     * disambiguate it against other similar methods of this class.\n     */\n    @SuppressWarnings(\"removal\")\n    private String(Charset charset, byte[] bytes, int offset, int length) {\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     *\n     * @param  noShare\n     *         {@code true} if the resulting string MUST NOT share the byte array,\n     *         {@code false} if the byte array can be exclusively used to construct\n     *         the string and is not modified or used for any other purpose.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                if (noShare || length !\u003d bytes.length) {\n                    return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n                } else {\n                    return new String(bytes, LATIN1);\n                }\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return val.clone();\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            int positives \u003d StringCoding.countPositives(val, 0, val.length);\n            byte[] dst \u003d val.clone();\n            if (positives \u003c dst.length) {\n                replaceNegatives(dst, positives);\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static void replaceNegatives(byte[] val, int fromIndex) {\n        for (int i \u003d fromIndex; i \u003c val.length; i++) {\n            if (val[i] \u003c 0) {\n                val[i] \u003d \u0027?\u0027;\n            }\n        }\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return val.clone();\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16) {\n            return encodeUTF8_UTF16(val, doReplace);\n        }\n\n        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n            return val.clone();\n        }\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(Charset.defaultCharset(), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(Charset.defaultCharset(), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger than the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            return v1.length \u003c\u003d v2.length \u0026\u0026 ArraysSupport.mismatch(v1, v2, v1.length) \u003c 0;\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte[] v1 \u003d s1.value;\n            byte[] v2 \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n                ooffset \u003c\u003c\u003d UTF16;\n                len \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(tv, toffset,\n                    ov, ooffset, len) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte[] ta \u003d value;\n        byte[] pa \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(ta, toffset,\n                    pa, 0, pc) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code ch} in the string.\n     * If stricter behavior is needed, {@link #indexOf(int, int, int)}\n     * should be considered instead.\n     * On a {@link String} {@code s}, for example,\n     * {@code s.indexOf(ch, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, length())\n                : StringUTF16.indexOf(value, ch, fromIndex, length());\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at {@code beginIndex} and\n     * stopping before {@code endIndex}.\n     *\n     * \u003cp\u003eIf a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code beginIndex} but smaller than\n     * {@code endIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code beginIndex} and before position\n     * {@code endIndex}, then {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code beginIndex} and less than {@code endIndex},\n     *          or {@code -1} if the character does not occur.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(int ch, int beginIndex, int endIndex) {\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return isLatin1() ? StringLatin1.indexOf(value, ch, beginIndex, endIndex)\n                : StringUTF16.indexOf(value, ch, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code str} in the string.\n     * If stricter behavior is needed, {@link #indexOf(String, int, int)}\n     * should be considered instead.\n     * On {@link String} {@code s} and a non-empty {@code str}, for example,\n     * {@code s.indexOf(str, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified substring\n     * within the specified index range of {@code this} string.\n     *\n     * \u003cp\u003eThis method returns the same result as the one of the invocation\n     * \u003cpre\u003e{@code\n     *     s.substring(beginIndex, endIndex).indexOf(str) + beginIndex\n     * }\u003c/pre\u003e\n     * if the index returned by {@link #indexOf(String)} is non-negative,\n     * and returns -1 otherwise.\n     * (No substring is instantiated, though.)\n     *\n     * @param   str         the substring to search for.\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the specified substring\n     *          within the specified index range,\n     *          or {@code -1} if there is no such occurrence.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(String str, int beginIndex, int endIndex) {\n        if (str.length() \u003d\u003d 1) {\n            /* Simple optimization, can be omitted without behavioral impact */\n            return indexOf(str.charAt(0), beginIndex, endIndex);\n        }\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return indexOf(value, coder(), endIndex, str, beginIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  last index (exclusive) in the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        fromIndex \u003d Math.clamp(fromIndex, 0, srcCount);\n        int tgtCount \u003d tgtStr.length();\n        if (tgtCount \u003e srcCount - fromIndex) {\n            return -1;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        return split(regex, limit, false);\n    }\n\n    /**\n     * Splits this string around matches of the given regular expression and\n     * returns both the strings and the matching delimiters.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.\n     * Each substring is immediately followed by the subsequence (the delimiter)\n     * that matches the given expression, \u003cem\u003eexcept\u003c/em\u003e for the last\n     * substring, which is not followed by anything.\n     * The substrings in the array and the delimiters are in the order in which\n     * they occur in the input.\n     * If the expression does not match any part of the input then the resulting\n     * array has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring nor the empty delimiter.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than 2 \u0026times; \u003ci\u003elimit\u003c/i\u003e - 1, and the array\u0027s last\n     *    entry will contain all input beyond the last matched delimiter.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The input {@code \"boo:::and::foo\"}, for example, yields the following\n     * results with these parameters:\n     *\n     * \u003ctable class\u003d\"plain\" style\u003d\"margin-left:2em;\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:+\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and::foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @apiNote An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code splitWithDelimiters(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#splitWithDelimiters(CharSequence,int) splitWithDelimiters}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression, alternating\n     *          substrings and matching delimiters\n     *\n     * @since   21\n     */\n    public String[] splitWithDelimiters(String regex, int limit) {\n        return split(regex, limit, true);\n    }\n\n    private String[] split(String regex, int limit, boolean withDelimiters) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n                \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n                (regex.length() \u003d\u003d 2 \u0026\u0026\n                        regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n                        (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n                (ch \u003c Character.MIN_HIGH_SURROGATE ||\n                        ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            // All the checks above can potentially be constant folded by\n            // a JIT/AOT compiler when the regex is a constant string.\n            // That requires method inlining of the checks, which is only\n            // possible when the actual split logic is in a separate method\n            // because the large split loop can usually not be inlined.\n            return split(ch, limit, withDelimiters);\n        }\n        Pattern pattern \u003d Pattern.compile(regex);\n        return withDelimiters\n                ? pattern.splitWithDelimiters(this, limit)\n                : pattern.split(this, limit);\n    }\n\n    private String[] split(char ch, int limit, boolean withDelimiters) {\n        int matchCount \u003d 0;\n        int off \u003d 0;\n        int next;\n        boolean limited \u003d limit \u003e 0;\n        ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        String del \u003d withDelimiters ? String.valueOf(ch) : null;\n        while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n            if (!limited || matchCount \u003c limit - 1) {\n                list.add(substring(off, next));\n                if (withDelimiters) {\n                    list.add(del);\n                }\n                off \u003d next + 1;\n                ++matchCount;\n            } else {    // last one\n                int last \u003d length();\n                list.add(substring(off, last));\n                off \u003d last;\n                ++matchCount;\n                break;\n            }\n        }\n        // If no match was found, return this\n        if (off \u003d\u003d 0)\n            return new String[] {this};\n\n        // Add remaining segment\n        if (!limited || matchCount \u003c limit)\n            list.add(substring(off, length()));\n\n        // Construct result\n        int resultSize \u003d list.size();\n        if (limit \u003d\u003d 0) {\n            while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                resultSize--;\n            }\n        }\n        String[] result \u003d new String[resultSize];\n        return list.subList(0, resultSize).toArray(result);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0, false);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a {@linkplain\n     * Character##unicode surrogate code point} is passed through\n     * uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        repeatCopyRest(multiple, 0, limit, len);\n        return new String(multiple, coder);\n    }\n\n    /**\n     * Used to perform copying after the initial insertion. Copying is optimized\n     * by using power of two duplication. First pass duplicates original copy,\n     * second pass then duplicates the original and the copy yielding four copies,\n     * third pass duplicates four copies yielding eight copies, and so on.\n     * Finally, the remainder is filled in with prior copies.\n     *\n     * @implNote The technique used here is significantly faster than hand-rolled\n     * loops or special casing small numbers due to the intensive optimization\n     * done by intrinsic {@code System.arraycopy}.\n     *\n     * @param buffer    destination buffer\n     * @param offset    offset in the destination buffer\n     * @param limit     total replicated including what is already in the buffer\n     * @param copied    number of bytes that have already in the buffer\n     */\n    static void repeatCopyRest(byte[] buffer, int offset, int limit, int copied) {\n        // Initial copy is in the buffer.\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            // Power of two duplicate.\n            System.arraycopy(buffer, offset, buffer, offset + copied, copied);\n        }\n        // Duplicate remainder.\n        System.arraycopy(buffer, offset, buffer, offset + copied, limit - copied);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @return  {@code offset} if the sub-range within bounds of the range\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static int checkBoundsOffCount(int offset, int count, int length) {\n        return Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 3:19:02 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 15:19:04 WARN  Using indexes to guess the definition of MacroWorkSpace
2024.01.23 15:19:04 INFO  compiling root-test (1 scala source)
2024.01.23 15:19:04 INFO  time: compiled root-test in 0.46s
2024.01.23 15:19:15 INFO  compiling root-test (1 scala source)
2024.01.23 15:19:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:19:15 INFO  time: compiled root-test in 0.47s
2024.01.23 15:19:31 ERROR Failed to tokenize input for semantic tokens for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
scala.meta.tokenizers.TokenizeException: <input>:43: error: Non-zero integral values may not have a leading zero.
    assertEquals(wordCount.getOrElse("example", 1),01)
                                                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:856)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1583)

2024.01.23 15:19:35 INFO  compiling root-test (1 scala source)
2024.01.23 15:19:35 INFO  time: compiled root-test in 0.46s
2024.01.23 15:19:36 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:19:36 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:19:36 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:19:36 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54328 .
2024.01.23 15:19:36 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:19:36 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:19:36 INFO  Closing debug server tcp://0.0.0.0:54325
2024.01.23 15:19:41 ERROR Failed to tokenize input for semantic tokens for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
scala.meta.tokenizers.TokenizeException: <input>:43: error: Non-zero integral values may not have a leading zero.
    assertEquals(wordCount.getOrElse("example", 1),01)
                                                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:856)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1583)

2024.01.23 15:19:44 INFO  compiling root-test (1 scala source)
2024.01.23 15:19:44 INFO  time: compiled root-test in 0.59s
2024.01.23 15:20:00 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:00 INFO  time: compiled root-test in 0.47s
2024.01.23 15:20:03 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:03 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:03 INFO  time: compiled root-test in 0.45s
2024.01.23 15:20:05 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:05 INFO  time: compiled root-test in 0.45s
2024.01.23 15:20:08 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:08 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:08 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:08 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:08 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:08 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:08 INFO  time: compiled root-test in 0.46s
2024.01.23 15:20:11 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:11 INFO  time: compiled root-test in 0.47s
2024.01.23 15:20:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:13 INFO  compiling root-test (1 scala source)
ene 23, 2024 3:20:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4637
2024.01.23 15:20:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:13 INFO  time: compiled root-test in 0.59s
2024.01.23 15:20:16 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:16 INFO  time: compiled root-test in 0.47s
2024.01.23 15:20:22 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:22 INFO  time: compiled root-test in 0.46s
Exception in thread "pool-10-thread-11" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-10-thread-12" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:20:25 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:25 INFO  time: compiled root-test in 0.48s
2024.01.23 15:20:32 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:32 INFO  time: compiled root-test in 0.46s
2024.01.23 15:20:35 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:20:35 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:20:35 INFO  Starting debug proxy for [test.Tests(read temporal)]
2024.01.23 15:20:35 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54339 .
2024.01.23 15:20:35 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:20:36 INFO  Canceling debug proxy for [test.Tests(read temporal)]
2024.01.23 15:20:35 INFO  Closing debug server tcp://0.0.0.0:54336
2024.01.23 15:20:49 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:49 INFO  time: compiled root-test in 0.41s
2024.01.23 15:20:51 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:51 INFO  time: compiled root-test in 0.47s
2024.01.23 15:20:53 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:53 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:20:53 INFO  time: compiled root-test in 0.59s
2024.01.23 15:20:55 INFO  compiling root-test (1 scala source)
2024.01.23 15:20:55 INFO  time: compiled root-test in 0.42s
2024.01.23 15:21:05 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:21:05 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:21:05 INFO  Starting debug proxy for [test.Tests(read text test)]
2024.01.23 15:21:05 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54347 .
2024.01.23 15:21:05 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:21:06 INFO  Canceling debug proxy for [test.Tests(read text test)]
2024.01.23 15:21:05 INFO  Closing debug server tcp://0.0.0.0:54344
2024.01.23 15:21:31 INFO  compiling root-test (1 scala source)
2024.01.23 15:21:31 INFO  time: compiled root-test in 0.48s
Exception in thread "pool-10-thread-13" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:21:35 INFO  compiling root-test (1 scala source)
2024.01.23 15:21:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:21:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:21:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:21:35 INFO  time: compiled root-test in 0.49s
2024.01.23 15:21:36 INFO  compiling root-test (1 scala source)
2024.01.23 15:21:36 INFO  time: compiled root-test in 0.14s
2024.01.23 15:21:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:21:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:21:40 INFO  compiling root-test (1 scala source)
2024.01.23 15:21:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:21:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:21:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:21:40 INFO  time: compiled root-test in 0.46s
2024.01.23 15:21:41 INFO  compiling root-test (1 scala source)
2024.01.23 15:21:41 INFO  time: compiled root-test in 0.17s
2024.01.23 15:21:43 INFO  compiling root-test (1 scala source)
2024.01.23 15:21:43 INFO  time: compiled root-test in 0.5s
2024.01.23 15:21:44 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:21:44 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:21:44 INFO  Starting debug proxy for [test.Tests()]
2024.01.23 15:21:44 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54355 .
2024.01.23 15:21:44 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:21:45 INFO  Canceling debug proxy for [test.Tests()]
2024.01.23 15:21:44 INFO  Closing debug server tcp://0.0.0.0:54352
Exception in thread "pool-7-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:27:09 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala copy\MacroWorkSpace.scala
2024.01.23 15:27:14 INFO  compiling root (1 scala source)
2024.01.23 15:27:14 INFO  time: compiled root in 0.64s
2024.01.23 15:27:17 INFO  compiling root (2 scala sources)
2024.01.23 15:27:17 INFO  time: compiled root in 37ms
2024.01.23 15:27:17 INFO  compiling root (2 scala sources)
2024.01.23 15:27:17 INFO  time: compiled root in 23ms
2024.01.23 15:27:17 INFO  compiling root (2 scala sources)
2024.01.23 15:27:17 INFO  time: compiled root in 18ms
2024.01.23 15:27:39 INFO  compiling root (2 scala sources)
2024.01.23 15:27:39 INFO  time: compiled root in 0.91s
2024.01.23 15:27:43 INFO  compiling root (1 scala source)
2024.01.23 15:27:43 INFO  time: compiled root in 0.65s
2024.01.23 15:27:58 INFO  compiling root (2 scala sources)
2024.01.23 15:27:58 INFO  time: compiled root in 0.77s
2024.01.23 15:28:02 INFO  compiling root (1 scala source)
2024.01.23 15:28:02 INFO  time: compiled root in 0.51s
2024.01.23 15:28:04 INFO  compiling root (1 scala source)
2024.01.23 15:28:04 WARN  failed to generate semanticdb for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Functions.scala:
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Functions.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.inputs.Input$File.chars$lzycompute(Input.scala:52)
	at scala.meta.inputs.Input$File.chars(Input.scala:52)
	at scala.meta.internal.tokenizers.CharArrayReader.<init>(CharArrayReader.scala:25)
	at scala.meta.internal.tokenizers.LegacyScanner.<init>(LegacyScanner.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:22)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.parsers.ScannerTokens$.apply(ScannerTokens.scala:914)
	at scala.meta.internal.parsers.ScalametaParser.<init>(ScalametaParser.scala:33)
	at scala.meta.parsers.Parse$$anon$1.apply(Parse.scala:35)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:206)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:54)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.saveSemanticdbForCompilationUnit(SemanticdbPipeline.scala:59)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.apply(SemanticdbPipeline.scala:65)
	at scala.tools.nsc.Global$GlobalPhase.applyPhase(Global.scala:480)
	at scala.tools.nsc.Global$GlobalPhase.run(Global.scala:427)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.run(SemanticdbPipeline.scala:75)
	at scala.tools.nsc.Global$Run.compileUnitsInternal(Global.scala:1546)
	at scala.tools.nsc.Global$Run.compileUnits(Global.scala:1530)
	at scala.tools.nsc.Global$Run.compileSources(Global.scala:1522)
	at scala.tools.nsc.Global$Run.compileFiles(Global.scala:1635)
	at scala.tools.xsbt.CachedCompiler0.run(CompilerBridge.scala:176)
	at scala.tools.xsbt.CachedCompiler0.run(CompilerBridge.scala:139)
	at scala.tools.xsbt.CompilerBridge.run(CompilerBridge.scala:43)
	at sbt.internal.inc.AnalyzingCompiler.compile(AnalyzingCompiler.scala:91)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.compileSources$1(BloopHighLevelCompiler.scala:133)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$7(BloopHighLevelCompiler.scala:159)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$1(BloopHighLevelCompiler.scala:71)
	at bloop.tracing.NoopTracer$.trace(BraveTracer.scala:53)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.timed$1(BloopHighLevelCompiler.scala:70)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$6(BloopHighLevelCompiler.scala:159)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at monix.eval.internal.TaskRunLoop$.startFull(TaskRunLoop.scala:81)
	at monix.eval.internal.TaskRestartCallback.syncOnSuccess(TaskRestartCallback.scala:101)
	at monix.eval.internal.TaskRestartCallback.onSuccess(TaskRestartCallback.scala:74)
	at monix.eval.internal.TaskExecuteOn$AsyncRegister$$anon$1.run(TaskExecuteOn.scala:71)
	at java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1423)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:387)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1312)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1843)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1808)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:188)

2024.01.23 15:28:04 INFO  time: compiled root in 0.12s
2024.01.23 15:28:04 INFO  compiling root (2 scala sources)
2024.01.23 15:28:04 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 3:28:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * This method does not do any precondition checks on its arguments.\n     * \u003cp\u003e\n     * Important: parameter order of this method is deliberately changed in order to\n     * disambiguate it against other similar methods of this class.\n     */\n    @SuppressWarnings(\"removal\")\n    private String(Charset charset, byte[] bytes, int offset, int length) {\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     *\n     * @param  noShare\n     *         {@code true} if the resulting string MUST NOT share the byte array,\n     *         {@code false} if the byte array can be exclusively used to construct\n     *         the string and is not modified or used for any other purpose.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                if (noShare || length !\u003d bytes.length) {\n                    return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n                } else {\n                    return new String(bytes, LATIN1);\n                }\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return val.clone();\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            int positives \u003d StringCoding.countPositives(val, 0, val.length);\n            byte[] dst \u003d val.clone();\n            if (positives \u003c dst.length) {\n                replaceNegatives(dst, positives);\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static void replaceNegatives(byte[] val, int fromIndex) {\n        for (int i \u003d fromIndex; i \u003c val.length; i++) {\n            if (val[i] \u003c 0) {\n                val[i] \u003d \u0027?\u0027;\n            }\n        }\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return val.clone();\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16) {\n            return encodeUTF8_UTF16(val, doReplace);\n        }\n\n        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n            return val.clone();\n        }\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(Charset.defaultCharset(), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(Charset.defaultCharset(), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger than the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            return v1.length \u003c\u003d v2.length \u0026\u0026 ArraysSupport.mismatch(v1, v2, v1.length) \u003c 0;\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte[] v1 \u003d s1.value;\n            byte[] v2 \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n                ooffset \u003c\u003c\u003d UTF16;\n                len \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(tv, toffset,\n                    ov, ooffset, len) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte[] ta \u003d value;\n        byte[] pa \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(ta, toffset,\n                    pa, 0, pc) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code ch} in the string.\n     * If stricter behavior is needed, {@link #indexOf(int, int, int)}\n     * should be considered instead.\n     * On a {@link String} {@code s}, for example,\n     * {@code s.indexOf(ch, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, length())\n                : StringUTF16.indexOf(value, ch, fromIndex, length());\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at {@code beginIndex} and\n     * stopping before {@code endIndex}.\n     *\n     * \u003cp\u003eIf a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code beginIndex} but smaller than\n     * {@code endIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code beginIndex} and before position\n     * {@code endIndex}, then {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code beginIndex} and less than {@code endIndex},\n     *          or {@code -1} if the character does not occur.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(int ch, int beginIndex, int endIndex) {\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return isLatin1() ? StringLatin1.indexOf(value, ch, beginIndex, endIndex)\n                : StringUTF16.indexOf(value, ch, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code str} in the string.\n     * If stricter behavior is needed, {@link #indexOf(String, int, int)}\n     * should be considered instead.\n     * On {@link String} {@code s} and a non-empty {@code str}, for example,\n     * {@code s.indexOf(str, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified substring\n     * within the specified index range of {@code this} string.\n     *\n     * \u003cp\u003eThis method returns the same result as the one of the invocation\n     * \u003cpre\u003e{@code\n     *     s.substring(beginIndex, endIndex).indexOf(str) + beginIndex\n     * }\u003c/pre\u003e\n     * if the index returned by {@link #indexOf(String)} is non-negative,\n     * and returns -1 otherwise.\n     * (No substring is instantiated, though.)\n     *\n     * @param   str         the substring to search for.\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the specified substring\n     *          within the specified index range,\n     *          or {@code -1} if there is no such occurrence.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(String str, int beginIndex, int endIndex) {\n        if (str.length() \u003d\u003d 1) {\n            /* Simple optimization, can be omitted without behavioral impact */\n            return indexOf(str.charAt(0), beginIndex, endIndex);\n        }\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return indexOf(value, coder(), endIndex, str, beginIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  last index (exclusive) in the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        fromIndex \u003d Math.clamp(fromIndex, 0, srcCount);\n        int tgtCount \u003d tgtStr.length();\n        if (tgtCount \u003e srcCount - fromIndex) {\n            return -1;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        return split(regex, limit, false);\n    }\n\n    /**\n     * Splits this string around matches of the given regular expression and\n     * returns both the strings and the matching delimiters.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.\n     * Each substring is immediately followed by the subsequence (the delimiter)\n     * that matches the given expression, \u003cem\u003eexcept\u003c/em\u003e for the last\n     * substring, which is not followed by anything.\n     * The substrings in the array and the delimiters are in the order in which\n     * they occur in the input.\n     * If the expression does not match any part of the input then the resulting\n     * array has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring nor the empty delimiter.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than 2 \u0026times; \u003ci\u003elimit\u003c/i\u003e - 1, and the array\u0027s last\n     *    entry will contain all input beyond the last matched delimiter.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The input {@code \"boo:::and::foo\"}, for example, yields the following\n     * results with these parameters:\n     *\n     * \u003ctable class\u003d\"plain\" style\u003d\"margin-left:2em;\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:+\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and::foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @apiNote An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code splitWithDelimiters(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#splitWithDelimiters(CharSequence,int) splitWithDelimiters}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression, alternating\n     *          substrings and matching delimiters\n     *\n     * @since   21\n     */\n    public String[] splitWithDelimiters(String regex, int limit) {\n        return split(regex, limit, true);\n    }\n\n    private String[] split(String regex, int limit, boolean withDelimiters) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n                \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n                (regex.length() \u003d\u003d 2 \u0026\u0026\n                        regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n                        (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n                (ch \u003c Character.MIN_HIGH_SURROGATE ||\n                        ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            // All the checks above can potentially be constant folded by\n            // a JIT/AOT compiler when the regex is a constant string.\n            // That requires method inlining of the checks, which is only\n            // possible when the actual split logic is in a separate method\n            // because the large split loop can usually not be inlined.\n            return split(ch, limit, withDelimiters);\n        }\n        Pattern pattern \u003d Pattern.compile(regex);\n        return withDelimiters\n                ? pattern.splitWithDelimiters(this, limit)\n                : pattern.split(this, limit);\n    }\n\n    private String[] split(char ch, int limit, boolean withDelimiters) {\n        int matchCount \u003d 0;\n        int off \u003d 0;\n        int next;\n        boolean limited \u003d limit \u003e 0;\n        ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        String del \u003d withDelimiters ? String.valueOf(ch) : null;\n        while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n            if (!limited || matchCount \u003c limit - 1) {\n                list.add(substring(off, next));\n                if (withDelimiters) {\n                    list.add(del);\n                }\n                off \u003d next + 1;\n                ++matchCount;\n            } else {    // last one\n                int last \u003d length();\n                list.add(substring(off, last));\n                off \u003d last;\n                ++matchCount;\n                break;\n            }\n        }\n        // If no match was found, return this\n        if (off \u003d\u003d 0)\n            return new String[] {this};\n\n        // Add remaining segment\n        if (!limited || matchCount \u003c limit)\n            list.add(substring(off, length()));\n\n        // Construct result\n        int resultSize \u003d list.size();\n        if (limit \u003d\u003d 0) {\n            while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                resultSize--;\n            }\n        }\n        String[] result \u003d new String[resultSize];\n        return list.subList(0, resultSize).toArray(result);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0, false);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a {@linkplain\n     * Character##unicode surrogate code point} is passed through\n     * uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        repeatCopyRest(multiple, 0, limit, len);\n        return new String(multiple, coder);\n    }\n\n    /**\n     * Used to perform copying after the initial insertion. Copying is optimized\n     * by using power of two duplication. First pass duplicates original copy,\n     * second pass then duplicates the original and the copy yielding four copies,\n     * third pass duplicates four copies yielding eight copies, and so on.\n     * Finally, the remainder is filled in with prior copies.\n     *\n     * @implNote The technique used here is significantly faster than hand-rolled\n     * loops or special casing small numbers due to the intensive optimization\n     * done by intrinsic {@code System.arraycopy}.\n     *\n     * @param buffer    destination buffer\n     * @param offset    offset in the destination buffer\n     * @param limit     total replicated including what is already in the buffer\n     * @param copied    number of bytes that have already in the buffer\n     */\n    static void repeatCopyRest(byte[] buffer, int offset, int limit, int copied) {\n        // Initial copy is in the buffer.\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            // Power of two duplicate.\n            System.arraycopy(buffer, offset, buffer, offset + copied, copied);\n        }\n        // Duplicate remainder.\n        System.arraycopy(buffer, offset, buffer, offset + copied, limit - copied);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @return  {@code offset} if the sub-range within bounds of the range\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static int checkBoundsOffCount(int offset, int count, int length) {\n        return Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 3:28:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 15:28:04 INFO  time: compiled root in 0.66s
2024.01.23 15:28:14 INFO  compiling root (1 scala source)
2024.01.23 15:28:14 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:14 INFO  time: compiled root in 0.79s
2024.01.23 15:28:19 INFO  compiling root (1 scala source)
2024.01.23 15:28:19 INFO  time: compiled root in 0.57s
2024.01.23 15:28:25 INFO  compiling root (1 scala source)
2024.01.23 15:28:25 INFO  time: compiled root in 75ms
2024.01.23 15:28:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:33 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:34 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:48 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:50 INFO  compiling root (1 scala source)
2024.01.23 15:28:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:28:50 INFO  time: compiled root in 79ms
2024.01.23 15:28:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:03 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:04 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:11 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:16 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:20 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:23 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:24 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:24 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:25 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:36 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:36 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:36 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:36 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:43 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:45 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:49 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:53 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:54 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:54 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:54 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:54 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:29:54 INFO  compiling root (1 scala source)
2024.01.23 15:29:54 INFO  time: compiled root in 0.27s
2024.01.23 15:30:00 INFO  compiling root (1 scala source)
2024.01.23 15:30:00 INFO  time: compiled root in 0.31s
2024.01.23 15:30:05 INFO  compiling root (1 scala source)
2024.01.23 15:30:05 INFO  time: compiled root in 0.27s
2024.01.23 15:30:16 INFO  compiling root (1 scala source)
2024.01.23 15:30:16 INFO  time: compiled root in 0.28s
2024.01.23 15:30:49 INFO  compiling root (1 scala source)
2024.01.23 15:30:49 INFO  time: compiled root in 0.27s
2024.01.23 15:31:03 INFO  compiling root (1 scala source)
2024.01.23 15:31:03 INFO  time: compiled root in 0.28s
2024.01.23 15:31:18 INFO  compiling root (1 scala source)
2024.01.23 15:31:18 INFO  time: compiled root in 0.34s
2024.01.23 15:31:24 INFO  compiling root (1 scala source)
2024.01.23 15:31:24 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:31:24 INFO  time: compiled root in 0.33s
2024.01.23 15:31:27 INFO  compiling root (1 scala source)
2024.01.23 15:31:27 INFO  time: compiled root in 0.34s
2024.01.23 15:31:32 INFO  compiling root (1 scala source)
2024.01.23 15:31:32 INFO  time: compiled root in 0.32s
2024.01.23 15:31:34 INFO  compiling root (1 scala source)
2024.01.23 15:31:34 INFO  time: compiled root in 0.29s
2024.01.23 15:32:40 INFO  compiling root (1 scala source)
2024.01.23 15:32:40 INFO  time: compiled root in 0.33s
2024.01.23 15:32:42 INFO  compiling root (1 scala source)
2024.01.23 15:32:42 INFO  time: compiled root in 52ms
2024.01.23 15:32:42 WARN  Using indexes to guess the definition of default
ene 23, 2024 3:32:42 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
ene 23, 2024 3:32:43 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_(scala-projects-build)_15-32-43-093.md
2024.01.23 15:32:44 INFO  compiling root (1 scala source)
2024.01.23 15:32:44 INFO  time: compiled root in 0.29s
2024.01.23 15:33:18 INFO  compiling root-test (1 scala source)
2024.01.23 15:33:18 INFO  time: compiled root-test in 44ms
2024.01.23 15:33:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:20 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:20 INFO  compiling root-test (1 scala source)
2024.01.23 15:33:20 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:20 INFO  time: compiled root-test in 0.64s
2024.01.23 15:33:24 INFO  compiling root-test (1 scala source)
2024.01.23 15:33:24 INFO  time: compiled root-test in 0.47s
2024.01.23 15:33:35 INFO  compiling root-test (1 scala source)
2024.01.23 15:33:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:35 INFO  time: compiled root-test in 82ms
2024.01.23 15:33:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:36 INFO  compiling root-test (1 scala source)
2024.01.23 15:33:36 INFO  time: compiled root-test in 64ms
2024.01.23 15:33:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 INFO  compiling root-test (1 scala source)
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 INFO  time: compiled root-test in 73ms
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:33:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:02 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:04 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:05 INFO  compiling root-test (1 scala source)
2024.01.23 15:34:05 INFO  time: compiled root-test in 71ms
2024.01.23 15:34:05 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:08 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:08 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:08 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:09 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:10 INFO  compiling root-test (1 scala source)
2024.01.23 15:34:10 INFO  time: compiled root-test in 71ms
2024.01.23 15:34:10 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:19 INFO  compiling root-test (1 scala source)
2024.01.23 15:34:19 INFO  time: compiled root-test in 0.11s
2024.01.23 15:34:18 WARN  Using indexes to guess the definition of Controller
2024.01.23 15:34:19 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:34:24 INFO  compiling root (1 scala source)
2024.01.23 15:34:24 INFO  time: compiled root in 0.3s
2024.01.23 15:34:25 INFO  compiling root-test (1 scala source)
2024.01.23 15:34:25 INFO  time: compiled root-test in 0.26s
2024.01.23 15:34:29 INFO  compiling root-test (1 scala source)
2024.01.23 15:34:29 INFO  time: compiled root-test in 0.51s
2024.01.23 15:34:30 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:34:30 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:34:30 INFO  Starting debug proxy for [test.Tests(controller Singleton by default)]
2024.01.23 15:34:29 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54466 .
2024.01.23 15:34:29 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:34:30 INFO  Canceling debug proxy for [test.Tests(controller Singleton by default)]
2024.01.23 15:34:30 INFO  Closing debug server tcp://0.0.0.0:54463
2024.01.23 15:34:43 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:34:43 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:34:43 INFO  Starting debug proxy for [test.Tests(controller Singleton by default)]
2024.01.23 15:34:43 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54474 .
2024.01.23 15:34:43 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:34:43 INFO  Canceling debug proxy for [test.Tests(controller Singleton by default)]
2024.01.23 15:34:43 INFO  Closing debug server tcp://0.0.0.0:54471
Exception in thread "pool-7-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:34:58 INFO  compiling root (1 scala source)
2024.01.23 15:34:58 INFO  time: compiled root in 0.34s
ene 23, 2024 3:35:21 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5939
2024.01.23 15:35:21 INFO  compiling root (1 scala source)
2024.01.23 15:35:21 INFO  time: compiled root in 0.34s
2024.01.23 15:35:23 INFO  compiling root (1 scala source)
2024.01.23 15:35:23 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:35:23 INFO  time: compiled root in 0.34s
2024.01.23 15:35:27 INFO  compiling root (1 scala source)
2024.01.23 15:35:27 INFO  time: compiled root in 0.32s
2024.01.23 15:35:27 INFO  compiling root-test (1 scala source)
2024.01.23 15:35:27 INFO  time: compiled root-test in 78ms
2024.01.23 15:35:39 INFO  compiling root-test (1 scala source)
2024.01.23 15:35:39 INFO  time: compiled root-test in 69ms
2024.01.23 15:35:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:41 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:42 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:42 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:42 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:42 INFO  compiling root-test (1 scala source)
2024.01.23 15:35:42 INFO  time: compiled root-test in 68ms
2024.01.23 15:35:42 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
Exception in thread "pool-10-thread-14" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:45 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:45 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:45 INFO  compiling root-test (1 scala source)
2024.01.23 15:35:45 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:35:45 INFO  time: compiled root-test in 0.63s
ene 23, 2024 3:36:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6059
2024.01.23 15:36:40 INFO  compiling root-test (1 scala source)
2024.01.23 15:36:40 INFO  time: compiled root-test in 0.48s
2024.01.23 15:36:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:36:46 INFO  compiling root-test (1 scala source)
2024.01.23 15:36:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:36:46 INFO  time: compiled root-test in 0.49s
2024.01.23 15:36:47 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:36:47 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:36:47 INFO  Starting debug proxy for [test.Tests(Controller should be a singleton)]
2024.01.23 15:36:47 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54484 .
2024.01.23 15:36:47 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:36:48 INFO  Canceling debug proxy for [test.Tests(Controller should be a singleton)]
2024.01.23 15:36:47 INFO  Closing debug server tcp://0.0.0.0:54481
2024.01.23 15:36:49 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:36:49 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:36:49 INFO  Starting debug proxy for [test.Tests(Controller should have a valid ID)]
2024.01.23 15:36:49 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54492 .
2024.01.23 15:36:49 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:36:49 INFO  Canceling debug proxy for [test.Tests(Controller should have a valid ID)]
2024.01.23 15:36:49 INFO  Closing debug server tcp://0.0.0.0:54489
2024.01.23 15:37:42 INFO  compiling root (1 scala source)
2024.01.23 15:37:42 INFO  time: compiled root in 0.35s
2024.01.23 15:37:49 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:37:49 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:37:49 INFO  compiling root (1 scala source)
2024.01.23 15:37:49 INFO  time: compiled root in 0.34s
2024.01.23 15:37:49 INFO  compiling root-test (1 scala source)
2024.01.23 15:37:49 INFO  time: compiled root-test in 0.24s
2024.01.23 15:38:21 INFO  compiling root-test (1 scala source)
2024.01.23 15:38:21 INFO  time: compiled root-test in 0.47s
2024.01.23 15:38:26 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:38:26 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:38:26 INFO  Starting debug proxy for [test.Tests(Controller should have a valid ID using the default constructor)]
2024.01.23 15:38:26 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54507 .
2024.01.23 15:38:26 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:38:26 INFO  Canceling debug proxy for [test.Tests(Controller should have a valid ID using the default constructor)]
2024.01.23 15:38:26 INFO  Closing debug server tcp://0.0.0.0:54504
2024.01.23 15:38:50 INFO  compiling root-test (1 scala source)
2024.01.23 15:38:50 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:38:50 INFO  time: compiled root-test in 0.59s
2024.01.23 15:38:55 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:38:55 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:38:55 INFO  Starting debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:38:55 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54516 .
2024.01.23 15:38:55 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:38:56 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:38:55 INFO  Closing debug server tcp://0.0.0.0:54513
2024.01.23 15:39:14 INFO  compiling root-test (1 scala source)
2024.01.23 15:39:14 INFO  time: compiled root-test in 0.48s
2024.01.23 15:39:18 INFO  compiling root (1 scala source)
2024.01.23 15:39:18 INFO  time: compiled root in 0.39s
2024.01.23 15:39:19 INFO  compiling root-test (1 scala source)
2024.01.23 15:39:19 INFO  time: compiled root-test in 87ms
2024.01.23 15:39:31 INFO  compiling root-test (1 scala source)
2024.01.23 15:39:31 INFO  time: compiled root-test in 71ms
2024.01.23 15:39:31 INFO  compiling root-test (1 scala source)
2024.01.23 15:39:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:39:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:39:31 INFO  time: compiled root-test in 60ms
2024.01.23 15:39:32 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:39:33 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:39:33 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:39:33 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:39:33 INFO  compiling root-test (1 scala source)
2024.01.23 15:39:33 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:39:33 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:39:33 INFO  time: compiled root-test in 0.49s
2024.01.23 15:39:34 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:39:34 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:39:35 INFO  Starting debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:39:35 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54524 .
2024.01.23 15:39:35 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:39:35 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:39:35 INFO  Closing debug server tcp://0.0.0.0:54521
2024.01.23 15:39:57 INFO  compiling root (1 scala source)
2024.01.23 15:39:57 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:39:57 INFO  time: compiled root in 0.36s
2024.01.23 15:40:00 INFO  compiling root (1 scala source)
2024.01.23 15:40:00 INFO  time: compiled root in 0.37s
2024.01.23 15:40:00 INFO  compiling root-test (1 scala source)
2024.01.23 15:40:00 INFO  time: compiled root-test in 70ms
2024.01.23 15:40:06 INFO  compiling root (1 scala source)
2024.01.23 15:40:06 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\Controller.scala
2024.01.23 15:40:06 INFO  time: compiled root in 0.36s
Exception in thread "pool-7-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:40:10 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:40:10 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:40:10 INFO  Starting debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:40:10 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54535 .
2024.01.23 15:40:10 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:40:10 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:40:10 INFO  Closing debug server tcp://0.0.0.0:54532
Exception in thread "pool-10-thread-15" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-10-thread-16" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-10-thread-17" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:40:38 INFO  compiling root-test (1 scala source)
2024.01.23 15:40:38 INFO  time: compiled root-test in 69ms
2024.01.23 15:40:41 INFO  compiling root-test (1 scala source)
2024.01.23 15:40:41 INFO  time: compiled root-test in 0.62s
2024.01.23 15:40:42 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:40:42 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:40:42 INFO  Starting debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:40:42 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54550 .
2024.01.23 15:40:42 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:40:42 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:40:42 INFO  Closing debug server tcp://0.0.0.0:54547
2024.01.23 15:40:57 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:40:57 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:40:57 INFO  Starting debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:40:57 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54558 .
2024.01.23 15:40:57 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:40:58 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:40:57 INFO  Closing debug server tcp://0.0.0.0:54555
2024.01.23 15:41:17 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:41:17 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:41:17 INFO  Starting debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:41:17 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54566 .
2024.01.23 15:41:17 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:41:17 INFO  Closing debug server tcp://0.0.0.0:54563
2024.01.23 15:41:18 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:41:33 INFO  compiling root-test (1 scala source)
2024.01.23 15:41:33 INFO  time: compiled root-test in 39ms
2024.01.23 15:41:33 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:35 INFO  compiling root-test (1 scala source)
2024.01.23 15:41:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:35 INFO  time: compiled root-test in 38ms
2024.01.23 15:41:35 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
ene 23, 2024 3:41:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6543
2024.01.23 15:41:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:41 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:42 INFO  compiling root-test (1 scala source)
2024.01.23 15:41:42 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:41:42 INFO  time: compiled root-test in 0.48s
2024.01.23 15:41:43 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:41:43 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:41:43 INFO  Starting debug proxy for [test.Tests(Controller is Singleton 1)]
2024.01.23 15:41:43 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54574 .
2024.01.23 15:41:43 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:41:44 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton 1)]
2024.01.23 15:41:43 INFO  Closing debug server tcp://0.0.0.0:54571
2024.01.23 15:41:45 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:41:45 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:41:45 INFO  Starting debug proxy for [test.Tests(Controller is Singleton 2)]
2024.01.23 15:41:45 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54583 .
2024.01.23 15:41:45 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:41:45 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton 2)]
2024.01.23 15:41:45 INFO  Closing debug server tcp://0.0.0.0:54579
2024.01.23 15:42:04 INFO  compiling root-test (1 scala source)
2024.01.23 15:42:04 INFO  time: compiled root-test in 72ms
ene 23, 2024 3:42:21 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6666
2024.01.23 15:42:29 INFO  compiling root-test (1 scala source)
2024.01.23 15:42:29 INFO  time: compiled root-test in 0.48s
2024.01.23 15:42:33 INFO  compiling root-test (1 scala source)
2024.01.23 15:42:33 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:42:33 INFO  time: compiled root-test in 0.47s
2024.01.23 15:42:37 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:42:37 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:42:37 INFO  Starting debug proxy for [test.Tests(Controller is Singleton 1)]
2024.01.23 15:42:37 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54593 .
2024.01.23 15:42:37 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:42:37 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton 1)]
2024.01.23 15:42:37 INFO  Closing debug server tcp://0.0.0.0:54590
2024.01.23 15:42:38 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:42:38 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:42:38 INFO  Starting debug proxy for [test.Tests(Controller is Singleton 2)]
2024.01.23 15:42:38 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54601 .
2024.01.23 15:42:38 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:42:39 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton 2)]
2024.01.23 15:42:38 INFO  Closing debug server tcp://0.0.0.0:54598
2024.01.23 15:42:41 INFO  compiling root-test (1 scala source)
2024.01.23 15:42:41 INFO  time: compiled root-test in 0.47s
2024.01.23 15:42:42 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:42:42 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:42:42 INFO  Starting debug proxy for [test.Tests(Controller is Singleton 1)]
2024.01.23 15:42:41 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54610 .
2024.01.23 15:42:41 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:42:42 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton 1)]
2024.01.23 15:42:42 INFO  Closing debug server tcp://0.0.0.0:54606
2024.01.23 15:42:44 INFO  compiling root-test (1 scala source)
2024.01.23 15:42:44 INFO  time: compiled root-test in 0.58s
2024.01.23 15:42:48 INFO  compiling root-test (1 scala source)
2024.01.23 15:42:48 INFO  time: compiled root-test in 0.49s
2024.01.23 15:43:14 INFO  compiling root-test (1 scala source)
2024.01.23 15:43:14 INFO  time: compiled root-test in 0.5s
2024.01.23 15:43:16 INFO  compiling root-test (1 scala source)
2024.01.23 15:43:16 INFO  time: compiled root-test in 0.47s
2024.01.23 15:43:17 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:43:17 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:43:17 INFO  Starting debug proxy for [test.Tests(Controller is Singleton 1)]
2024.01.23 15:43:16 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54620 .
2024.01.23 15:43:16 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:43:17 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton 1)]
2024.01.23 15:43:17 INFO  Closing debug server tcp://0.0.0.0:54617
2024.01.23 15:43:18 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:43:18 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:43:18 INFO  Starting debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:43:17 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54629 .
2024.01.23 15:43:17 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:43:18 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:43:18 INFO  Closing debug server tcp://0.0.0.0:54625
2024.01.23 15:43:33 INFO  compiling root-test (1 scala source)
2024.01.23 15:43:33 INFO  time: compiled root-test in 0.5s
2024.01.23 15:43:35 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:43:35 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:43:35 INFO  Starting debug proxy for [test.Tests(Controller is Singleton 1)]
2024.01.23 15:43:35 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54637 .
2024.01.23 15:43:35 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:43:35 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton 1)]
2024.01.23 15:43:35 INFO  Closing debug server tcp://0.0.0.0:54634
2024.01.23 15:43:37 INFO  compiling root-test (1 scala source)
2024.01.23 15:43:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:37 INFO  time: compiled root-test in 0.48s
2024.01.23 15:43:46 INFO  compiling root-test (1 scala source)
2024.01.23 15:43:46 INFO  time: compiled root-test in 0.64s
2024.01.23 15:43:47 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:43:47 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:43:47 INFO  Starting debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:43:47 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54645 .
2024.01.23 15:43:47 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:43:48 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:43:47 INFO  Closing debug server tcp://0.0.0.0:54642
2024.01.23 15:43:52 INFO  compiling root-test (1 scala source)
2024.01.23 15:43:52 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:52 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:52 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:43:52 INFO  time: compiled root-test in 0.47s
2024.01.23 15:43:54 INFO  compiling root-test (1 scala source)
2024.01.23 15:43:54 INFO  time: compiled root-test in 0.47s
2024.01.23 15:44:00 INFO  compiling root-test (1 scala source)
2024.01.23 15:44:00 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:44:00 INFO  time: compiled root-test in 0.47s
Exception in thread "pool-10-thread-18" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:44:04 INFO  compiling root-test (1 scala source)
2024.01.23 15:44:04 INFO  time: compiled root-test in 0.6s
2024.01.23 15:44:05 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:44:05 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:44:06 INFO  Starting debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:44:06 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54655 .
2024.01.23 15:44:06 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:44:06 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:44:06 INFO  Closing debug server tcp://0.0.0.0:54652
2024.01.23 15:44:22 INFO  compiling root-test (1 scala source)
2024.01.23 15:44:22 INFO  time: compiled root-test in 0.47s
2024.01.23 15:44:40 INFO  compiling root-test (1 scala source)
2024.01.23 15:44:40 INFO  time: compiled root-test in 0.46s
2024.01.23 15:44:41 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:44:41 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:44:42 INFO  Starting debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:44:42 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54666 .
2024.01.23 15:44:42 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:44:42 INFO  Canceling debug proxy for [test.Tests(Controller is Singleton)]
2024.01.23 15:44:42 INFO  Closing debug server tcp://0.0.0.0:54662
2024.01.23 15:45:07 INFO  compiling root (1 scala source)
2024.01.23 15:45:07 INFO  time: compiled root in 47ms
2024.01.23 15:45:11 INFO  compiling root (1 scala source)
2024.01.23 15:45:11 INFO  time: compiled root in 31ms
ene 23, 2024 3:45:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7055
2024.01.23 15:45:13 INFO  compiling root (1 scala source)
2024.01.23 15:45:13 INFO  time: compiled root in 33ms
2024.01.23 15:45:15 INFO  compiling root (1 scala source)
2024.01.23 15:45:15 INFO  time: compiled root in 0.38s
2024.01.23 15:45:17 INFO  compiling root (2 scala sources)
ene 23, 2024 3:45:18 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7086
2024.01.23 15:45:17 INFO  time: compiled root in 0.53s
2024.01.23 15:45:20 INFO  compiling root-test (1 scala source)
2024.01.23 15:45:20 INFO  time: compiled root-test in 94ms
2024.01.23 15:45:22 WARN  Using indexes to guess the definition of Controller
2024.01.23 15:45:22 INFO  compiling root-test (1 scala source)
2024.01.23 15:45:22 INFO  time: compiled root-test in 73ms
2024.01.23 15:45:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:22 INFO  compiling root-test (1 scala source)
2024.01.23 15:45:23 INFO  time: compiled root-test in 51ms
2024.01.23 15:45:23 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 INFO  compiling root-test (1 scala source)
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:26 INFO  time: compiled root-test in 72ms
2024.01.23 15:45:27 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:28 INFO  compiling root-test (1 scala source)
2024.01.23 15:45:28 INFO  time: compiled root-test in 70ms
2024.01.23 15:45:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:32 INFO  compiling root-test (1 scala source)
2024.01.23 15:45:32 INFO  time: compiled root-test in 69ms
2024.01.23 15:45:32 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:32 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:34 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:36 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:36 INFO  compiling root-test (1 scala source)
2024.01.23 15:45:36 INFO  time: compiled root-test in 68ms
2024.01.23 15:45:36 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Using indexes to guess the definition of Controller
2024.01.23 15:45:37 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 3:45:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/ModuleLayer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2014, 2022, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.lang.module.Configuration;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.module.ResolvedModule;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport jdk.internal.javac.PreviewFeature;\nimport jdk.internal.loader.ClassLoaderValue;\nimport jdk.internal.loader.Loader;\nimport jdk.internal.loader.LoaderPool;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.misc.CDS;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.security.util.SecurityConstants;\n\n/**\n * A layer of modules in the Java virtual machine.\n *\n * \u003cp\u003e A layer is created from a graph of modules in a {@link Configuration}\n * and a function that maps each module to a {@link ClassLoader}.\n * Creating a layer informs the Java virtual machine about the classes that\n * may be loaded from the modules so that the Java virtual machine knows which\n * module that each class is a member of. \u003c/p\u003e\n *\n * \u003cp\u003e Creating a layer creates a {@link Module} object for each {@link\n * ResolvedModule} in the configuration. For each resolved module that is\n * {@link ResolvedModule#reads() read}, the {@code Module} {@link\n * Module#canRead reads} the corresponding run-time {@code Module}, which may\n * be in the same layer or a {@link #parents() parent} layer. \u003c/p\u003e\n *\n * \u003cp\u003e The {@link #defineModulesWithOneLoader defineModulesWithOneLoader} and\n * {@link #defineModulesWithManyLoaders defineModulesWithManyLoaders} methods\n * provide convenient ways to create a module layer where all modules are\n * mapped to a single class loader or where each module is mapped to its own\n * class loader. The {@link #defineModules defineModules} method is for more\n * advanced cases where modules are mapped to custom class loaders by means of\n * a function specified to the method. Each of these methods has an instance\n * and static variant. The instance methods create a layer with the receiver\n * as the parent layer. The static methods are for more advanced cases where\n * there can be more than one parent layer or where a {@link\n * ModuleLayer.Controller Controller} is needed to control modules in the layer\n * \u003c/p\u003e\n *\n * \u003cp\u003e A Java virtual machine has at least one non-empty layer, the {@link\n * #boot() boot} layer, that is created when the Java virtual machine is\n * started. The boot layer contains module {@code java.base} and is the only\n * layer in the Java virtual machine with a module named \"{@code java.base}\".\n * The modules in the boot layer are mapped to the bootstrap class loader and\n * other class loaders that are \u003ca href\u003d\"ClassLoader.html#builtinLoaders\"\u003e\n * built-in\u003c/a\u003e into the Java virtual machine. The boot layer will often be\n * the {@link #parents() parent} when creating additional layers. \u003c/p\u003e\n *\n * \u003cp\u003e Each {@code Module} in a layer is created so that it {@link\n * Module#isExported(String) exports} and {@link Module#isOpen(String) opens}\n * the packages described by its {@link ModuleDescriptor}. Qualified exports\n * (where a package is exported to a set of target modules rather than all\n * modules) are reified when creating the layer as follows: \u003c/p\u003e\n * \u003cul\u003e\n *     \u003cli\u003e If module {@code X} exports a package to {@code Y}, and if the\n *     runtime {@code Module} {@code X} reads {@code Module} {@code Y}, then\n *     the package is exported to {@code Module} {@code Y} (which may be in\n *     the same layer as {@code X} or a parent layer). \u003c/li\u003e\n *\n *     \u003cli\u003e If module {@code X} exports a package to {@code Y}, and if the\n *     runtime {@code Module} {@code X} does not read {@code Y} then target\n *     {@code Y} is located as if by invoking {@link #findModule(String)\n *     findModule} to find the module in the layer or its parent layers. If\n *     {@code Y} is found then the package is exported to the instance of\n *     {@code Y} that was found. If {@code Y} is not found then the qualified\n *     export is ignored. \u003c/li\u003e\n * \u003c/ul\u003e\n *\n * \u003cp\u003e Qualified opens are handled in same way as qualified exports. \u003c/p\u003e\n *\n * \u003cp\u003e As when creating a {@code Configuration},\n * {@link ModuleDescriptor#isAutomatic() automatic} modules receive special\n * treatment when creating a layer. An automatic module is created in the\n * Java virtual machine as a {@code Module} that reads every unnamed {@code\n * Module} in the Java virtual machine. \u003c/p\u003e\n *\n * \u003cp\u003e Unless otherwise specified, passing a {@code null} argument to a method\n * in this class causes a {@link NullPointerException NullPointerException} to\n * be thrown. \u003c/p\u003e\n *\n * \u003ch2\u003e Example \u003c/h2\u003e\n *\n * \u003cp\u003e This example creates a configuration by resolving a module named\n * \"{@code myapp}\" with the configuration for the boot layer as the parent. It\n * then creates a new layer with the modules in this configuration. All modules\n * are defined to the same class loader. \u003c/p\u003e\n *\n * {@snippet :\n *     ModuleFinder finder \u003d ModuleFinder.of(dir1, dir2, dir3);\n *     ModuleLayer parent \u003d ModuleLayer.boot();\n *     Configuration cf \u003d parent.configuration()\n *                              .resolve(finder, ModuleFinder.of(), Set.of(\"myapp\"));\n *     ClassLoader scl \u003d ClassLoader.getSystemClassLoader();\n *     ModuleLayer layer \u003d parent.defineModulesWithOneLoader(cf, scl);\n *     Class\u003c?\u003e c \u003d layer.findLoader(\"myapp\").loadClass(\"app.Main\");\n * }\n *\n * @since 9\n * @see Module#getLayer()\n */\n\npublic final class ModuleLayer {\n\n    // the empty layer (may be initialized from the CDS archive)\n    private static @Stable ModuleLayer EMPTY_LAYER;\n    static {\n        CDS.initializeFromArchive(ModuleLayer.class);\n        if (EMPTY_LAYER \u003d\u003d null) {\n            // create a new empty layer if there is no archived version.\n            EMPTY_LAYER \u003d new ModuleLayer(Configuration.empty(), List.of(), null);\n        }\n    }\n\n    // the configuration from which this layer was created\n    private final Configuration cf;\n\n    // parent layers, empty in the case of the empty layer\n    private final List\u003cModuleLayer\u003e parents;\n\n    // maps module name to jlr.Module\n    private final Map\u003cString, Module\u003e nameToModule;\n\n    /**\n     * Creates a new module layer from the modules in the given configuration.\n     */\n    private ModuleLayer(Configuration cf,\n                        List\u003cModuleLayer\u003e parents,\n                        Function\u003cString, ClassLoader\u003e clf)\n    {\n        this.cf \u003d cf;\n        this.parents \u003d parents; // no need to do defensive copy\n\n        Map\u003cString, Module\u003e map;\n        if (parents.isEmpty()) {\n            map \u003d Map.of();\n        } else {\n            map \u003d Module.defineModules(cf, clf, this);\n        }\n        this.nameToModule \u003d map; // no need to do defensive copy\n    }\n\n    /**\n     * Controls a module layer. The static methods defined by {@link ModuleLayer}\n     * to create module layers return a {@code Controller} that can be used to\n     * control modules in the layer.\n     *\n     * \u003cp\u003e Unless otherwise specified, passing a {@code null} argument to a\n     * method in this class causes a {@link NullPointerException\n     * NullPointerException} to be thrown. \u003c/p\u003e\n     *\n     * @apiNote Care should be taken with {@code Controller} objects, they\n     * should never be shared with untrusted code.\n     *\n     * @since 9\n     */\n    public static final class Controller {\n        private final ModuleLayer layer;\n\n        Controller(ModuleLayer layer) {\n            this.layer \u003d layer;\n        }\n\n        /**\n         * Returns the layer that this object controls.\n         *\n         * @return the module layer\n         */\n        public ModuleLayer layer() {\n            return layer;\n        }\n\n        private void ensureInLayer(Module source) {\n            if (source.getLayer() !\u003d layer)\n                throw new IllegalArgumentException(source + \" not in layer\");\n        }\n\n\n        /**\n         * Updates module {@code source} in the layer to read module\n         * {@code target}. This method is a no-op if {@code source} already\n         * reads {@code target}.\n         *\n         * @implNote \u003cem\u003eRead edges\u003c/em\u003e added by this method are \u003cem\u003eweak\u003c/em\u003e\n         * and do not prevent {@code target} from being GC\u0027ed when {@code source}\n         * is strongly reachable.\n         *\n         * @param  source\n         *         The source module\n         * @param  target\n         *         The target module to read\n         *\n         * @return This controller\n         *\n         * @throws IllegalArgumentException\n         *         If {@code source} is not in the module layer\n         *\n         * @see Module#addReads\n         */\n        public Controller addReads(Module source, Module target) {\n            ensureInLayer(source);\n            source.implAddReads(target);\n            return this;\n        }\n\n        /**\n         * Updates module {@code source} in the layer to export a package to\n         * module {@code target}. This method is a no-op if {@code source}\n         * already exports the package to at least {@code target}.\n         *\n         * @param  source\n         *         The source module\n         * @param  pn\n         *         The package name\n         * @param  target\n         *         The target module\n         *\n         * @return This controller\n         *\n         * @throws IllegalArgumentException\n         *         If {@code source} is not in the module layer or the package\n         *         is not in the source module\n         *\n         * @see Module#addExports\n         */\n        public Controller addExports(Module source, String pn, Module target) {\n            ensureInLayer(source);\n            source.implAddExports(pn, target);\n            return this;\n        }\n\n        /**\n         * Updates module {@code source} in the layer to open a package to\n         * module {@code target}. This method is a no-op if {@code source}\n         * already opens the package to at least {@code target}.\n         *\n         * @param  source\n         *         The source module\n         * @param  pn\n         *         The package name\n         * @param  target\n         *         The target module\n         *\n         * @return This controller\n         *\n         * @throws IllegalArgumentException\n         *         If {@code source} is not in the module layer or the package\n         *         is not in the source module\n         *\n         * @see Module#addOpens\n         */\n        public Controller addOpens(Module source, String pn, Module target) {\n            ensureInLayer(source);\n            source.implAddOpens(pn, target);\n            return this;\n        }\n\n        /**\n         * Enables native access for a module in the layer if the caller\u0027s module\n         * has native access.\n         *\n         * \u003cp\u003e This method is \u003ca href\u003d\"foreign/package-summary.html#restricted\"\u003e\u003cem\u003erestricted\u003c/em\u003e\u003c/a\u003e.\n         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain\n         * from depending on restricted methods, and use safe and supported functionalities,\n         * where possible.\n         *\n         * @param  target\n         *         The module to update\n         *\n         * @return This controller\n         *\n         * @throws IllegalArgumentException\n         *         If {@code target} is not in the module layer\n         *\n         * @throws IllegalCallerException\n         *         If the caller is in a module that does not have native access enabled\n         *\n         * @since 20\n         */\n        @PreviewFeature(feature\u003dPreviewFeature.Feature.FOREIGN)\n        @CallerSensitive\n        public Controller enableNativeAccess(Module target) {\n            ensureInLayer(target);\n            Reflection.ensureNativeAccess(Reflection.getCallerClass(), Module.class,\n                \"enableNativeAccess\");\n            target.implAddEnableNativeAccess();\n            return this;\n        }\n    }\n\n\n    /**\n     * Creates a new module layer, with this layer as its parent, by defining the\n     * modules in the given {@code Configuration} to the Java virtual machine.\n     * This method creates one class loader and defines all modules to that\n     * class loader. The {@link ClassLoader#getParent() parent} of each class\n     * loader is the given parent class loader. This method works exactly as\n     * specified by the static {@link\n     * #defineModulesWithOneLoader(Configuration,List,ClassLoader)\n     * defineModulesWithOneLoader} method when invoked with this layer as the\n     * parent. In other words, if this layer is {@code thisLayer} then this\n     * method is equivalent to invoking:\n     * \u003cpre\u003e {@code\n     *     ModuleLayer.defineModulesWithOneLoader(cf, List.of(thisLayer), parentLoader).layer();\n     * }\u003c/pre\u003e\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  parentLoader\n     *         The parent class loader for the class loader created by this\n     *         method; may be {@code null} for the bootstrap class loader\n     *\n     * @return The newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the given configuration has more than one parent or the parent\n     *         of the configuration is not the configuration for this layer\n     * @throws LayerInstantiationException\n     *         If the layer cannot be created for any of the reasons specified\n     *         by the static {@code defineModulesWithOneLoader} method\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"createClassLoader\")} or\n     *         {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     *\n     * @see #findLoader\n     */\n    public ModuleLayer defineModulesWithOneLoader(Configuration cf,\n                                                  ClassLoader parentLoader) {\n        return defineModulesWithOneLoader(cf, List.of(this), parentLoader).layer();\n    }\n\n\n    /**\n     * Creates a new module layer, with this layer as its parent, by defining the\n     * modules in the given {@code Configuration} to the Java virtual machine.\n     * Each module is defined to its own {@link ClassLoader} created by this\n     * method. The {@link ClassLoader#getParent() parent} of each class loader\n     * is the given parent class loader. This method works exactly as specified\n     * by the static {@link\n     * #defineModulesWithManyLoaders(Configuration,List,ClassLoader)\n     * defineModulesWithManyLoaders} method when invoked with this layer as the\n     * parent. In other words, if this layer is {@code thisLayer} then this\n     * method is equivalent to invoking:\n     * \u003cpre\u003e {@code\n     *     ModuleLayer.defineModulesWithManyLoaders(cf, List.of(thisLayer), parentLoader).layer();\n     * }\u003c/pre\u003e\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  parentLoader\n     *         The parent class loader for each of the class loaders created by\n     *         this method; may be {@code null} for the bootstrap class loader\n     *\n     * @return The newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the given configuration has more than one parent or the parent\n     *         of the configuration is not the configuration for this layer\n     * @throws LayerInstantiationException\n     *         If the layer cannot be created for any of the reasons specified\n     *         by the static {@code defineModulesWithManyLoaders} method\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"createClassLoader\")} or\n     *         {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     *\n     * @see #findLoader\n     */\n    public ModuleLayer defineModulesWithManyLoaders(Configuration cf,\n                                                    ClassLoader parentLoader) {\n        return defineModulesWithManyLoaders(cf, List.of(this), parentLoader).layer();\n    }\n\n\n    /**\n     * Creates a new module layer, with this layer as its parent, by defining the\n     * modules in the given {@code Configuration} to the Java virtual machine.\n     * Each module is mapped, by name, to its class loader by means of the\n     * given function. This method works exactly as specified by the static\n     * {@link #defineModules(Configuration,List,Function) defineModules}\n     * method when invoked with this layer as the parent. In other words, if\n     * this layer is {@code thisLayer} then this method is equivalent to\n     * invoking:\n     * \u003cpre\u003e {@code\n     *     ModuleLayer.defineModules(cf, List.of(thisLayer), clf).layer();\n     * }\u003c/pre\u003e\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  clf\n     *         The function to map a module name to a class loader\n     *\n     * @return The newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the given configuration has more than one parent or the parent\n     *         of the configuration is not the configuration for this layer\n     * @throws LayerInstantiationException\n     *         If the layer cannot be created for any of the reasons specified\n     *         by the static {@code defineModules} method\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     */\n    public ModuleLayer defineModules(Configuration cf,\n                                     Function\u003cString, ClassLoader\u003e clf) {\n        return defineModules(cf, List.of(this), clf).layer();\n    }\n\n    /**\n     * Creates a new module layer by defining the modules in the given {@code\n     * Configuration} to the Java virtual machine. This method creates one\n     * class loader and defines all modules to that class loader.\n     *\n     * \u003cp\u003e The class loader created by this method implements \u003cem\u003edirect\n     * delegation\u003c/em\u003e when loading classes from modules. If the {@link\n     * ClassLoader#loadClass(String, boolean) loadClass} method is invoked to\n     * load a class then it uses the package name of the class to map it to a\n     * module. This may be a module in this layer and hence defined to the same\n     * class loader. It may be a package in a module in a parent layer that is\n     * exported to one or more of the modules in this layer. The class\n     * loader delegates to the class loader of the module, throwing {@code\n     * ClassNotFoundException} if not found by that class loader.\n     * When {@code loadClass} is invoked to load classes that do not map to a\n     * module then it delegates to the parent class loader. \u003c/p\u003e\n     *\n     * \u003cp\u003e The class loader created by this method locates resources\n     * ({@link ClassLoader#getResource(String) getResource}, {@link\n     * ClassLoader#getResources(String) getResources}, and other resource\n     * methods) in all modules in the layer before searching the parent class\n     * loader. \u003c/p\u003e\n     *\n     * \u003cp\u003e Attempting to create a layer with all modules defined to the same\n     * class loader can fail for the following reasons:\n     *\n     * \u003cul\u003e\n     *\n     *     \u003cli\u003e\u003cp\u003e \u003cem\u003eOverlapping packages\u003c/em\u003e: Two or more modules in the\n     *     configuration have the same package. \u003c/p\u003e\u003c/li\u003e\n     *\n     *     \u003cli\u003e\u003cp\u003e \u003cem\u003eSplit delegation\u003c/em\u003e: The resulting class loader would\n     *     need to delegate to more than one class loader in order to load\n     *     classes in a specific package. \u003c/p\u003e\u003c/li\u003e\n     *\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e In addition, a layer cannot be created if the configuration contains\n     * a module named \"{@code java.base}\", or a module contains a package named\n     * \"{@code java}\" or a package with a name starting with \"{@code java.}\". \u003c/p\u003e\n     *\n     * \u003cp\u003e If there is a security manager then the class loader created by\n     * this method will load classes and resources with privileges that are\n     * restricted by the calling context of this method. \u003c/p\u003e\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  parentLayers\n     *         The list of parent layers in search order\n     * @param  parentLoader\n     *         The parent class loader for the class loader created by this\n     *         method; may be {@code null} for the bootstrap class loader\n     *\n     * @return A controller that controls the newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the parent(s) of the given configuration do not match the\n     *         configuration of the parent layers, including order\n     * @throws LayerInstantiationException\n     *         If all modules cannot be defined to the same class loader for any\n     *         of the reasons listed above\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"createClassLoader\")} or\n     *         {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     *\n     * @see #findLoader\n     */\n    public static Controller defineModulesWithOneLoader(Configuration cf,\n                                                        List\u003cModuleLayer\u003e parentLayers,\n                                                        ClassLoader parentLoader)\n    {\n        List\u003cModuleLayer\u003e parents \u003d List.copyOf(parentLayers);\n        checkConfiguration(cf, parents);\n\n        checkCreateClassLoaderPermission();\n        checkGetClassLoaderPermission();\n\n        try {\n            Loader loader \u003d new Loader(cf.modules(), parentLoader);\n            loader.initRemotePackageMap(cf, parents);\n            ModuleLayer layer \u003d new ModuleLayer(cf, parents, mn -\u003e loader);\n            return new Controller(layer);\n        } catch (IllegalArgumentException | IllegalStateException e) {\n            throw new LayerInstantiationException(e.getMessage());\n        }\n    }\n\n    /**\n     * Creates a new module layer by defining the modules in the given {@code\n     * Configuration} to the Java virtual machine. Each module is defined to\n     * its own {@link ClassLoader} created by this method. The {@link\n     * ClassLoader#getParent() parent} of each class loader is the given parent\n     * class loader.\n     *\n     * \u003cp\u003e The class loaders created by this method implement \u003cem\u003edirect\n     * delegation\u003c/em\u003e when loading classes from modules. If the {@link\n     * ClassLoader#loadClass(String, boolean) loadClass} method is invoked to\n     * load a class then it uses the package name of the class to map it to a\n     * module. The package may be in the module defined to the class loader.\n     * The package may be exported by another module in this layer to the\n     * module defined to the class loader. It may be in a package exported by a\n     * module in a parent layer. The class loader delegates to the class loader\n     * of the module, throwing {@code ClassNotFoundException} if not found by\n     * that class loader. When {@code loadClass} is invoked to load a class\n     * that does not map to a module then it delegates to the parent class\n     * loader. \u003c/p\u003e\n     *\n     * \u003cp\u003e The class loaders created by this method locate resources\n     * ({@link ClassLoader#getResource(String) getResource}, {@link\n     * ClassLoader#getResources(String) getResources}, and other resource\n     * methods) in the module defined to the class loader before searching\n     * the parent class loader. \u003c/p\u003e\n     *\n     * \u003cp\u003e If there is a security manager then the class loaders created by\n     * this method will load classes and resources with privileges that are\n     * restricted by the calling context of this method. \u003c/p\u003e\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  parentLayers\n     *         The list of parent layers in search order\n     * @param  parentLoader\n     *         The parent class loader for each of the class loaders created by\n     *         this method; may be {@code null} for the bootstrap class loader\n     *\n     * @return A controller that controls the newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the parent(s) of the given configuration do not match the\n     *         configuration of the parent layers, including order\n     * @throws LayerInstantiationException\n     *         If the layer cannot be created because the configuration contains\n     *         a module named \"{@code java.base}\" or a module contains a package\n     *         named \"{@code java}\" or a package with a name starting with\n     *         \"{@code java.}\"\n     *\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"createClassLoader\")} or\n     *         {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     *\n     * @see #findLoader\n     */\n    public static Controller defineModulesWithManyLoaders(Configuration cf,\n                                                          List\u003cModuleLayer\u003e parentLayers,\n                                                          ClassLoader parentLoader)\n    {\n        List\u003cModuleLayer\u003e parents \u003d List.copyOf(parentLayers);\n        checkConfiguration(cf, parents);\n\n        checkCreateClassLoaderPermission();\n        checkGetClassLoaderPermission();\n\n        LoaderPool pool \u003d new LoaderPool(cf, parents, parentLoader);\n        try {\n            ModuleLayer layer \u003d new ModuleLayer(cf, parents, pool::loaderFor);\n            return new Controller(layer);\n        } catch (IllegalArgumentException | IllegalStateException e) {\n            throw new LayerInstantiationException(e.getMessage());\n        }\n    }\n\n    /**\n     * Creates a new module layer by defining the modules in the given {@code\n     * Configuration} to the Java virtual machine. The given function maps each\n     * module in the configuration, by name, to a class loader. Creating the\n     * layer informs the Java virtual machine about the classes that may be\n     * loaded so that the Java virtual machine knows which module that each\n     * class is a member of.\n     *\n     * \u003cp\u003e The class loader delegation implemented by the class loaders must\n     * respect module readability. The class loaders should be\n     * {@link ClassLoader#registerAsParallelCapable parallel-capable} so as to\n     * avoid deadlocks during class loading. In addition, the entity creating\n     * a new layer with this method should arrange that the class loaders be\n     * ready to load from these modules before there are any attempts to load\n     * classes or resources. \u003c/p\u003e\n     *\n     * \u003cp\u003e Creating a layer can fail for the following reasons: \u003c/p\u003e\n     *\n     * \u003cul\u003e\n     *\n     *     \u003cli\u003e\u003cp\u003e Two or more modules with the same package are mapped to the\n     *     same class loader. \u003c/p\u003e\u003c/li\u003e\n     *\n     *     \u003cli\u003e\u003cp\u003e A module is mapped to a class loader that already has a\n     *     module of the same name defined to it. \u003c/p\u003e\u003c/li\u003e\n     *\n     *     \u003cli\u003e\u003cp\u003e A module is mapped to a class loader that has already\n     *     defined types in any of the packages in the module. \u003c/p\u003e\u003c/li\u003e\n     *\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e In addition, a layer cannot be created if the configuration contains\n     * a module named \"{@code java.base}\", a configuration contains a module\n     * with a package named \"{@code java}\" or a package name starting with\n     * \"{@code java.}\", or the function to map a module name to a class loader\n     * returns {@code null} or the {@linkplain ClassLoader#getPlatformClassLoader()\n     * platform class loader}. \u003c/p\u003e\n     *\n     * \u003cp\u003e If the function to map a module name to class loader throws an error\n     * or runtime exception then it is propagated to the caller of this method.\n     * \u003c/p\u003e\n     *\n     * @apiNote It is implementation specific as to whether creating a layer\n     * with this method is an atomic operation or not. Consequently it is\n     * possible for this method to fail with some modules, but not all, defined\n     * to the Java virtual machine.\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  parentLayers\n     *         The list of parent layers in search order\n     * @param  clf\n     *         The function to map a module name to a class loader\n     *\n     * @return A controller that controls the newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the parent(s) of the given configuration do not match the\n     *         configuration of the parent layers, including order\n     * @throws LayerInstantiationException\n     *         If creating the layer fails for any of the reasons listed above\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     */\n    public static Controller defineModules(Configuration cf,\n                                           List\u003cModuleLayer\u003e parentLayers,\n                                           Function\u003cString, ClassLoader\u003e clf)\n    {\n        List\u003cModuleLayer\u003e parents \u003d List.copyOf(parentLayers);\n        checkConfiguration(cf, parents);\n        Objects.requireNonNull(clf);\n\n        checkGetClassLoaderPermission();\n\n        // The boot layer is checked during module system initialization\n        if (boot() !\u003d null) {\n            checkForDuplicatePkgs(cf, clf);\n        }\n\n        try {\n            ModuleLayer layer \u003d new ModuleLayer(cf, parents, clf);\n            return new Controller(layer);\n        } catch (IllegalArgumentException | IllegalStateException e) {\n            throw new LayerInstantiationException(e.getMessage());\n        }\n    }\n\n\n    /**\n     * Checks that the parent configurations match the configuration of\n     * the parent layers.\n     */\n    private static void checkConfiguration(Configuration cf,\n                                           List\u003cModuleLayer\u003e parentLayers)\n    {\n        Objects.requireNonNull(cf);\n\n        List\u003cConfiguration\u003e parentConfigurations \u003d cf.parents();\n        if (parentLayers.size() !\u003d parentConfigurations.size())\n            throw new IllegalArgumentException(\"wrong number of parents\");\n\n        int index \u003d 0;\n        for (ModuleLayer parent : parentLayers) {\n            if (parent.configuration() !\u003d parentConfigurations.get(index)) {\n                throw new IllegalArgumentException(\n                        \"Parent of configuration !\u003d configuration of this Layer\");\n            }\n            index++;\n        }\n    }\n\n    private static void checkCreateClassLoaderPermission() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null)\n            sm.checkPermission(SecurityConstants.CREATE_CLASSLOADER_PERMISSION);\n    }\n\n    private static void checkGetClassLoaderPermission() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null)\n            sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n    }\n\n    /**\n     * Checks a configuration and the module-to-loader mapping to ensure that\n     * no two modules mapped to the same class loader have the same package.\n     * It also checks that no two automatic modules have the same package.\n     *\n     * @throws LayerInstantiationException\n     */\n    private static void checkForDuplicatePkgs(Configuration cf,\n                                              Function\u003cString, ClassLoader\u003e clf)\n    {\n        // HashMap allows null keys\n        Map\u003cClassLoader, Set\u003cString\u003e\u003e loaderToPackages \u003d new HashMap\u003c\u003e();\n        for (ResolvedModule resolvedModule : cf.modules()) {\n            ModuleDescriptor descriptor \u003d resolvedModule.reference().descriptor();\n            ClassLoader loader \u003d clf.apply(descriptor.name());\n\n            Set\u003cString\u003e loaderPackages\n                \u003d loaderToPackages.computeIfAbsent(loader, k -\u003e new HashSet\u003c\u003e());\n\n            for (String pkg : descriptor.packages()) {\n                boolean added \u003d loaderPackages.add(pkg);\n                if (!added) {\n                    throw fail(\"More than one module with package %s mapped\" +\n                               \" to the same class loader\", pkg);\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates a LayerInstantiationException with the message formatted from\n     * the given format string and arguments.\n     */\n    private static LayerInstantiationException fail(String fmt, Object ... args) {\n        String msg \u003d String.format(fmt, args);\n        return new LayerInstantiationException(msg);\n    }\n\n\n    /**\n     * Returns the configuration for this layer.\n     *\n     * @return The configuration for this layer\n     */\n    public Configuration configuration() {\n        return cf;\n    }\n\n    /**\n     * Returns an unmodifiable list of this layer\u0027s parents, in search\n     * order. If this is the {@linkplain #empty() empty layer} then an\n     * empty list is returned.\n     *\n     * @return A possibly-empty unmodifiable list of this layer\u0027s parents\n     */\n    public List\u003cModuleLayer\u003e parents() {\n        return parents;\n    }\n\n\n    /**\n     * Returns an ordered stream of layers. The first element is this layer,\n     * the remaining elements are the parent layers in DFS order.\n     *\n     * @implNote For now, the assumption is that the number of elements will\n     * be very low and so this method does not use a specialized spliterator.\n     */\n    Stream\u003cModuleLayer\u003e layers() {\n        List\u003cModuleLayer\u003e allLayers \u003d this.allLayers;\n        if (allLayers !\u003d null)\n            return allLayers.stream();\n\n        allLayers \u003d new ArrayList\u003c\u003e();\n        Set\u003cModuleLayer\u003e visited \u003d new HashSet\u003c\u003e();\n        Deque\u003cModuleLayer\u003e stack \u003d new ArrayDeque\u003c\u003e();\n        visited.add(this);\n        stack.push(this);\n\n        while (!stack.isEmpty()) {\n            ModuleLayer layer \u003d stack.pop();\n            allLayers.add(layer);\n\n            // push in reverse order\n            for (int i \u003d layer.parents.size() - 1; i \u003e\u003d 0; i--) {\n                ModuleLayer parent \u003d layer.parents.get(i);\n                if (visited.add(parent)) {\n                    stack.push(parent);\n                }\n            }\n        }\n\n        this.allLayers \u003d allLayers \u003d Collections.unmodifiableList(allLayers);\n        return allLayers.stream();\n    }\n\n    private volatile List\u003cModuleLayer\u003e allLayers;\n\n    /**\n     * Returns an unmodifiable set of the modules in this layer.\n     *\n     * @return A possibly-empty unmodifiable set of the modules in this layer\n     */\n    public Set\u003cModule\u003e modules() {\n        Set\u003cModule\u003e modules \u003d this.modules;\n        if (modules \u003d\u003d null) {\n            this.modules \u003d modules \u003d Set.copyOf(nameToModule.values());\n        }\n        return modules;\n    }\n\n    private volatile Set\u003cModule\u003e modules;\n\n\n    /**\n     * Returns the module with the given name in this layer, or if not in this\n     * layer, the {@linkplain #parents() parent} layers. Finding a module in\n     * parent layers is equivalent to invoking {@code findModule} on each\n     * parent, in search order, until the module is found or all parents have\n     * been searched. In a \u003cem\u003etree of layers\u003c/em\u003e  then this is equivalent to\n     * a depth-first search.\n     *\n     * @param  name\n     *         The name of the module to find\n     *\n     * @return The module with the given name or an empty {@code Optional}\n     *         if there isn\u0027t a module with this name in this layer or any\n     *         parent layer\n     */\n    public Optional\u003cModule\u003e findModule(String name) {\n        Objects.requireNonNull(name);\n        if (this \u003d\u003d EMPTY_LAYER)\n            return Optional.empty();\n        Module m \u003d nameToModule.get(name);\n        if (m !\u003d null)\n            return Optional.of(m);\n\n        return layers()\n                .skip(1)  // skip this layer\n                .map(l -\u003e l.nameToModule.get(name))\n                .filter(Objects::nonNull)\n                .findAny();\n    }\n\n\n    /**\n     * Returns the {@code ClassLoader} for the module with the given name. If\n     * a module of the given name is not in this layer then the {@link #parents()\n     * parent} layers are searched in the manner specified by {@link\n     * #findModule(String) findModule}.\n     *\n     * \u003cp\u003e If there is a security manager then its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"getClassLoader\")}\n     * permission to check that the caller is allowed to get access to the\n     * class loader. \u003c/p\u003e\n     *\n     * @apiNote This method does not return an {@code Optional\u003cClassLoader\u003e}\n     * because `null` must be used to represent the bootstrap class loader.\n     *\n     * @param  name\n     *         The name of the module to find\n     *\n     * @return The ClassLoader that the module is defined to\n     *\n     * @throws IllegalArgumentException if a module of the given name is not\n     *         defined in this layer or any parent of this layer\n     *\n     * @throws SecurityException if denied by the security manager\n     */\n    public ClassLoader findLoader(String name) {\n        Optional\u003cModule\u003e om \u003d findModule(name);\n\n        // can\u0027t use map(Module::getClassLoader) as class loader can be null\n        if (om.isPresent()) {\n            return om.get().getClassLoader();\n        } else {\n            throw new IllegalArgumentException(\"Module \" + name\n                                               + \" not known to this layer\");\n        }\n    }\n\n    /**\n     * Returns a string describing this module layer.\n     *\n     * @return A possibly empty string describing this module layer\n     */\n    @Override\n    public String toString() {\n        return modules().stream()\n                .map(Module::getName)\n                .collect(Collectors.joining(\", \"));\n    }\n\n    /**\n     * Returns the \u003cem\u003eempty\u003c/em\u003e layer. There are no modules in the empty\n     * layer. It has no parents.\n     *\n     * @return The empty layer\n     */\n    public static ModuleLayer empty() {\n        return EMPTY_LAYER;\n    }\n\n\n    /**\n     * Returns the boot layer. The boot layer contains at least one module,\n     * {@code java.base}. Its parent is the {@link #empty() empty} layer.\n     *\n     * @apiNote This method returns {@code null} during startup and before\n     *          the boot layer is fully initialized.\n     *\n     * @return The boot layer\n     */\n    public static ModuleLayer boot() {\n        return System.bootLayer;\n    }\n\n    /**\n     * Returns the ServicesCatalog for this Layer, creating it if not\n     * already created.\n     */\n    ServicesCatalog getServicesCatalog() {\n        ServicesCatalog servicesCatalog \u003d this.servicesCatalog;\n        if (servicesCatalog !\u003d null)\n            return servicesCatalog;\n\n        synchronized (this) {\n            servicesCatalog \u003d this.servicesCatalog;\n            if (servicesCatalog \u003d\u003d null) {\n                servicesCatalog \u003d ServicesCatalog.create();\n                for (Module m : nameToModule.values()) {\n                    servicesCatalog.register(m);\n                }\n                this.servicesCatalog \u003d servicesCatalog;\n            }\n        }\n\n        return servicesCatalog;\n    }\n\n    private volatile ServicesCatalog servicesCatalog;\n\n\n    /**\n     * Record that this layer has at least one module defined to the given\n     * class loader.\n     */\n    void bindToLoader(ClassLoader loader) {\n        // CLV.computeIfAbsent(loader, (cl, clv) -\u003e new CopyOnWriteArrayList\u003c\u003e())\n        List\u003cModuleLayer\u003e list \u003d CLV.get(loader);\n        if (list \u003d\u003d null) {\n            list \u003d new CopyOnWriteArrayList\u003c\u003e();\n            List\u003cModuleLayer\u003e previous \u003d CLV.putIfAbsent(loader, list);\n            if (previous !\u003d null) list \u003d previous;\n        }\n        list.add(this);\n    }\n\n    /**\n     * Returns a stream of the layers that have at least one module defined to\n     * the given class loader.\n     */\n    static Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n        List\u003cModuleLayer\u003e list \u003d CLV.get(loader);\n        if (list !\u003d null) {\n            return list.stream();\n        } else {\n            return Stream.empty();\n        }\n    }\n\n    // the list of layers with modules defined to a class loader\n    private static final ClassLoaderValue\u003cList\u003cModuleLayer\u003e\u003e CLV \u003d new ClassLoaderValue\u003c\u003e();\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 3:45:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/ModuleLayer.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:38 WARN  Using indexes to guess the definition of Controller
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:38 WARN  Using indexes to guess the definition of Controller
2024.01.23 15:45:37 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 23, 2024 3:45:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/ModuleLayer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2014, 2022, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.lang.module.Configuration;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.module.ResolvedModule;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport jdk.internal.javac.PreviewFeature;\nimport jdk.internal.loader.ClassLoaderValue;\nimport jdk.internal.loader.Loader;\nimport jdk.internal.loader.LoaderPool;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.misc.CDS;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.security.util.SecurityConstants;\n\n/**\n * A layer of modules in the Java virtual machine.\n *\n * \u003cp\u003e A layer is created from a graph of modules in a {@link Configuration}\n * and a function that maps each module to a {@link ClassLoader}.\n * Creating a layer informs the Java virtual machine about the classes that\n * may be loaded from the modules so that the Java virtual machine knows which\n * module that each class is a member of. \u003c/p\u003e\n *\n * \u003cp\u003e Creating a layer creates a {@link Module} object for each {@link\n * ResolvedModule} in the configuration. For each resolved module that is\n * {@link ResolvedModule#reads() read}, the {@code Module} {@link\n * Module#canRead reads} the corresponding run-time {@code Module}, which may\n * be in the same layer or a {@link #parents() parent} layer. \u003c/p\u003e\n *\n * \u003cp\u003e The {@link #defineModulesWithOneLoader defineModulesWithOneLoader} and\n * {@link #defineModulesWithManyLoaders defineModulesWithManyLoaders} methods\n * provide convenient ways to create a module layer where all modules are\n * mapped to a single class loader or where each module is mapped to its own\n * class loader. The {@link #defineModules defineModules} method is for more\n * advanced cases where modules are mapped to custom class loaders by means of\n * a function specified to the method. Each of these methods has an instance\n * and static variant. The instance methods create a layer with the receiver\n * as the parent layer. The static methods are for more advanced cases where\n * there can be more than one parent layer or where a {@link\n * ModuleLayer.Controller Controller} is needed to control modules in the layer\n * \u003c/p\u003e\n *\n * \u003cp\u003e A Java virtual machine has at least one non-empty layer, the {@link\n * #boot() boot} layer, that is created when the Java virtual machine is\n * started. The boot layer contains module {@code java.base} and is the only\n * layer in the Java virtual machine with a module named \"{@code java.base}\".\n * The modules in the boot layer are mapped to the bootstrap class loader and\n * other class loaders that are \u003ca href\u003d\"ClassLoader.html#builtinLoaders\"\u003e\n * built-in\u003c/a\u003e into the Java virtual machine. The boot layer will often be\n * the {@link #parents() parent} when creating additional layers. \u003c/p\u003e\n *\n * \u003cp\u003e Each {@code Module} in a layer is created so that it {@link\n * Module#isExported(String) exports} and {@link Module#isOpen(String) opens}\n * the packages described by its {@link ModuleDescriptor}. Qualified exports\n * (where a package is exported to a set of target modules rather than all\n * modules) are reified when creating the layer as follows: \u003c/p\u003e\n * \u003cul\u003e\n *     \u003cli\u003e If module {@code X} exports a package to {@code Y}, and if the\n *     runtime {@code Module} {@code X} reads {@code Module} {@code Y}, then\n *     the package is exported to {@code Module} {@code Y} (which may be in\n *     the same layer as {@code X} or a parent layer). \u003c/li\u003e\n *\n *     \u003cli\u003e If module {@code X} exports a package to {@code Y}, and if the\n *     runtime {@code Module} {@code X} does not read {@code Y} then target\n *     {@code Y} is located as if by invoking {@link #findModule(String)\n *     findModule} to find the module in the layer or its parent layers. If\n *     {@code Y} is found then the package is exported to the instance of\n *     {@code Y} that was found. If {@code Y} is not found then the qualified\n *     export is ignored. \u003c/li\u003e\n * \u003c/ul\u003e\n *\n * \u003cp\u003e Qualified opens are handled in same way as qualified exports. \u003c/p\u003e\n *\n * \u003cp\u003e As when creating a {@code Configuration},\n * {@link ModuleDescriptor#isAutomatic() automatic} modules receive special\n * treatment when creating a layer. An automatic module is created in the\n * Java virtual machine as a {@code Module} that reads every unnamed {@code\n * Module} in the Java virtual machine. \u003c/p\u003e\n *\n * \u003cp\u003e Unless otherwise specified, passing a {@code null} argument to a method\n * in this class causes a {@link NullPointerException NullPointerException} to\n * be thrown. \u003c/p\u003e\n *\n * \u003ch2\u003e Example \u003c/h2\u003e\n *\n * \u003cp\u003e This example creates a configuration by resolving a module named\n * \"{@code myapp}\" with the configuration for the boot layer as the parent. It\n * then creates a new layer with the modules in this configuration. All modules\n * are defined to the same class loader. \u003c/p\u003e\n *\n * {@snippet :\n *     ModuleFinder finder \u003d ModuleFinder.of(dir1, dir2, dir3);\n *     ModuleLayer parent \u003d ModuleLayer.boot();\n *     Configuration cf \u003d parent.configuration()\n *                              .resolve(finder, ModuleFinder.of(), Set.of(\"myapp\"));\n *     ClassLoader scl \u003d ClassLoader.getSystemClassLoader();\n *     ModuleLayer layer \u003d parent.defineModulesWithOneLoader(cf, scl);\n *     Class\u003c?\u003e c \u003d layer.findLoader(\"myapp\").loadClass(\"app.Main\");\n * }\n *\n * @since 9\n * @see Module#getLayer()\n */\n\npublic final class ModuleLayer {\n\n    // the empty layer (may be initialized from the CDS archive)\n    private static @Stable ModuleLayer EMPTY_LAYER;\n    static {\n        CDS.initializeFromArchive(ModuleLayer.class);\n        if (EMPTY_LAYER \u003d\u003d null) {\n            // create a new empty layer if there is no archived version.\n            EMPTY_LAYER \u003d new ModuleLayer(Configuration.empty(), List.of(), null);\n        }\n    }\n\n    // the configuration from which this layer was created\n    private final Configuration cf;\n\n    // parent layers, empty in the case of the empty layer\n    private final List\u003cModuleLayer\u003e parents;\n\n    // maps module name to jlr.Module\n    private final Map\u003cString, Module\u003e nameToModule;\n\n    /**\n     * Creates a new module layer from the modules in the given configuration.\n     */\n    private ModuleLayer(Configuration cf,\n                        List\u003cModuleLayer\u003e parents,\n                        Function\u003cString, ClassLoader\u003e clf)\n    {\n        this.cf \u003d cf;\n        this.parents \u003d parents; // no need to do defensive copy\n\n        Map\u003cString, Module\u003e map;\n        if (parents.isEmpty()) {\n            map \u003d Map.of();\n        } else {\n            map \u003d Module.defineModules(cf, clf, this);\n        }\n        this.nameToModule \u003d map; // no need to do defensive copy\n    }\n\n    /**\n     * Controls a module layer. The static methods defined by {@link ModuleLayer}\n     * to create module layers return a {@code Controller} that can be used to\n     * control modules in the layer.\n     *\n     * \u003cp\u003e Unless otherwise specified, passing a {@code null} argument to a\n     * method in this class causes a {@link NullPointerException\n     * NullPointerException} to be thrown. \u003c/p\u003e\n     *\n     * @apiNote Care should be taken with {@code Controller} objects, they\n     * should never be shared with untrusted code.\n     *\n     * @since 9\n     */\n    public static final class Controller {\n        private final ModuleLayer layer;\n\n        Controller(ModuleLayer layer) {\n            this.layer \u003d layer;\n        }\n\n        /**\n         * Returns the layer that this object controls.\n         *\n         * @return the module layer\n         */\n        public ModuleLayer layer() {\n            return layer;\n        }\n\n        private void ensureInLayer(Module source) {\n            if (source.getLayer() !\u003d layer)\n                throw new IllegalArgumentException(source + \" not in layer\");\n        }\n\n\n        /**\n         * Updates module {@code source} in the layer to read module\n         * {@code target}. This method is a no-op if {@code source} already\n         * reads {@code target}.\n         *\n         * @implNote \u003cem\u003eRead edges\u003c/em\u003e added by this method are \u003cem\u003eweak\u003c/em\u003e\n         * and do not prevent {@code target} from being GC\u0027ed when {@code source}\n         * is strongly reachable.\n         *\n         * @param  source\n         *         The source module\n         * @param  target\n         *         The target module to read\n         *\n         * @return This controller\n         *\n         * @throws IllegalArgumentException\n         *         If {@code source} is not in the module layer\n         *\n         * @see Module#addReads\n         */\n        public Controller addReads(Module source, Module target) {\n            ensureInLayer(source);\n            source.implAddReads(target);\n            return this;\n        }\n\n        /**\n         * Updates module {@code source} in the layer to export a package to\n         * module {@code target}. This method is a no-op if {@code source}\n         * already exports the package to at least {@code target}.\n         *\n         * @param  source\n         *         The source module\n         * @param  pn\n         *         The package name\n         * @param  target\n         *         The target module\n         *\n         * @return This controller\n         *\n         * @throws IllegalArgumentException\n         *         If {@code source} is not in the module layer or the package\n         *         is not in the source module\n         *\n         * @see Module#addExports\n         */\n        public Controller addExports(Module source, String pn, Module target) {\n            ensureInLayer(source);\n            source.implAddExports(pn, target);\n            return this;\n        }\n\n        /**\n         * Updates module {@code source} in the layer to open a package to\n         * module {@code target}. This method is a no-op if {@code source}\n         * already opens the package to at least {@code target}.\n         *\n         * @param  source\n         *         The source module\n         * @param  pn\n         *         The package name\n         * @param  target\n         *         The target module\n         *\n         * @return This controller\n         *\n         * @throws IllegalArgumentException\n         *         If {@code source} is not in the module layer or the package\n         *         is not in the source module\n         *\n         * @see Module#addOpens\n         */\n        public Controller addOpens(Module source, String pn, Module target) {\n            ensureInLayer(source);\n            source.implAddOpens(pn, target);\n            return this;\n        }\n\n        /**\n         * Enables native access for a module in the layer if the caller\u0027s module\n         * has native access.\n         *\n         * \u003cp\u003e This method is \u003ca href\u003d\"foreign/package-summary.html#restricted\"\u003e\u003cem\u003erestricted\u003c/em\u003e\u003c/a\u003e.\n         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain\n         * from depending on restricted methods, and use safe and supported functionalities,\n         * where possible.\n         *\n         * @param  target\n         *         The module to update\n         *\n         * @return This controller\n         *\n         * @throws IllegalArgumentException\n         *         If {@code target} is not in the module layer\n         *\n         * @throws IllegalCallerException\n         *         If the caller is in a module that does not have native access enabled\n         *\n         * @since 20\n         */\n        @PreviewFeature(feature\u003dPreviewFeature.Feature.FOREIGN)\n        @CallerSensitive\n        public Controller enableNativeAccess(Module target) {\n            ensureInLayer(target);\n            Reflection.ensureNativeAccess(Reflection.getCallerClass(), Module.class,\n                \"enableNativeAccess\");\n            target.implAddEnableNativeAccess();\n            return this;\n        }\n    }\n\n\n    /**\n     * Creates a new module layer, with this layer as its parent, by defining the\n     * modules in the given {@code Configuration} to the Java virtual machine.\n     * This method creates one class loader and defines all modules to that\n     * class loader. The {@link ClassLoader#getParent() parent} of each class\n     * loader is the given parent class loader. This method works exactly as\n     * specified by the static {@link\n     * #defineModulesWithOneLoader(Configuration,List,ClassLoader)\n     * defineModulesWithOneLoader} method when invoked with this layer as the\n     * parent. In other words, if this layer is {@code thisLayer} then this\n     * method is equivalent to invoking:\n     * \u003cpre\u003e {@code\n     *     ModuleLayer.defineModulesWithOneLoader(cf, List.of(thisLayer), parentLoader).layer();\n     * }\u003c/pre\u003e\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  parentLoader\n     *         The parent class loader for the class loader created by this\n     *         method; may be {@code null} for the bootstrap class loader\n     *\n     * @return The newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the given configuration has more than one parent or the parent\n     *         of the configuration is not the configuration for this layer\n     * @throws LayerInstantiationException\n     *         If the layer cannot be created for any of the reasons specified\n     *         by the static {@code defineModulesWithOneLoader} method\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"createClassLoader\")} or\n     *         {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     *\n     * @see #findLoader\n     */\n    public ModuleLayer defineModulesWithOneLoader(Configuration cf,\n                                                  ClassLoader parentLoader) {\n        return defineModulesWithOneLoader(cf, List.of(this), parentLoader).layer();\n    }\n\n\n    /**\n     * Creates a new module layer, with this layer as its parent, by defining the\n     * modules in the given {@code Configuration} to the Java virtual machine.\n     * Each module is defined to its own {@link ClassLoader} created by this\n     * method. The {@link ClassLoader#getParent() parent} of each class loader\n     * is the given parent class loader. This method works exactly as specified\n     * by the static {@link\n     * #defineModulesWithManyLoaders(Configuration,List,ClassLoader)\n     * defineModulesWithManyLoaders} method when invoked with this layer as the\n     * parent. In other words, if this layer is {@code thisLayer} then this\n     * method is equivalent to invoking:\n     * \u003cpre\u003e {@code\n     *     ModuleLayer.defineModulesWithManyLoaders(cf, List.of(thisLayer), parentLoader).layer();\n     * }\u003c/pre\u003e\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  parentLoader\n     *         The parent class loader for each of the class loaders created by\n     *         this method; may be {@code null} for the bootstrap class loader\n     *\n     * @return The newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the given configuration has more than one parent or the parent\n     *         of the configuration is not the configuration for this layer\n     * @throws LayerInstantiationException\n     *         If the layer cannot be created for any of the reasons specified\n     *         by the static {@code defineModulesWithManyLoaders} method\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"createClassLoader\")} or\n     *         {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     *\n     * @see #findLoader\n     */\n    public ModuleLayer defineModulesWithManyLoaders(Configuration cf,\n                                                    ClassLoader parentLoader) {\n        return defineModulesWithManyLoaders(cf, List.of(this), parentLoader).layer();\n    }\n\n\n    /**\n     * Creates a new module layer, with this layer as its parent, by defining the\n     * modules in the given {@code Configuration} to the Java virtual machine.\n     * Each module is mapped, by name, to its class loader by means of the\n     * given function. This method works exactly as specified by the static\n     * {@link #defineModules(Configuration,List,Function) defineModules}\n     * method when invoked with this layer as the parent. In other words, if\n     * this layer is {@code thisLayer} then this method is equivalent to\n     * invoking:\n     * \u003cpre\u003e {@code\n     *     ModuleLayer.defineModules(cf, List.of(thisLayer), clf).layer();\n     * }\u003c/pre\u003e\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  clf\n     *         The function to map a module name to a class loader\n     *\n     * @return The newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the given configuration has more than one parent or the parent\n     *         of the configuration is not the configuration for this layer\n     * @throws LayerInstantiationException\n     *         If the layer cannot be created for any of the reasons specified\n     *         by the static {@code defineModules} method\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     */\n    public ModuleLayer defineModules(Configuration cf,\n                                     Function\u003cString, ClassLoader\u003e clf) {\n        return defineModules(cf, List.of(this), clf).layer();\n    }\n\n    /**\n     * Creates a new module layer by defining the modules in the given {@code\n     * Configuration} to the Java virtual machine. This method creates one\n     * class loader and defines all modules to that class loader.\n     *\n     * \u003cp\u003e The class loader created by this method implements \u003cem\u003edirect\n     * delegation\u003c/em\u003e when loading classes from modules. If the {@link\n     * ClassLoader#loadClass(String, boolean) loadClass} method is invoked to\n     * load a class then it uses the package name of the class to map it to a\n     * module. This may be a module in this layer and hence defined to the same\n     * class loader. It may be a package in a module in a parent layer that is\n     * exported to one or more of the modules in this layer. The class\n     * loader delegates to the class loader of the module, throwing {@code\n     * ClassNotFoundException} if not found by that class loader.\n     * When {@code loadClass} is invoked to load classes that do not map to a\n     * module then it delegates to the parent class loader. \u003c/p\u003e\n     *\n     * \u003cp\u003e The class loader created by this method locates resources\n     * ({@link ClassLoader#getResource(String) getResource}, {@link\n     * ClassLoader#getResources(String) getResources}, and other resource\n     * methods) in all modules in the layer before searching the parent class\n     * loader. \u003c/p\u003e\n     *\n     * \u003cp\u003e Attempting to create a layer with all modules defined to the same\n     * class loader can fail for the following reasons:\n     *\n     * \u003cul\u003e\n     *\n     *     \u003cli\u003e\u003cp\u003e \u003cem\u003eOverlapping packages\u003c/em\u003e: Two or more modules in the\n     *     configuration have the same package. \u003c/p\u003e\u003c/li\u003e\n     *\n     *     \u003cli\u003e\u003cp\u003e \u003cem\u003eSplit delegation\u003c/em\u003e: The resulting class loader would\n     *     need to delegate to more than one class loader in order to load\n     *     classes in a specific package. \u003c/p\u003e\u003c/li\u003e\n     *\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e In addition, a layer cannot be created if the configuration contains\n     * a module named \"{@code java.base}\", or a module contains a package named\n     * \"{@code java}\" or a package with a name starting with \"{@code java.}\". \u003c/p\u003e\n     *\n     * \u003cp\u003e If there is a security manager then the class loader created by\n     * this method will load classes and resources with privileges that are\n     * restricted by the calling context of this method. \u003c/p\u003e\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  parentLayers\n     *         The list of parent layers in search order\n     * @param  parentLoader\n     *         The parent class loader for the class loader created by this\n     *         method; may be {@code null} for the bootstrap class loader\n     *\n     * @return A controller that controls the newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the parent(s) of the given configuration do not match the\n     *         configuration of the parent layers, including order\n     * @throws LayerInstantiationException\n     *         If all modules cannot be defined to the same class loader for any\n     *         of the reasons listed above\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"createClassLoader\")} or\n     *         {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     *\n     * @see #findLoader\n     */\n    public static Controller defineModulesWithOneLoader(Configuration cf,\n                                                        List\u003cModuleLayer\u003e parentLayers,\n                                                        ClassLoader parentLoader)\n    {\n        List\u003cModuleLayer\u003e parents \u003d List.copyOf(parentLayers);\n        checkConfiguration(cf, parents);\n\n        checkCreateClassLoaderPermission();\n        checkGetClassLoaderPermission();\n\n        try {\n            Loader loader \u003d new Loader(cf.modules(), parentLoader);\n            loader.initRemotePackageMap(cf, parents);\n            ModuleLayer layer \u003d new ModuleLayer(cf, parents, mn -\u003e loader);\n            return new Controller(layer);\n        } catch (IllegalArgumentException | IllegalStateException e) {\n            throw new LayerInstantiationException(e.getMessage());\n        }\n    }\n\n    /**\n     * Creates a new module layer by defining the modules in the given {@code\n     * Configuration} to the Java virtual machine. Each module is defined to\n     * its own {@link ClassLoader} created by this method. The {@link\n     * ClassLoader#getParent() parent} of each class loader is the given parent\n     * class loader.\n     *\n     * \u003cp\u003e The class loaders created by this method implement \u003cem\u003edirect\n     * delegation\u003c/em\u003e when loading classes from modules. If the {@link\n     * ClassLoader#loadClass(String, boolean) loadClass} method is invoked to\n     * load a class then it uses the package name of the class to map it to a\n     * module. The package may be in the module defined to the class loader.\n     * The package may be exported by another module in this layer to the\n     * module defined to the class loader. It may be in a package exported by a\n     * module in a parent layer. The class loader delegates to the class loader\n     * of the module, throwing {@code ClassNotFoundException} if not found by\n     * that class loader. When {@code loadClass} is invoked to load a class\n     * that does not map to a module then it delegates to the parent class\n     * loader. \u003c/p\u003e\n     *\n     * \u003cp\u003e The class loaders created by this method locate resources\n     * ({@link ClassLoader#getResource(String) getResource}, {@link\n     * ClassLoader#getResources(String) getResources}, and other resource\n     * methods) in the module defined to the class loader before searching\n     * the parent class loader. \u003c/p\u003e\n     *\n     * \u003cp\u003e If there is a security manager then the class loaders created by\n     * this method will load classes and resources with privileges that are\n     * restricted by the calling context of this method. \u003c/p\u003e\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  parentLayers\n     *         The list of parent layers in search order\n     * @param  parentLoader\n     *         The parent class loader for each of the class loaders created by\n     *         this method; may be {@code null} for the bootstrap class loader\n     *\n     * @return A controller that controls the newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the parent(s) of the given configuration do not match the\n     *         configuration of the parent layers, including order\n     * @throws LayerInstantiationException\n     *         If the layer cannot be created because the configuration contains\n     *         a module named \"{@code java.base}\" or a module contains a package\n     *         named \"{@code java}\" or a package with a name starting with\n     *         \"{@code java.}\"\n     *\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"createClassLoader\")} or\n     *         {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     *\n     * @see #findLoader\n     */\n    public static Controller defineModulesWithManyLoaders(Configuration cf,\n                                                          List\u003cModuleLayer\u003e parentLayers,\n                                                          ClassLoader parentLoader)\n    {\n        List\u003cModuleLayer\u003e parents \u003d List.copyOf(parentLayers);\n        checkConfiguration(cf, parents);\n\n        checkCreateClassLoaderPermission();\n        checkGetClassLoaderPermission();\n\n        LoaderPool pool \u003d new LoaderPool(cf, parents, parentLoader);\n        try {\n            ModuleLayer layer \u003d new ModuleLayer(cf, parents, pool::loaderFor);\n            return new Controller(layer);\n        } catch (IllegalArgumentException | IllegalStateException e) {\n            throw new LayerInstantiationException(e.getMessage());\n        }\n    }\n\n    /**\n     * Creates a new module layer by defining the modules in the given {@code\n     * Configuration} to the Java virtual machine. The given function maps each\n     * module in the configuration, by name, to a class loader. Creating the\n     * layer informs the Java virtual machine about the classes that may be\n     * loaded so that the Java virtual machine knows which module that each\n     * class is a member of.\n     *\n     * \u003cp\u003e The class loader delegation implemented by the class loaders must\n     * respect module readability. The class loaders should be\n     * {@link ClassLoader#registerAsParallelCapable parallel-capable} so as to\n     * avoid deadlocks during class loading. In addition, the entity creating\n     * a new layer with this method should arrange that the class loaders be\n     * ready to load from these modules before there are any attempts to load\n     * classes or resources. \u003c/p\u003e\n     *\n     * \u003cp\u003e Creating a layer can fail for the following reasons: \u003c/p\u003e\n     *\n     * \u003cul\u003e\n     *\n     *     \u003cli\u003e\u003cp\u003e Two or more modules with the same package are mapped to the\n     *     same class loader. \u003c/p\u003e\u003c/li\u003e\n     *\n     *     \u003cli\u003e\u003cp\u003e A module is mapped to a class loader that already has a\n     *     module of the same name defined to it. \u003c/p\u003e\u003c/li\u003e\n     *\n     *     \u003cli\u003e\u003cp\u003e A module is mapped to a class loader that has already\n     *     defined types in any of the packages in the module. \u003c/p\u003e\u003c/li\u003e\n     *\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e In addition, a layer cannot be created if the configuration contains\n     * a module named \"{@code java.base}\", a configuration contains a module\n     * with a package named \"{@code java}\" or a package name starting with\n     * \"{@code java.}\", or the function to map a module name to a class loader\n     * returns {@code null} or the {@linkplain ClassLoader#getPlatformClassLoader()\n     * platform class loader}. \u003c/p\u003e\n     *\n     * \u003cp\u003e If the function to map a module name to class loader throws an error\n     * or runtime exception then it is propagated to the caller of this method.\n     * \u003c/p\u003e\n     *\n     * @apiNote It is implementation specific as to whether creating a layer\n     * with this method is an atomic operation or not. Consequently it is\n     * possible for this method to fail with some modules, but not all, defined\n     * to the Java virtual machine.\n     *\n     * @param  cf\n     *         The configuration for the layer\n     * @param  parentLayers\n     *         The list of parent layers in search order\n     * @param  clf\n     *         The function to map a module name to a class loader\n     *\n     * @return A controller that controls the newly created layer\n     *\n     * @throws IllegalArgumentException\n     *         If the parent(s) of the given configuration do not match the\n     *         configuration of the parent layers, including order\n     * @throws LayerInstantiationException\n     *         If creating the layer fails for any of the reasons listed above\n     * @throws SecurityException\n     *         If {@code RuntimePermission(\"getClassLoader\")} is denied by\n     *         the security manager\n     */\n    public static Controller defineModules(Configuration cf,\n                                           List\u003cModuleLayer\u003e parentLayers,\n                                           Function\u003cString, ClassLoader\u003e clf)\n    {\n        List\u003cModuleLayer\u003e parents \u003d List.copyOf(parentLayers);\n        checkConfiguration(cf, parents);\n        Objects.requireNonNull(clf);\n\n        checkGetClassLoaderPermission();\n\n        // The boot layer is checked during module system initialization\n        if (boot() !\u003d null) {\n            checkForDuplicatePkgs(cf, clf);\n        }\n\n        try {\n            ModuleLayer layer \u003d new ModuleLayer(cf, parents, clf);\n            return new Controller(layer);\n        } catch (IllegalArgumentException | IllegalStateException e) {\n            throw new LayerInstantiationException(e.getMessage());\n        }\n    }\n\n\n    /**\n     * Checks that the parent configurations match the configuration of\n     * the parent layers.\n     */\n    private static void checkConfiguration(Configuration cf,\n                                           List\u003cModuleLayer\u003e parentLayers)\n    {\n        Objects.requireNonNull(cf);\n\n        List\u003cConfiguration\u003e parentConfigurations \u003d cf.parents();\n        if (parentLayers.size() !\u003d parentConfigurations.size())\n            throw new IllegalArgumentException(\"wrong number of parents\");\n\n        int index \u003d 0;\n        for (ModuleLayer parent : parentLayers) {\n            if (parent.configuration() !\u003d parentConfigurations.get(index)) {\n                throw new IllegalArgumentException(\n                        \"Parent of configuration !\u003d configuration of this Layer\");\n            }\n            index++;\n        }\n    }\n\n    private static void checkCreateClassLoaderPermission() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null)\n            sm.checkPermission(SecurityConstants.CREATE_CLASSLOADER_PERMISSION);\n    }\n\n    private static void checkGetClassLoaderPermission() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null)\n            sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n    }\n\n    /**\n     * Checks a configuration and the module-to-loader mapping to ensure that\n     * no two modules mapped to the same class loader have the same package.\n     * It also checks that no two automatic modules have the same package.\n     *\n     * @throws LayerInstantiationException\n     */\n    private static void checkForDuplicatePkgs(Configuration cf,\n                                              Function\u003cString, ClassLoader\u003e clf)\n    {\n        // HashMap allows null keys\n        Map\u003cClassLoader, Set\u003cString\u003e\u003e loaderToPackages \u003d new HashMap\u003c\u003e();\n        for (ResolvedModule resolvedModule : cf.modules()) {\n            ModuleDescriptor descriptor \u003d resolvedModule.reference().descriptor();\n            ClassLoader loader \u003d clf.apply(descriptor.name());\n\n            Set\u003cString\u003e loaderPackages\n                \u003d loaderToPackages.computeIfAbsent(loader, k -\u003e new HashSet\u003c\u003e());\n\n            for (String pkg : descriptor.packages()) {\n                boolean added \u003d loaderPackages.add(pkg);\n                if (!added) {\n                    throw fail(\"More than one module with package %s mapped\" +\n                               \" to the same class loader\", pkg);\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates a LayerInstantiationException with the message formatted from\n     * the given format string and arguments.\n     */\n    private static LayerInstantiationException fail(String fmt, Object ... args) {\n        String msg \u003d String.format(fmt, args);\n        return new LayerInstantiationException(msg);\n    }\n\n\n    /**\n     * Returns the configuration for this layer.\n     *\n     * @return The configuration for this layer\n     */\n    public Configuration configuration() {\n        return cf;\n    }\n\n    /**\n     * Returns an unmodifiable list of this layer\u0027s parents, in search\n     * order. If this is the {@linkplain #empty() empty layer} then an\n     * empty list is returned.\n     *\n     * @return A possibly-empty unmodifiable list of this layer\u0027s parents\n     */\n    public List\u003cModuleLayer\u003e parents() {\n        return parents;\n    }\n\n\n    /**\n     * Returns an ordered stream of layers. The first element is this layer,\n     * the remaining elements are the parent layers in DFS order.\n     *\n     * @implNote For now, the assumption is that the number of elements will\n     * be very low and so this method does not use a specialized spliterator.\n     */\n    Stream\u003cModuleLayer\u003e layers() {\n        List\u003cModuleLayer\u003e allLayers \u003d this.allLayers;\n        if (allLayers !\u003d null)\n            return allLayers.stream();\n\n        allLayers \u003d new ArrayList\u003c\u003e();\n        Set\u003cModuleLayer\u003e visited \u003d new HashSet\u003c\u003e();\n        Deque\u003cModuleLayer\u003e stack \u003d new ArrayDeque\u003c\u003e();\n        visited.add(this);\n        stack.push(this);\n\n        while (!stack.isEmpty()) {\n            ModuleLayer layer \u003d stack.pop();\n            allLayers.add(layer);\n\n            // push in reverse order\n            for (int i \u003d layer.parents.size() - 1; i \u003e\u003d 0; i--) {\n                ModuleLayer parent \u003d layer.parents.get(i);\n                if (visited.add(parent)) {\n                    stack.push(parent);\n                }\n            }\n        }\n\n        this.allLayers \u003d allLayers \u003d Collections.unmodifiableList(allLayers);\n        return allLayers.stream();\n    }\n\n    private volatile List\u003cModuleLayer\u003e allLayers;\n\n    /**\n     * Returns an unmodifiable set of the modules in this layer.\n     *\n     * @return A possibly-empty unmodifiable set of the modules in this layer\n     */\n    public Set\u003cModule\u003e modules() {\n        Set\u003cModule\u003e modules \u003d this.modules;\n        if (modules \u003d\u003d null) {\n            this.modules \u003d modules \u003d Set.copyOf(nameToModule.values());\n        }\n        return modules;\n    }\n\n    private volatile Set\u003cModule\u003e modules;\n\n\n    /**\n     * Returns the module with the given name in this layer, or if not in this\n     * layer, the {@linkplain #parents() parent} layers. Finding a module in\n     * parent layers is equivalent to invoking {@code findModule} on each\n     * parent, in search order, until the module is found or all parents have\n     * been searched. In a \u003cem\u003etree of layers\u003c/em\u003e  then this is equivalent to\n     * a depth-first search.\n     *\n     * @param  name\n     *         The name of the module to find\n     *\n     * @return The module with the given name or an empty {@code Optional}\n     *         if there isn\u0027t a module with this name in this layer or any\n     *         parent layer\n     */\n    public Optional\u003cModule\u003e findModule(String name) {\n        Objects.requireNonNull(name);\n        if (this \u003d\u003d EMPTY_LAYER)\n            return Optional.empty();\n        Module m \u003d nameToModule.get(name);\n        if (m !\u003d null)\n            return Optional.of(m);\n\n        return layers()\n                .skip(1)  // skip this layer\n                .map(l -\u003e l.nameToModule.get(name))\n                .filter(Objects::nonNull)\n                .findAny();\n    }\n\n\n    /**\n     * Returns the {@code ClassLoader} for the module with the given name. If\n     * a module of the given name is not in this layer then the {@link #parents()\n     * parent} layers are searched in the manner specified by {@link\n     * #findModule(String) findModule}.\n     *\n     * \u003cp\u003e If there is a security manager then its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"getClassLoader\")}\n     * permission to check that the caller is allowed to get access to the\n     * class loader. \u003c/p\u003e\n     *\n     * @apiNote This method does not return an {@code Optional\u003cClassLoader\u003e}\n     * because `null` must be used to represent the bootstrap class loader.\n     *\n     * @param  name\n     *         The name of the module to find\n     *\n     * @return The ClassLoader that the module is defined to\n     *\n     * @throws IllegalArgumentException if a module of the given name is not\n     *         defined in this layer or any parent of this layer\n     *\n     * @throws SecurityException if denied by the security manager\n     */\n    public ClassLoader findLoader(String name) {\n        Optional\u003cModule\u003e om \u003d findModule(name);\n\n        // can\u0027t use map(Module::getClassLoader) as class loader can be null\n        if (om.isPresent()) {\n            return om.get().getClassLoader();\n        } else {\n            throw new IllegalArgumentException(\"Module \" + name\n                                               + \" not known to this layer\");\n        }\n    }\n\n    /**\n     * Returns a string describing this module layer.\n     *\n     * @return A possibly empty string describing this module layer\n     */\n    @Override\n    public String toString() {\n        return modules().stream()\n                .map(Module::getName)\n                .collect(Collectors.joining(\", \"));\n    }\n\n    /**\n     * Returns the \u003cem\u003eempty\u003c/em\u003e layer. There are no modules in the empty\n     * layer. It has no parents.\n     *\n     * @return The empty layer\n     */\n    public static ModuleLayer empty() {\n        return EMPTY_LAYER;\n    }\n\n\n    /**\n     * Returns the boot layer. The boot layer contains at least one module,\n     * {@code java.base}. Its parent is the {@link #empty() empty} layer.\n     *\n     * @apiNote This method returns {@code null} during startup and before\n     *          the boot layer is fully initialized.\n     *\n     * @return The boot layer\n     */\n    public static ModuleLayer boot() {\n        return System.bootLayer;\n    }\n\n    /**\n     * Returns the ServicesCatalog for this Layer, creating it if not\n     * already created.\n     */\n    ServicesCatalog getServicesCatalog() {\n        ServicesCatalog servicesCatalog \u003d this.servicesCatalog;\n        if (servicesCatalog !\u003d null)\n            return servicesCatalog;\n\n        synchronized (this) {\n            servicesCatalog \u003d this.servicesCatalog;\n            if (servicesCatalog \u003d\u003d null) {\n                servicesCatalog \u003d ServicesCatalog.create();\n                for (Module m : nameToModule.values()) {\n                    servicesCatalog.register(m);\n                }\n                this.servicesCatalog \u003d servicesCatalog;\n            }\n        }\n\n        return servicesCatalog;\n    }\n\n    private volatile ServicesCatalog servicesCatalog;\n\n\n    /**\n     * Record that this layer has at least one module defined to the given\n     * class loader.\n     */\n    void bindToLoader(ClassLoader loader) {\n        // CLV.computeIfAbsent(loader, (cl, clv) -\u003e new CopyOnWriteArrayList\u003c\u003e())\n        List\u003cModuleLayer\u003e list \u003d CLV.get(loader);\n        if (list \u003d\u003d null) {\n            list \u003d new CopyOnWriteArrayList\u003c\u003e();\n            List\u003cModuleLayer\u003e previous \u003d CLV.putIfAbsent(loader, list);\n            if (previous !\u003d null) list \u003d previous;\n        }\n        list.add(this);\n    }\n\n    /**\n     * Returns a stream of the layers that have at least one module defined to\n     * the given class loader.\n     */\n    static Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n        List\u003cModuleLayer\u003e list \u003d CLV.get(loader);\n        if (list !\u003d null) {\n            return list.stream();\n        } else {\n            return Stream.empty();\n        }\n    }\n\n    // the list of layers with modules defined to a class loader\n    private static final ClassLoaderValue\u003cList\u003cModuleLayer\u003e\u003e CLV \u003d new ClassLoaderValue\u003c\u003e();\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 23, 2024 3:45:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/ModuleLayer.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/ModuleLayer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.23 15:45:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 INFO  compiling root-test (1 scala source)
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:39 INFO  time: compiled root-test in 0.5s
2024.01.23 15:45:44 INFO  compiling root-test (1 scala source)
Exception in thread "pool-10-thread-19" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:45:44 INFO  time: compiled root-test in 0.49s
2024.01.23 15:45:49 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:49 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:49 INFO  compiling root-test (1 scala source)
2024.01.23 15:45:49 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:45:49 INFO  time: compiled root-test in 0.47s
2024.01.23 15:45:51 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:45:51 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:45:51 INFO  Starting debug proxy for [test.Tests(Singleton is the only instance)]
2024.01.23 15:45:51 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54677 .
2024.01.23 15:45:51 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:45:52 INFO  Canceling debug proxy for [test.Tests(Singleton is the only instance)]
2024.01.23 15:45:51 INFO  Closing debug server tcp://0.0.0.0:54674
2024.01.23 15:46:03 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:46:03 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:46:03 INFO  Starting debug proxy for [test.Tests(Singleton is the only instance)]
2024.01.23 15:46:03 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54688 .
2024.01.23 15:46:03 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:46:03 INFO  Canceling debug proxy for [test.Tests(Singleton is the only instance)]
2024.01.23 15:46:03 INFO  Closing debug server tcp://0.0.0.0:54685
2024.01.23 15:46:16 INFO  compiling root-test (1 scala source)
2024.01.23 15:46:16 INFO  time: compiled root-test in 0.62s
2024.01.23 15:46:19 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:46:19 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:46:19 INFO  compiling root-test (1 scala source)
2024.01.23 15:46:19 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:46:19 INFO  time: compiled root-test in 0.45s
2024.01.23 15:46:22 INFO  compiling root-test (1 scala source)
2024.01.23 15:46:22 INFO  time: compiled root-test in 86ms
2024.01.23 15:46:27 INFO  compiling root-test (1 scala source)
2024.01.23 15:46:27 INFO  time: compiled root-test in 0.46s
2024.01.23 15:46:31 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:46:31 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:46:31 INFO  Starting debug proxy for [test.Tests(Singleton is the only instance)]
2024.01.23 15:46:31 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54699 .
2024.01.23 15:46:31 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:46:32 INFO  Canceling debug proxy for [test.Tests(Singleton is the only instance)]
2024.01.23 15:46:31 INFO  Closing debug server tcp://0.0.0.0:54696
2024.01.23 15:47:25 INFO  compiling root (1 scala source)
2024.01.23 15:47:25 INFO  time: compiled root in 0.36s
2024.01.23 15:47:28 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.23 15:47:28 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.23 15:47:28 INFO  Starting debug proxy for [test.Tests(Singleton is the only instance)]
2024.01.23 15:47:28 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54728 .
2024.01.23 15:47:28 INFO  Attaching to debuggee VM succeeded.
2024.01.23 15:47:29 INFO  Canceling debug proxy for [test.Tests(Singleton is the only instance)]
2024.01.23 15:47:28 INFO  Closing debug server tcp://0.0.0.0:54725
2024.01.23 15:48:44 INFO  compiling root (1 scala source)
2024.01.23 15:48:44 INFO  time: compiled root in 0.46s
2024.01.23 15:48:47 INFO  compiling root (1 scala source)
2024.01.23 15:48:47 INFO  time: compiled root in 0.46s
2024.01.23 15:49:05 INFO  compiling root (2 scala sources)
2024.01.23 15:49:05 INFO  time: compiled root in 0.67s
2024.01.23 15:49:10 INFO  compiling root (1 scala source)
2024.01.23 15:49:10 INFO  time: compiled root in 0.47s
2024.01.23 15:49:10 INFO  compiling root-test (1 scala source)
2024.01.23 15:49:11 INFO  time: compiled root-test in 68ms
2024.01.23 15:49:13 WARN  Using indexes to guess the definition of ScalaFunctions
2024.01.23 15:49:14 WARN  Using indexes to guess the definition of ScalaFunctions
2024.01.23 15:49:15 INFO  compiling root-test (1 scala source)
2024.01.23 15:49:15 INFO  time: compiled root-test in 77ms
2024.01.23 15:49:17 INFO  compiling root-test (1 scala source)
2024.01.23 15:49:17 INFO  time: compiled root-test in 76ms
2024.01.23 15:49:20 INFO  compiling root-test (1 scala source)
2024.01.23 15:49:20 INFO  time: compiled root-test in 68ms
ene 23, 2024 3:49:24 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7626
2024.01.23 15:49:24 INFO  compiling root-test (1 scala source)
ene 23, 2024 3:49:24 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7628
2024.01.23 15:49:24 INFO  time: compiled root-test in 0.49s
2024.01.23 15:49:27 INFO  compiling root (1 scala source)
2024.01.23 15:49:27 INFO  time: compiled root in 0.47s
2024.01.23 15:49:27 INFO  compiling root (3 scala sources)
2024.01.23 15:49:27 INFO  time: compiled root in 15ms
2024.01.23 15:49:32 INFO  compiling root (3 scala sources)
2024.01.23 15:49:32 INFO  time: compiled root in 33ms
2024.01.23 15:49:32 INFO  compiling root (3 scala sources)
2024.01.23 15:49:32 INFO  time: compiled root in 20ms
2024.01.23 15:49:32 INFO  compiling root (3 scala sources)
2024.01.23 15:49:32 INFO  time: compiled root in 17ms
2024.01.23 15:49:33 INFO  compiling root (3 scala sources)
2024.01.23 15:49:33 INFO  time: compiled root in 34ms
2024.01.23 15:49:37 INFO  compiling root (3 scala sources)
2024.01.23 15:49:37 INFO  time: compiled root in 0.48s
2024.01.23 15:49:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:49:46 INFO  compiling root-test (1 scala source)
2024.01.23 15:49:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:49:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:49:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:49:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:49:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:49:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:49:46 INFO  time: compiled root-test in 0.48s
2024.01.23 15:49:56 INFO  compiling root-test (1 scala source)
2024.01.23 15:49:56 INFO  time: compiled root-test in 0.6s
2024.01.23 15:49:58 INFO  compiling root-test (1 scala source)
2024.01.23 15:49:58 INFO  time: compiled root-test in 0.45s
2024.01.23 15:50:00 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:50:00 INFO  compiling root-test (1 scala source)
2024.01.23 15:50:00 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 15:50:00 INFO  time: compiled root-test in 0.47s
2024.01.23 15:50:32 INFO  compiling root (1 scala source)
2024.01.23 15:50:32 INFO  time: compiled root in 0.49s
2024.01.23 15:50:37 INFO  compiling root (3 scala sources)
2024.01.23 15:50:37 INFO  time: compiled root in 36ms
2024.01.23 15:50:37 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 15:50:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 15:50:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 15:50:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 15:50:40 INFO  compiling root (3 scala sources)
2024.01.23 15:50:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 15:50:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 15:50:40 INFO  time: compiled root in 30ms
2024.01.23 15:50:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 15:50:43 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 15:50:43 INFO  compiling root (3 scala sources)
2024.01.23 15:50:43 INFO  time: compiled root in 0.5s
2024.01.23 15:50:45 INFO  compiling root (1 scala source)
2024.01.23 15:50:45 INFO  time: compiled root in 0.26s
2024.01.23 15:50:53 INFO  compiling root (1 scala source)
2024.01.23 15:50:53 INFO  time: compiled root in 55ms
2024.01.23 15:50:53 INFO  compiling root (1 scala source)
2024.01.23 15:50:53 INFO  time: compiled root in 22ms
2024.01.23 15:50:55 INFO  compiling root (1 scala source)
2024.01.23 15:50:55 INFO  time: compiled root in 0.3s
2024.01.23 15:52:26 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 15:52:29 INFO  time: compiled root in 2.67s
2024.01.23 15:57:32 INFO  compiling root (1 scala source)
2024.01.23 15:57:32 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 15:57:32 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 15:57:32 WARN  Using indexes to guess the definition of main
2024.01.23 15:57:32 INFO  time: compiled root in 0.37s
Exception in thread "pool-7-thread-4" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 15:57:49 WARN  Using indexes to guess the definition of main
2024.01.23 15:57:53 INFO  compiling root (1 scala source)
2024.01.23 15:57:53 INFO  time: compiled root in 29ms
2024.01.23 15:57:56 INFO  compiling root (1 scala source)
2024.01.23 15:57:56 INFO  time: compiled root in 49ms
2024.01.23 15:58:06 INFO  compiling root (1 scala source)
2024.01.23 15:58:06 INFO  time: compiled root in 44ms
2024.01.23 15:58:45 INFO  compiling root (1 scala source)
2024.01.23 15:58:45 INFO  time: compiled root in 54ms
2024.01.23 15:58:47 INFO  compiling root (1 scala source)
2024.01.23 15:58:47 INFO  time: compiled root in 50ms
2024.01.23 15:58:58 INFO  compiling root (1 scala source)
2024.01.23 15:58:58 INFO  time: compiled root in 80ms
2024.01.23 15:59:31 INFO  compiling root (1 scala source)
2024.01.23 15:59:31 INFO  time: compiled root in 0.12s
2024.01.23 15:59:44 INFO  compiling root (1 scala source)
2024.01.23 15:59:44 INFO  time: compiled root in 48ms
2024.01.23 15:59:49 INFO  compiling root (1 scala source)
2024.01.23 15:59:49 INFO  time: compiled root in 48ms
2024.01.23 15:59:59 INFO  compiling root (1 scala source)
2024.01.23 15:59:59 INFO  time: compiled root in 39ms
2024.01.23 16:00:07 INFO  compiling root (1 scala source)
2024.01.23 16:00:07 INFO  time: compiled root in 45ms
ene 23, 2024 4:00:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8083
2024.01.23 16:00:09 INFO  compiling root (1 scala source)
2024.01.23 16:00:09 INFO  time: compiled root in 38ms
2024.01.23 16:00:12 INFO  compiling root (1 scala source)
2024.01.23 16:00:12 INFO  time: compiled root in 36ms
2024.01.23 16:00:18 WARN  Using indexes to guess the definition of Metric
2024.01.23 16:00:18 INFO  compiling root (1 scala source)
2024.01.23 16:00:18 INFO  time: compiled root in 40ms
2024.01.23 16:00:27 INFO  compiling root (1 scala source)
2024.01.23 16:00:27 INFO  time: compiled root in 33ms
2024.01.23 16:00:58 INFO  compiling root (1 scala source)
2024.01.23 16:00:58 INFO  time: compiled root in 36ms
2024.01.23 16:01:27 INFO  running 'C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals16007447257997956146\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.01.23 16:01:28 INFO  [info] welcome to sbt 1.9.7 (Oracle Corporation Java 21.0.1)
2024.01.23 16:01:28 INFO  [info] loading settings for project scala-projects-build-build from metals.sbt ...
2024.01.23 16:01:29 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\project
2024.01.23 16:01:29 INFO  [info] loading settings for project scala-projects-build from metals.sbt ...
2024.01.23 16:01:29 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\Scala-Projects\project
2024.01.23 16:01:32 INFO  [success] Generated .bloop\scala-projects-build.json
2024.01.23 16:01:32 INFO  [success] Total time: 2 s, completed 23 ene 2024, 16:01:32
2024.01.23 16:01:33 ERROR C:\URV\Progra\RepositorioGitHub\Scala-Projects\build.sbt:12: error: value libraryDependencies is not a member of sbt.librarymanagement.ModuleID
2024.01.23 16:01:33 ERROR possible cause: maybe a semicolon is missing before `value libraryDependencies'?
2024.01.23 16:01:33 ERROR     libraryDependencies ++= Seq(
2024.01.23 16:01:33 ERROR     ^
2024.01.23 16:01:33 ERROR C:\URV\Progra\RepositorioGitHub\Scala-Projects\build.sbt:12: error: not found: value ++=
2024.01.23 16:01:33 ERROR     libraryDependencies ++= Seq(
2024.01.23 16:01:33 ERROR                         ^
2024.01.23 16:01:33 ERROR sbt.compiler.EvalException: Type error in expression
2024.01.23 16:01:33 INFO  [error] sbt.compiler.EvalException: Type error in expression
2024.01.23 16:01:33 INFO  [error] Use 'last' for the full log.
2024.01.23 16:01:33 INFO  [warn] Project loading failed: (r)etry, (q)uit, (l)ast, or (i)gnore? (default: r)
2024.01.23 16:01:33 INFO  time: ran 'sbt bloopInstall' in 6.51s
2024.01.23 16:01:33 ERROR sbt command failed: C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals16007447257997956146\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.01.23 16:01:33 INFO  Disconnecting from Bloop session...
2024.01.23 16:01:33 INFO  Shut down connection with build server.
2024.01.23 16:01:33 INFO  Shut down connection with build server.
2024.01.23 16:01:33 INFO  Attempting to connect to the build server...
2024.01.23 16:01:33 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:01:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:01:33 INFO  Attempting to connect to the build server...
2024.01.23 16:01:33 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:01:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:01:33 INFO  time: Connected to build server in 85ms
2024.01.23 16:01:33 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 16:01:35 INFO  time: indexed workspace in 1.59s
2024.01.23 16:01:35 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala copy\MacroWorkSpace.scala
2024.01.23 16:01:35 INFO  compiling root (1 scala source)
2024.01.23 16:01:36 INFO  time: compiled root in 1.21s
2024.01.23 16:01:36 INFO  skipping build import with status 'Failed'
2024.01.23 16:01:39 INFO  skipping build import with status 'Failed'
2024.01.23 16:01:40 INFO  skipping build import with status 'Failed'
2024.01.23 16:01:49 INFO  running 'C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals8965314325349692481\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.01.23 16:01:50 INFO  [info] welcome to sbt 1.9.7 (Oracle Corporation Java 21.0.1)
2024.01.23 16:01:50 INFO  [info] loading settings for project scala-projects-build-build from metals.sbt ...
2024.01.23 16:01:51 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\project
2024.01.23 16:01:51 INFO  [info] loading settings for project scala-projects-build from metals.sbt ...
2024.01.23 16:01:51 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\Scala-Projects\project
2024.01.23 16:01:54 INFO  [success] Generated .bloop\scala-projects-build.json
2024.01.23 16:01:54 INFO  [success] Total time: 2 s, completed 23 ene 2024, 16:01:54
2024.01.23 16:01:54 INFO  [info] loading settings for project root from build.sbt ...
2024.01.23 16:01:54 INFO  [info] set current project to P2 TAP (in build file:/C:/URV/Progra/RepositorioGitHub/Scala-Projects/)
2024.01.23 16:01:54 INFO  [success] Generated .bloop\root-test.json
2024.01.23 16:01:54 INFO  [success] Generated .bloop\root.json
2024.01.23 16:01:54 INFO  [success] Total time: 0 s, completed 23 ene 2024, 16:01:55
2024.01.23 16:01:55 INFO  time: ran 'sbt bloopInstall' in 6.16s
2024.01.23 16:01:55 INFO  Disconnecting from Bloop session...
2024.01.23 16:01:55 INFO  Shut down connection with build server.
2024.01.23 16:01:55 INFO  Shut down connection with build server.
2024.01.23 16:01:55 INFO  Attempting to connect to the build server...
2024.01.23 16:01:55 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:01:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:01:55 INFO  Attempting to connect to the build server...
2024.01.23 16:01:55 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:01:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:01:55 INFO  time: Connected to build server in 75ms
2024.01.23 16:01:55 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 16:01:56 INFO  time: indexed workspace in 1.53s
2024.01.23 16:01:56 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala copy\MacroWorkSpace.scala
2024.01.23 16:02:00 INFO  compiling root (1 scala source)
2024.01.23 16:02:00 INFO  time: compiled root in 36ms
2024.01.23 16:02:36 INFO  running 'C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals5578071581164927455\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.01.23 16:02:37 INFO  [info] welcome to sbt 1.9.7 (Oracle Corporation Java 21.0.1)
2024.01.23 16:02:37 INFO  [info] loading settings for project scala-projects-build-build from metals.sbt ...
2024.01.23 16:02:39 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\project
2024.01.23 16:02:39 INFO  [info] loading settings for project scala-projects-build from metals.sbt ...
2024.01.23 16:02:39 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\Scala-Projects\project
2024.01.23 16:02:41 INFO  [success] Generated .bloop\scala-projects-build.json
2024.01.23 16:02:41 INFO  [success] Total time: 2 s, completed 23 ene 2024, 16:02:42
2024.01.23 16:02:44 INFO  [info] loading settings for project root from build.sbt ...
2024.01.23 16:02:44 INFO  [info] set current project to P2 TAP (in build file:/C:/URV/Progra/RepositorioGitHub/Scala-Projects/)
2024.01.23 16:02:44 INFO  [success] Generated .bloop\root.json
2024.01.23 16:02:44 INFO  [success] Generated .bloop\root-test.json
2024.01.23 16:02:44 INFO  [success] Total time: 0 s, completed 23 ene 2024, 16:02:44
2024.01.23 16:02:44 INFO  time: ran 'sbt bloopInstall' in 8.42s
2024.01.23 16:02:44 INFO  Disconnecting from Bloop session...
2024.01.23 16:02:44 INFO  Shut down connection with build server.
2024.01.23 16:02:44 INFO  Shut down connection with build server.
2024.01.23 16:02:44 INFO  Attempting to connect to the build server...
2024.01.23 16:02:44 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:02:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:02:44 INFO  Attempting to connect to the build server...
2024.01.23 16:02:44 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:02:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:02:44 INFO  time: Connected to build server in 82ms
2024.01.23 16:02:44 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 16:02:46 INFO  time: indexed workspace in 1.58s
2024.01.23 16:02:46 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala copy\MacroWorkSpace.scala
2024.01.23 16:02:46 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:02:47 INFO  time: compiled root in 1.25s
2024.01.23 16:02:48 INFO  skipping build import with status 'Installed'
2024.01.23 16:02:47 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:02:47 INFO  time: compiled root in 0.12s
2024.01.23 16:02:51 INFO  skipping build import with status 'Installed'
2024.01.23 16:03:06 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:03:06 INFO  time: compiled root in 0.12s
2024.01.23 16:03:09 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:03:09 INFO  time: compiled root in 0.11s
2024.01.23 16:03:18 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:03:18 INFO  time: compiled root in 71ms
2024.01.23 16:03:29 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:03:29 INFO  time: compiled root in 98ms
2024.01.23 16:03:35 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:03:35 INFO  time: compiled root in 0.11s
2024.01.23 16:06:09 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:06:09 INFO  time: compiled root in 72ms
2024.01.23 16:06:12 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:06:12 INFO  time: compiled root in 0.11s
2024.01.23 16:06:19 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:06:19 INFO  time: compiled root in 82ms
ene 23, 2024 4:06:19 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.01.23 16:06:19 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:06:19 INFO  time: compiled root in 84ms
2024.01.23 16:06:23 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:06:23 INFO  time: compiled root in 84ms
2024.01.23 16:06:25 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:06:25 INFO  time: compiled root in 90ms
2024.01.23 16:06:37 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:06:37 INFO  time: compiled root in 72ms
2024.01.23 16:06:44 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:06:44 INFO  time: compiled root in 0.13s
ene 23, 2024 4:06:50 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8638
2024.01.23 16:07:00 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:07:00 INFO  time: compiled root in 0.11s
2024.01.23 16:07:01 INFO  compiling root (3 scala sources and 38 java sources)
2024.01.23 16:07:03 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:07:03 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:07:03 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:07:03 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:07:03 INFO  time: compiled root in 2.35s
2024.01.23 16:07:03 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:07:05 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:07:20 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:07:29 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:07:49 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:14 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:15 WARN  Using indexes to guess the definition of Action
2024.01.23 16:08:16 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:17 INFO  compiling root (1 scala source)
2024.01.23 16:08:17 INFO  time: compiled root in 39ms
2024.01.23 16:08:16 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:24 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:08:56 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:09:16 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:09:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:09:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:09:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:09:17 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:09:17 INFO  compiling root (1 scala source)
2024.01.23 16:09:17 INFO  time: compiled root in 44ms
2024.01.23 16:09:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:09:27 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:09:29 INFO  skipping build import with status 'Installed'
ene 23, 2024 4:09:36 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-23\r_compiler-error_(scala-projects-build)_16-09-36-428.md
2024.01.23 16:09:38 INFO  running 'C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals2515725272591048779\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.01.23 16:09:39 INFO  [info] welcome to sbt 1.9.7 (Oracle Corporation Java 21.0.1)
2024.01.23 16:09:39 INFO  [info] loading settings for project scala-projects-build-build from metals.sbt ...
2024.01.23 16:09:40 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\project
2024.01.23 16:09:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:09:40 INFO  [info] loading settings for project scala-projects-build from metals.sbt ...
2024.01.23 16:09:40 INFO  [info] loading project definition from C:\URV\Progra\RepositorioGitHub\Scala-Projects\project
2024.01.23 16:09:42 INFO  compiling root (1 scala source)
2024.01.23 16:09:42 INFO  time: compiled root in 38ms
2024.01.23 16:09:42 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:09:43 INFO  [success] Generated .bloop\scala-projects-build.json
2024.01.23 16:09:43 INFO  [success] Total time: 2 s, completed 23 ene 2024, 16:09:43
2024.01.23 16:09:44 ERROR C:\URV\Progra\RepositorioGitHub\Scala-Projects\build.sbt:9: error: not found: value munit
2024.01.23 16:09:44 ERROR     libraryDependencies += munit % Test,
2024.01.23 16:09:44 ERROR                            ^
2024.01.23 16:09:44 ERROR sbt.compiler.EvalException: Type error in expression
2024.01.23 16:09:44 INFO  [error] sbt.compiler.EvalException: Type error in expression
2024.01.23 16:09:44 INFO  [error] Use 'last' for the full log.
2024.01.23 16:09:44 INFO  [warn] Project loading failed: (r)etry, (q)uit, (l)ast, or (i)gnore? (default: r)
2024.01.23 16:09:44 INFO  time: ran 'sbt bloopInstall' in 6.55s
2024.01.23 16:09:44 ERROR sbt command failed: C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals2515725272591048779\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.01.23 16:09:44 INFO  Disconnecting from Bloop session...
2024.01.23 16:09:44 INFO  Shut down connection with build server.
2024.01.23 16:09:44 INFO  Shut down connection with build server.
2024.01.23 16:09:44 INFO  Attempting to connect to the build server...
2024.01.23 16:09:44 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:09:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:09:44 INFO  Attempting to connect to the build server...
2024.01.23 16:09:44 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:09:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:09:44 INFO  time: Connected to build server in 64ms
2024.01.23 16:09:44 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 16:09:46 INFO  time: indexed workspace in 1.49s
2024.01.23 16:09:46 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala copy\MacroWorkSpace.scala
2024.01.23 16:09:56 INFO  compiling root (1 scala source)
2024.01.23 16:09:56 INFO  time: compiled root in 50ms
2024.01.23 16:09:56 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:10:03 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:10:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:10:31 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:10:36 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:10:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:10:38 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:10:38 WARN  Using indexes to guess the definition of Controller
2024.01.23 16:10:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:10:53 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:03 INFO  compiling root (1 scala source and 1 java source)
2024.01.23 16:11:03 INFO  time: compiled root in 62ms
2024.01.23 16:11:03 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:05 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:05 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:07 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:08 INFO  compiling root (1 scala source and 1 java source)
2024.01.23 16:11:08 INFO  time: compiled root in 37ms
2024.01.23 16:11:08 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:11 INFO  compiling root (1 scala source and 1 java source)
2024.01.23 16:11:11 INFO  time: compiled root in 81ms
2024.01.23 16:11:19 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:21 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:22 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:23 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:23 INFO  compiling root (1 scala source and 1 java source)
2024.01.23 16:11:23 INFO  time: compiled root in 40ms
2024.01.23 16:11:28 INFO  compiling root (1 scala source)
2024.01.23 16:11:28 INFO  time: compiled root in 41ms
2024.01.23 16:11:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:29 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:11:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:14:13 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:14:16 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:20:59 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:02 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:04 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:04 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:06 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:06 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:08 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:08 INFO  compiling root (1 scala source)
2024.01.23 16:21:08 INFO  time: compiled root in 38ms
2024.01.23 16:21:08 INFO  compiling root (1 scala source)
2024.01.23 16:21:08 INFO  time: compiled root in 18ms
2024.01.23 16:21:09 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:14 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:14 INFO  compiling root (1 scala source)
2024.01.23 16:21:14 INFO  time: compiled root in 39ms
2024.01.23 16:21:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:16 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:16 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:16 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:16 WARN  Using indexes to guess the definition of main
2024.01.23 16:21:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:21:19 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:22:59 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:23:01 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:23:01 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:23:01 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:23:01 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:23:01 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.23 16:23:02 INFO  compiling root (1 scala source)
2024.01.23 16:23:02 INFO  time: compiled root in 0.26s
2024.01.23 16:23:07 INFO  compiling root (1 scala source)
2024.01.23 16:23:07 INFO  time: compiled root in 0.48s
2024.01.23 16:23:08 WARN  Using indexes to guess the definition of main
Exception in thread "pool-29-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 16:23:10 INFO  compiling root (1 scala source)
2024.01.23 16:23:10 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\ScalaFunctions.scala
2024.01.23 16:23:10 INFO  time: compiled root in 0.64s
ene 23, 2024 4:23:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9051
2024.01.23 16:23:14 INFO  compiling root (1 scala source)
2024.01.23 16:23:14 INFO  time: compiled root in 0.41s
2024.01.23 16:23:15 INFO  compiling root-test (1 scala source)
2024.01.23 16:23:15 INFO  time: compiled root-test in 0.14s
2024.01.23 16:23:17 INFO  compiling root-test (1 scala source)
2024.01.23 16:23:17 INFO  time: compiled root-test in 0.1s
2024.01.23 16:23:18 WARN  Using indexes to guess the definition of ScalaFunctions
2024.01.23 16:23:18 WARN  Using indexes to guess the definition of ScalaFunctions
2024.01.23 16:23:18 WARN  Using indexes to guess the definition of ScalaFunctions
2024.01.23 16:23:18 INFO  compiling root-test (1 scala source)
2024.01.23 16:23:18 INFO  time: compiled root-test in 87ms
2024.01.23 16:23:22 WARN  Using indexes to guess the definition of main
2024.01.23 16:23:22 WARN  Using indexes to guess the definition of main
2024.01.23 16:23:22 WARN  Using indexes to guess the definition of main
2024.01.23 16:23:23 INFO  compiling root-test (1 scala source)
2024.01.23 16:23:23 WARN  Using indexes to guess the definition of ScalaFunctions
2024.01.23 16:23:23 INFO  time: compiled root-test in 0.11s
2024.01.23 16:23:24 WARN  Using indexes to guess the definition of ScalaFunctions
2024.01.23 16:23:24 INFO  compiling root-test (1 scala source)
2024.01.23 16:23:24 INFO  time: compiled root-test in 0.49s
2024.01.23 16:23:25 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:25 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:25 INFO  compiling root-test (1 scala source)
2024.01.23 16:23:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:25 INFO  time: compiled root-test in 0.1s
2024.01.23 16:23:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:27 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:27 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:27 WARN  Using indexes to guess the definition of FunSuite
2024.01.23 16:23:27 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:27 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:27 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:27 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.23 16:23:29 INFO  compiling root-test (1 scala source)
2024.01.23 16:23:29 INFO  time: compiled root-test in 0.48s
2024.01.23 16:23:53 INFO  compiling root (1 scala source)
2024.01.23 16:23:53 INFO  time: compiled root in 42ms
2024.01.23 16:24:05 INFO  compiling root (1 scala source)
2024.01.23 16:24:05 INFO  time: compiled root in 40ms
2024.01.23 16:24:05 INFO  compiling root (1 scala source)
2024.01.23 16:24:05 INFO  time: compiled root in 29ms
2024.01.23 16:24:07 WARN  Using indexes to guess the definition of main
2024.01.23 16:24:07 INFO  compiling root (1 scala source)
2024.01.23 16:24:07 INFO  time: compiled root in 21ms
2024.01.23 16:24:09 WARN  Using indexes to guess the definition of main
Exception in thread "pool-29-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 16:24:09 WARN  Using indexes to guess the definition of scalaFunctions
2024.01.23 16:24:10 INFO  compiling root (1 scala source)
2024.01.23 16:24:10 INFO  time: compiled root in 39ms
2024.01.23 16:24:10 INFO  compiling root (1 scala source)
2024.01.23 16:24:10 INFO  time: compiled root in 28ms
2024.01.23 16:24:12 INFO  compiling root (1 scala source)
2024.01.23 16:24:12 INFO  time: compiled root in 77ms
2024.01.23 16:24:14 INFO  compiling root (1 scala source and 1 java source)
2024.01.23 16:24:14 INFO  time: compiled root in 52ms
2024.01.23 16:24:18 INFO  compiling root (1 scala source)
2024.01.23 16:24:18 INFO  time: compiled root in 54ms
ene 23, 2024 4:24:21 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9325
2024.01.23 16:24:21 INFO  compiling root (1 scala source)
2024.01.23 16:24:21 INFO  time: compiled root in 71ms
2024.01.23 16:24:21 INFO  compiling root (1 scala source)
2024.01.23 16:24:21 INFO  time: compiled root in 53ms
2024.01.23 16:24:21 INFO  compiling root (1 scala source)
2024.01.23 16:24:21 INFO  time: compiled root in 31ms
2024.01.23 16:24:24 INFO  compiling root (1 scala source)
2024.01.23 16:24:24 INFO  time: compiled root in 69ms
2024.01.23 16:24:26 INFO  compiling root (1 scala source and 1 java source)
2024.01.23 16:24:26 INFO  time: compiled root in 47ms
2024.01.23 16:24:26 INFO  compiling root (1 scala source)
2024.01.23 16:24:26 INFO  time: compiled root in 36ms
2024.01.23 16:24:28 INFO  compiling root (1 scala source)
2024.01.23 16:24:28 INFO  time: compiled root in 32ms
2024.01.23 16:24:35 INFO  compiling root (1 scala source)
2024.01.23 16:24:35 INFO  time: compiled root in 47ms
2024.01.23 16:24:36 INFO  compiling root (1 scala source)
2024.01.23 16:24:36 INFO  time: compiled root in 0.11s
2024.01.23 16:24:40 INFO  compiling root (1 scala source)
2024.01.23 16:24:40 INFO  time: compiled root in 44ms
2024.01.23 16:24:43 INFO  compiling root (1 scala source)
2024.01.23 16:24:43 INFO  time: compiled root in 0.26s
ene 23, 2024 4:25:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9436
2024.01.23 16:25:39 INFO  compiling root (1 java source)
2024.01.23 16:25:40 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:25:40 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:40 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:40 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:25:40 WARN  javac exited with exit code 1
2024.01.23 16:25:40 INFO  time: compiled root in 1.26s
2024.01.23 16:25:45 INFO  compiling root (2 java sources)
2024.01.23 16:25:46 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:25:46 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:46 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:46 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:25:46 WARN  javac exited with exit code 1
2024.01.23 16:25:46 INFO  time: compiled root in 1.37s
2024.01.23 16:25:46 INFO  compiling root (2 java sources)
ene 23, 2024 4:25:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9487
2024.01.23 16:25:48 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:25:48 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:48 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:48 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
ene 23, 2024 4:25:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9494
2024.01.23 16:25:48 WARN  javac exited with exit code 1
2024.01.23 16:25:48 INFO  time: compiled root in 1.35s
2024.01.23 16:25:51 INFO  compiling root (3 java sources)
2024.01.23 16:25:52 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:25:52 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:52 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:52 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:25:52 WARN  javac exited with exit code 1
2024.01.23 16:25:52 INFO  time: compiled root in 1.29s
2024.01.23 16:25:52 INFO  compiling root (3 java sources)
2024.01.23 16:25:53 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:25:53 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:53 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:53 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:25:53 WARN  javac exited with exit code 1
2024.01.23 16:25:53 INFO  time: compiled root in 1.31s
2024.01.23 16:25:53 INFO  compiling root (3 java sources)
2024.01.23 16:25:55 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:25:55 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:55 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:55 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:25:55 WARN  javac exited with exit code 1
2024.01.23 16:25:55 INFO  time: compiled root in 1.37s
2024.01.23 16:25:55 INFO  compiling root (4 java sources)
2024.01.23 16:25:56 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:25:56 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:56 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:56 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:25:56 WARN  javac exited with exit code 1
2024.01.23 16:25:56 INFO  time: compiled root in 1.28s
2024.01.23 16:25:56 INFO  compiling root (4 java sources)
2024.01.23 16:25:57 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:25:57 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:57 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:57 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:25:57 WARN  javac exited with exit code 1
2024.01.23 16:25:57 INFO  time: compiled root in 1.24s
2024.01.23 16:25:57 INFO  compiling root (4 java sources)
2024.01.23 16:25:59 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:25:59 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:59 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:25:59 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:25:59 WARN  javac exited with exit code 1
2024.01.23 16:25:59 INFO  time: compiled root in 1.23s
ene 23, 2024 4:26:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9558
2024.01.23 16:26:00 INFO  compiling root (5 java sources)
2024.01.23 16:26:01 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:26:01 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:01 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:01 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
ene 23, 2024 4:26:01 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9566
2024.01.23 16:26:01 WARN  javac exited with exit code 1
2024.01.23 16:26:01 INFO  time: compiled root in 1.29s
2024.01.23 16:26:02 WARN  Using indexes to guess the definition of Controller
ene 23, 2024 4:26:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9581
ene 23, 2024 4:26:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9585
2024.01.23 16:26:04 WARN  Using indexes to guess the definition of Controller
ene 23, 2024 4:26:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9602
ene 23, 2024 4:26:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9615
2024.01.23 16:26:09 WARN  Using indexes to guess the definition of Action
2024.01.23 16:26:12 WARN  Using indexes to guess the definition of Action
ene 23, 2024 4:26:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9631
ene 23, 2024 4:26:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9632
2024.01.23 16:26:12 INFO  compiling root (5 java sources)
ene 23, 2024 4:26:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9635
2024.01.23 16:26:13 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:26:13 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:13 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:13 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:26:13 WARN  javac exited with exit code 1
2024.01.23 16:26:13 INFO  time: compiled root in 1.27s
ene 23, 2024 4:26:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9645
ene 23, 2024 4:26:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9646
ene 23, 2024 4:26:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9647
ene 23, 2024 4:26:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9655
2024.01.23 16:26:14 INFO  compiling root (5 java sources)
2024.01.23 16:26:15 WARN  Using indexes to guess the definition of Controller
2024.01.23 16:26:16 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:26:16 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:16 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:16 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:26:16 WARN  javac exited with exit code 1
2024.01.23 16:26:16 INFO  time: compiled root in 1.21s
ene 23, 2024 4:26:17 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9667
2024.01.23 16:26:19 INFO  compiling root (5 java sources)
2024.01.23 16:26:20 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:26:20 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:20 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:20 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:26:20 WARN  javac exited with exit code 1
2024.01.23 16:26:20 INFO  time: compiled root in 1.22s
ene 23, 2024 4:26:21 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9681
ene 23, 2024 4:26:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9683
ene 23, 2024 4:26:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9686
ene 23, 2024 4:26:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9689
ene 23, 2024 4:26:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9687
ene 23, 2024 4:26:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9690
2024.01.23 16:26:22 INFO  compiling root (6 java sources)
2024.01.23 16:26:23 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:26:23 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:23 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:23 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:26:23 WARN  javac exited with exit code 1
2024.01.23 16:26:23 INFO  time: compiled root in 1.29s
ene 23, 2024 4:26:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9733
ene 23, 2024 4:26:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9734
ene 23, 2024 4:26:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9735
ene 23, 2024 4:26:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9738
ene 23, 2024 4:26:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9739
ene 23, 2024 4:26:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9745
ene 23, 2024 4:26:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9746
ene 23, 2024 4:26:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9740
ene 23, 2024 4:26:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9747
ene 23, 2024 4:26:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9751
ene 23, 2024 4:26:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9759
ene 23, 2024 4:26:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9758
ene 23, 2024 4:26:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9760
ene 23, 2024 4:26:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9764
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9762
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9766
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9765
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9770
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9769
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9773
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9771
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9775
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9779
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9772
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9777
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9781
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9786
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9782
ene 23, 2024 4:26:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9788
ene 23, 2024 4:26:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9792
ene 23, 2024 4:26:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9793
ene 23, 2024 4:26:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9799
ene 23, 2024 4:26:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9804
ene 23, 2024 4:26:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9801
2024.01.23 16:26:41 INFO  compiling root (6 java sources)
2024.01.23 16:26:42 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:26:42 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:42 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:42 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:26:42 WARN  javac exited with exit code 1
2024.01.23 16:26:42 INFO  time: compiled root in 1.29s
ene 23, 2024 4:26:46 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9847
2024.01.23 16:26:46 INFO  compiling root (6 java sources)
ene 23, 2024 4:26:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9850
ene 23, 2024 4:26:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9855
2024.01.23 16:26:48 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:26:48 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:48 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:48 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:26:48 WARN  javac exited with exit code 1
2024.01.23 16:26:48 INFO  time: compiled root in 1.51s
2024.01.23 16:26:48 INFO  compiling root (6 java sources)
2024.01.23 16:26:49 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:26:49 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:49 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:49 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:26:49 WARN  javac exited with exit code 1
2024.01.23 16:26:49 INFO  time: compiled root in 1.4s
2024.01.23 16:26:49 INFO  compiling root (6 java sources)
ene 23, 2024 4:26:50 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9870
2024.01.23 16:26:51 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:26:51 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:51 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:51 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:26:51 WARN  javac exited with exit code 1
2024.01.23 16:26:51 INFO  time: compiled root in 1.32s
2024.01.23 16:26:51 INFO  compiling root (6 java sources)
2024.01.23 16:26:52 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:26:52 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:52 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:26:52 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:26:52 WARN  javac exited with exit code 1
2024.01.23 16:26:52 INFO  time: compiled root in 1.25s
ene 23, 2024 4:26:58 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9903
2024.01.23 16:26:59 INFO  compiling root (6 java sources)
ene 23, 2024 4:27:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9912
ene 23, 2024 4:27:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9913
2024.01.23 16:27:01 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:27:01 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:01 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:01 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:27:01 WARN  Using indexes to guess the definition of Action
2024.01.23 16:27:01 WARN  javac exited with exit code 1
2024.01.23 16:27:01 INFO  time: compiled root in 1.66s
ene 23, 2024 4:27:02 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9927
2024.01.23 16:27:02 INFO  compiling root (7 java sources)
2024.01.23 16:27:04 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:27:04 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:04 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:04 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:27:04 WARN  javac exited with exit code 1
2024.01.23 16:27:04 INFO  time: compiled root in 1.39s
2024.01.23 16:27:04 INFO  compiling root (7 java sources)
2024.01.23 16:27:05 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:27:05 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:05 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:05 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:27:05 WARN  javac exited with exit code 1
2024.01.23 16:27:05 INFO  time: compiled root in 1.37s
ene 23, 2024 4:27:05 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9960
ene 23, 2024 4:27:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9967
ene 23, 2024 4:27:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9966
ene 23, 2024 4:27:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9986
2024.01.23 16:27:10 INFO  compiling root (8 java sources)
2024.01.23 16:27:11 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:27:11 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:11 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:11 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:27:11 WARN  javac exited with exit code 1
2024.01.23 16:27:11 INFO  time: compiled root in 1.34s
ene 23, 2024 4:27:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10019
ene 23, 2024 4:27:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10021
2024.01.23 16:27:14 INFO  compiling root (8 java sources)
2024.01.23 16:27:15 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:27:15 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:15 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:15 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:27:15 WARN  javac exited with exit code 1
2024.01.23 16:27:15 INFO  time: compiled root in 1.44s
2024.01.23 16:27:15 INFO  compiling root (8 java sources)
2024.01.23 16:27:16 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 17m 31.835s)
2024.01.23 16:27:16 INFO  compiling root (8 java sources)
2024.01.23 16:27:16 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:27:16 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:16 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:16 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:27:16 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:27:16 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:16 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:16 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:27:16 WARN  javac exited with exit code 1
2024.01.23 16:27:16 WARN  javac exited with exit code 1
2024.01.23 16:27:16 INFO  time: compiled root in 0.94s
2024.01.23 16:27:16 INFO  compiling root (8 java sources)
2024.01.23 16:27:18 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:27:18 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:18 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:18 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:27:18 INFO  Shutting down server
2024.01.23 16:27:18 INFO  shutting down Metals
2024.01.23 16:27:19 INFO  Shut down connection with build server.
2024.01.23 16:27:18 WARN  javac exited with exit code 1
2024.01.23 16:27:18 INFO  time: compiled root in 1.46s
2024.01.23 16:27:19 INFO  Shut down connection with build server.
2024.01.23 16:27:18 INFO  Exiting server
2024.01.23 16:27:50 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.23 16:27:51 INFO  Attempting to connect to the build server...
2024.01.23 16:27:51 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:27:51 INFO  skipping build import with status 'Failed'
2024.01.23 16:27:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:27:51 INFO  Attempting to connect to the build server...
2024.01.23 16:27:51 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:27:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:27:51 INFO  time: Connected to build server in 0.53s
2024.01.23 16:27:51 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 16:27:52 INFO  time: Imported build in 0.1s
2024.01.23 16:27:56 INFO  time: indexed workspace in 4.22s
2024.01.23 16:27:56 INFO  compiling root (3 scala sources and 2 java sources)
2024.01.23 16:27:58 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:27:58 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:58 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:27:58 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:27:58 WARN  javac exited with exit code 1
2024.01.23 16:27:58 INFO  time: compiled root in 2.19s
2024.01.23 16:27:58 INFO  compiling root (3 scala sources and 2 java sources)
2024.01.23 16:28:00 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:28:00 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:00 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:00 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:28:00 WARN  javac exited with exit code 1
2024.01.23 16:28:00 INFO  time: compiled root in 1.92s
2024.01.23 16:28:00 INFO  compiling root (3 scala sources and 2 java sources)
2024.01.23 16:28:02 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:28:02 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:02 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:02 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:28:02 WARN  javac exited with exit code 1
2024.01.23 16:28:02 INFO  time: compiled root in 1.56s
2024.01.23 16:28:02 INFO  compiling root (3 scala sources and 2 java sources)
2024.01.23 16:28:04 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:28:04 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:04 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:04 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:28:04 WARN  javac exited with exit code 1
2024.01.23 16:28:04 INFO  time: compiled root in 1.85s
2024.01.23 16:28:04 INFO  compiling root (3 scala sources and 2 java sources)
2024.01.23 16:28:05 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:28:05 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:05 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:05 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:28:05 WARN  javac exited with exit code 1
2024.01.23 16:28:05 INFO  time: compiled root in 1.56s
2024.01.23 16:28:09 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\policy\BigGroup.java
2024.01.23 16:28:17 INFO  compiling root (3 scala sources and 2 java sources)
ene 23, 2024 4:28:19 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 74
ene 23, 2024 4:28:19 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 76
2024.01.23 16:28:19 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:28:19 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:19 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:19 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:28:19 WARN  javac exited with exit code 1
2024.01.23 16:28:19 INFO  time: compiled root in 1.79s
2024.01.23 16:28:25 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\interfaces\DistributionPolicy.java
2024.01.23 16:28:28 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\interfaces\DistributionPolicy.java
2024.01.23 16:28:29 INFO  compiling root (3 scala sources and 2 java sources)
2024.01.23 16:28:30 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\interfaces\DistributionPolicy.java
2024.01.23 16:28:31 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:28:31 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:31 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:31 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:28:31 WARN  javac exited with exit code 1
2024.01.23 16:28:31 INFO  time: compiled root in 1.95s
2024.01.23 16:28:31 INFO  compiling root (3 scala sources and 2 java sources)
2024.01.23 16:28:31 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\interfaces\DistributionPolicy.java
2024.01.23 16:28:33 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:28:33 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:33 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:33 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:28:33 WARN  javac exited with exit code 1
2024.01.23 16:28:33 INFO  time: compiled root in 1.63s
2024.01.23 16:28:35 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\interfaces\DistributionPolicy.java
2024.01.23 16:28:35 INFO  compiling root (3 scala sources and 2 java sources)
2024.01.23 16:28:35 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\interfaces\DistributionPolicy.java
2024.01.23 16:28:36 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.23 16:28:36 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:36 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.23 16:28:36 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.23 16:28:36 WARN  javac exited with exit code 1
2024.01.23 16:28:36 INFO  time: compiled root in 1.49s
2024.01.23 16:28:53 INFO  Shutting down server
2024.01.23 16:28:53 INFO  shutting down Metals
2024.01.23 16:28:54 INFO  Shut down connection with build server.
2024.01.23 16:28:54 INFO  Shut down connection with build server.
2024.01.23 16:28:53 INFO  Exiting server
2024.01.23 16:29:49 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.23 16:29:50 INFO  Attempting to connect to the build server...
2024.01.23 16:29:50 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:29:50 INFO  skipping build import with status 'Failed'
2024.01.23 16:29:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:29:50 INFO  Attempting to connect to the build server...
2024.01.23 16:29:50 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:29:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:29:50 INFO  time: Connected to build server in 0.29s
2024.01.23 16:29:50 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 16:29:53 INFO  time: indexed workspace in 3.12s
2024.01.23 16:29:57 INFO  compiling root (3 scala sources)
2024.01.23 16:29:57 INFO  time: compiled root in 0.86s
2024.01.23 16:30:26 INFO  time: code lens generation in 1.51s
2024.01.23 16:30:58 INFO  skipping build import with status 'Failed'
ene 23, 2024 4:32:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 62
Exception in thread "pool-6-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 16:32:15 INFO  running 'C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals6427674173977940358\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.01.23 16:32:16 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load3241995290504755784_lock, error 5
2024.01.23 16:32:16 INFO  sbt thinks that server is already booting because of this exception:
2024.01.23 16:32:16 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.01.23 16:32:16 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.01.23 16:32:16 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:152)
2024.01.23 16:32:16 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:78)
2024.01.23 16:32:16 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:78)
2024.01.23 16:32:16 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:86)
2024.01.23 16:32:16 ERROR 	at sbt.xMain$.run(Main.scala:123)
2024.01.23 16:32:16 ERROR 	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
2024.01.23 16:32:16 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
2024.01.23 16:32:16 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.01.23 16:32:16 ERROR 	at sbt.xMain.run(Main.scala:47)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.01.23 16:32:16 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.01.23 16:32:16 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load3241995290504755784_lock, error 5
2024.01.23 16:32:16 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.01.23 16:32:16 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.01.23 16:32:16 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.01.23 16:32:16 ERROR 	... 21 more
2024.01.23 16:32:16 INFO  time: ran 'sbt bloopInstall' in 1s
2024.01.23 16:32:16 ERROR sbt command failed: C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals6427674173977940358\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.01.23 16:32:16 INFO  Disconnecting from Bloop session...
2024.01.23 16:32:16 INFO  Shut down connection with build server.
2024.01.23 16:32:16 INFO  Shut down connection with build server.
2024.01.23 16:32:16 INFO  Attempting to connect to the build server...
2024.01.23 16:32:16 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:32:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:32:16 INFO  Attempting to connect to the build server...
2024.01.23 16:32:16 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:32:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:32:16 INFO  time: Connected to build server in 68ms
2024.01.23 16:32:16 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 16:32:18 INFO  time: indexed workspace in 1.62s
2024.01.23 16:32:19 INFO  skipping build import with status 'Failed'
2024.01.23 16:32:20 INFO  time: code lens generation in 1.06s
2024.01.23 16:33:33 INFO  skipping build import with status 'Dismissed'
2024.01.23 16:33:36 INFO  skipping build import with status 'Dismissed'
2024.01.23 16:33:42 INFO  skipping build import with status 'Dismissed'
2024.01.23 16:33:44 INFO  running 'C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals9510578380321317474\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.01.23 16:33:45 INFO  sbt thinks that server is already booting because of this exception:
2024.01.23 16:33:45 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load3241995290504755784_lock, error 5
2024.01.23 16:33:45 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.01.23 16:33:45 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.01.23 16:33:45 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:152)
2024.01.23 16:33:45 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:78)
2024.01.23 16:33:45 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:78)
2024.01.23 16:33:45 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:86)
2024.01.23 16:33:45 ERROR 	at sbt.xMain$.run(Main.scala:123)
2024.01.23 16:33:45 ERROR 	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
2024.01.23 16:33:45 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
2024.01.23 16:33:45 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.01.23 16:33:45 ERROR 	at sbt.xMain.run(Main.scala:47)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.01.23 16:33:45 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.01.23 16:33:45 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load3241995290504755784_lock, error 5
2024.01.23 16:33:45 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.01.23 16:33:45 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.01.23 16:33:45 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.01.23 16:33:45 ERROR 	... 21 more
2024.01.23 16:33:45 INFO  time: ran 'sbt bloopInstall' in 1.03s
2024.01.23 16:33:45 ERROR sbt command failed: C:\Program Files\Java\jdk-21\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\adria\AppData\Local\Temp\metals9510578380321317474\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.01.23 16:33:45 INFO  Disconnecting from Bloop session...
2024.01.23 16:33:45 INFO  Shut down connection with build server.
2024.01.23 16:33:45 INFO  Shut down connection with build server.
2024.01.23 16:33:45 INFO  Attempting to connect to the build server...
2024.01.23 16:33:45 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:33:45 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:33:45 INFO  Attempting to connect to the build server...
2024.01.23 16:33:45 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.23 16:33:45 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.23 16:33:45 INFO  time: Connected to build server in 67ms
2024.01.23 16:33:45 INFO  Connected to Build server: Bloop v1.5.13
2024.01.23 16:33:46 INFO  time: indexed workspace in 1.5s
2024.01.23 16:35:23 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\Controller.java
ene 23, 2024 4:35:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 166
ene 23, 2024 4:35:36 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
Exception in thread "pool-14-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 16:37:37 INFO  compiling root (1 scala source)
2024.01.23 16:37:37 INFO  time: compiled root in 73ms
2024.01.23 16:37:45 INFO  compiling root (1 scala source)
2024.01.23 16:37:45 INFO  time: compiled root in 42ms
2024.01.23 16:37:45 INFO  compiling root (1 scala source)
2024.01.23 16:37:45 INFO  time: compiled root in 27ms
2024.01.23 16:37:49 INFO  compiling root (1 scala source)
2024.01.23 16:37:49 INFO  time: compiled root in 47ms
2024.01.23 16:37:57 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\Controller.java
2024.01.23 16:38:04 WARN  Using indexes to guess the definition of main
2024.01.23 16:38:04 WARN  Using indexes to guess the definition of ScalaFunctions
2024.01.23 16:38:04 INFO  compiling root (1 scala source)
2024.01.23 16:38:04 INFO  time: compiled root in 44ms
2024.01.23 16:38:05 WARN  Using indexes to guess the definition of ScalaFunctions
2024.01.23 16:38:04 INFO  compiling root (1 scala source)
2024.01.23 16:38:04 INFO  time: compiled root in 24ms
2024.01.23 16:38:27 INFO  compiling root (1 scala source)
2024.01.23 16:38:27 INFO  time: compiled root in 40ms
2024.01.23 16:38:30 INFO  compiling root (1 scala source)
2024.01.23 16:38:30 INFO  time: compiled root in 38ms
2024.01.23 16:38:34 INFO  compiling root (1 scala source)
2024.01.23 16:38:34 INFO  time: compiled root in 38ms
2024.01.23 16:38:40 INFO  compiling root (1 scala source)
2024.01.23 16:38:40 INFO  time: compiled root in 39ms
2024.01.23 16:38:43 INFO  compiling root (1 scala source)
2024.01.23 16:38:43 INFO  time: compiled root in 40ms
2024.01.23 16:38:45 INFO  compiling root (1 scala source)
2024.01.23 16:38:45 INFO  time: compiled root in 39ms
2024.01.23 16:38:47 WARN  Using indexes to guess the definition of Controller
2024.01.23 16:38:48 INFO  compiling root (1 scala source)
2024.01.23 16:38:48 INFO  time: compiled root in 38ms
2024.01.23 16:39:15 INFO  compiling root (1 scala source)
2024.01.23 16:39:15 INFO  time: compiled root in 49ms
2024.01.23 16:39:18 INFO  compiling root (1 scala source)
2024.01.23 16:39:18 INFO  time: compiled root in 55ms
2024.01.23 16:39:18 INFO  compiling root (1 scala source)
2024.01.23 16:39:18 INFO  time: compiled root in 30ms
2024.01.23 16:39:20 INFO  compiling root (1 scala source)
2024.01.23 16:39:20 INFO  time: compiled root in 48ms
2024.01.23 16:39:30 INFO  compiling root (1 scala source)
2024.01.23 16:39:30 INFO  time: compiled root in 45ms
2024.01.23 16:39:35 INFO  compiling root (1 scala source)
2024.01.23 16:39:35 INFO  time: compiled root in 47ms
2024.01.23 16:40:04 INFO  compiling root (1 scala source)
2024.01.23 16:40:04 INFO  time: compiled root in 48ms
2024.01.23 16:40:10 INFO  compiling root (1 scala source)
2024.01.23 16:40:10 INFO  time: compiled root in 31ms
2024.01.23 16:40:13 INFO  compiling root (1 scala source)
2024.01.23 16:40:13 INFO  time: compiled root in 48ms
2024.01.23 16:40:13 INFO  compiling root (1 scala source)
2024.01.23 16:40:13 INFO  time: compiled root in 15ms
2024.01.23 16:40:16 INFO  compiling root (1 scala source)
2024.01.23 16:40:16 INFO  time: compiled root in 32ms
2024.01.23 16:40:20 INFO  compiling root (1 scala source)
2024.01.23 16:40:20 INFO  time: compiled root in 50ms
2024.01.23 16:40:22 INFO  compiling root (1 scala source)
2024.01.23 16:40:22 INFO  time: compiled root in 33ms
2024.01.23 16:40:27 INFO  compiling root (1 scala source)
2024.01.23 16:40:27 INFO  time: compiled root in 46ms
2024.01.23 16:40:39 INFO  compiling root (1 scala source)
2024.01.23 16:40:39 INFO  time: compiled root in 48ms
2024.01.23 16:40:42 INFO  compiling root (1 scala source)
2024.01.23 16:40:42 INFO  time: compiled root in 32ms
2024.01.23 16:40:50 INFO  compiling root (1 scala source)
2024.01.23 16:40:50 INFO  time: compiled root in 34ms
2024.01.23 16:40:52 INFO  compiling root (1 scala source)
2024.01.23 16:40:52 INFO  time: compiled root in 47ms
2024.01.23 16:40:54 INFO  compiling root (1 scala source)
2024.01.23 16:40:54 INFO  time: compiled root in 48ms
2024.01.23 16:40:55 INFO  compiling root (1 scala source)
2024.01.23 16:40:55 INFO  time: compiled root in 31ms
2024.01.23 16:41:02 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\Action.java
2024.01.23 16:41:04 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\policy\BigGroup.java
2024.01.23 16:41:06 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\Action.java
2024.01.23 16:41:11 INFO  compiling root (1 scala source)
2024.01.23 16:41:11 INFO  time: compiled root in 51ms
2024.01.23 16:42:14 INFO  compiling root (1 scala source)
2024.01.23 16:42:14 INFO  time: compiled root in 48ms
2024.01.23 16:42:21 INFO  compiling root (1 scala source)
2024.01.23 16:42:21 INFO  time: compiled root in 48ms
Exception in thread "pool-14-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.23 16:43:22 INFO  compiling root (1 scala source)
2024.01.23 16:43:22 INFO  time: compiled root in 44ms
ene 23, 2024 4:44:53 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 755
2024.01.23 16:45:01 INFO  compiling root (1 scala source)
2024.01.23 16:45:01 INFO  compiling root (1 scala source)
2024.01.23 16:45:01 INFO  time: compiled root in 0.31s
2024.01.23 16:45:08 INFO  compiling root (1 scala source)
2024.01.23 16:45:08 INFO  time: compiled root in 0.28s
2024.01.23 16:48:35 INFO  Shutting down server
2024.01.23 16:48:35 INFO  shutting down Metals
2024.01.23 16:48:35 INFO  Shut down connection with build server.
2024.01.23 16:48:35 INFO  Shut down connection with build server.
2024.01.23 16:48:35 INFO  Exiting server
2024.01.24 11:41:41 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.24 11:41:42 INFO  Attempting to connect to the build server...
2024.01.24 11:41:42 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.24 11:41:42 INFO  skipping build import with status 'Failed'
2024.01.24 11:41:46 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.24 11:41:46 INFO  Attempting to connect to the build server...
2024.01.24 11:41:46 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.24 11:41:46 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.24 11:41:46 INFO  time: Connected to build server in 4.58s
2024.01.24 11:41:46 INFO  Connected to Build server: Bloop v1.5.13
2024.01.24 11:41:47 INFO  time: Imported build in 0.13s
2024.01.24 11:41:50 INFO  time: indexed workspace in 3.07s
ene 24, 2024 11:44:31 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21
ene 24, 2024 11:44:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 36
2024.01.24 11:44:34 INFO  compiling root (1 scala source)
2024.01.24 11:44:36 INFO  time: compiled root in 2.03s
2024.01.24 11:45:43 INFO  compiling root (1 scala source)
Exception in thread "pool-4-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 11:45:43 INFO  time: compiled root in 0.2s
2024.01.24 11:46:09 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\Controller.java
ene 24, 2024 11:46:10 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 82
ene 24, 2024 11:46:10 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 84
ene 24, 2024 11:46:10 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 85
ene 24, 2024 11:46:19 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 100
ene 24, 2024 11:46:19 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 101
2024.01.24 11:47:01 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:01 INFO  time: compiled root in 0.49s
2024.01.24 11:47:03 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:03 INFO  time: compiled root in 0.23s
2024.01.24 11:47:10 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:10 INFO  time: compiled root in 0.76s
2024.01.24 11:47:12 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:12 INFO  time: compiled root in 0.33s
ene 24, 2024 11:47:18 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 144
2024.01.24 11:47:31 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:31 INFO  time: compiled root in 0.25s
2024.01.24 11:47:33 WARN  Using indexes to guess the definition of main
ene 24, 2024 11:47:34 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 164
ene 24, 2024 11:47:34 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 166
ene 24, 2024 11:47:35 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 168
ene 24, 2024 11:47:35 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 170
ene 24, 2024 11:47:35 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 172
2024.01.24 11:47:35 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:35 INFO  time: compiled root in 0.38s
ene 24, 2024 11:47:37 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 186
2024.01.24 11:47:37 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:37 INFO  time: compiled root in 0.32s
ene 24, 2024 11:47:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 191
ene 24, 2024 11:47:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 188
ene 24, 2024 11:47:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 189
ene 24, 2024 11:47:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 190
ene 24, 2024 11:47:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 194
2024.01.24 11:47:37 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:38 INFO  time: compiled root in 0.31s
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 193
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 202
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 192
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 199
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 200
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 203
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 201
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 206
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 210
2024.01.24 11:47:38 INFO  compiling root (3 scala sources and 26 java sources)
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 208
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 205
2024.01.24 11:47:38 INFO  time: compiled root in 0.16s
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 212
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 214
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 211
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 217
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 213
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 220
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 223
2024.01.24 11:47:39 INFO  compiling root (3 scala sources and 26 java sources)
ene 24, 2024 11:47:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 218
2024.01.24 11:47:39 INFO  time: compiled root in 0.16s
ene 24, 2024 11:47:41 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 230
2024.01.24 11:47:41 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:41 INFO  time: compiled root in 0.15s
ene 24, 2024 11:47:42 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 244
2024.01.24 11:47:41 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:41 INFO  time: compiled root in 0.14s
ene 24, 2024 11:47:44 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 251
ene 24, 2024 11:47:44 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 253
ene 24, 2024 11:47:44 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 254
ene 24, 2024 11:47:44 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 256
2024.01.24 11:47:49 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:49 INFO  time: compiled root in 0.16s
ene 24, 2024 11:47:50 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 287
ene 24, 2024 11:47:51 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 288
ene 24, 2024 11:47:52 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 300
ene 24, 2024 11:47:52 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 302
ene 24, 2024 11:47:52 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 301
ene 24, 2024 11:47:52 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 295
ene 24, 2024 11:47:52 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 303
ene 24, 2024 11:47:52 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 297
ene 24, 2024 11:47:52 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 304
ene 24, 2024 11:47:52 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 307
ene 24, 2024 11:47:53 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 317
ene 24, 2024 11:47:53 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 324
ene 24, 2024 11:47:53 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 325
ene 24, 2024 11:47:53 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 328
ene 24, 2024 11:47:55 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 337
ene 24, 2024 11:47:55 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 336
ene 24, 2024 11:47:55 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 333
ene 24, 2024 11:47:55 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 335
ene 24, 2024 11:47:55 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 339
ene 24, 2024 11:47:55 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 344
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 343
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 347
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 341
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 346
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 342
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 345
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 349
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 355
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 350
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 356
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 357
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 358
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 352
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 354
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 360
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 364
ene 24, 2024 11:47:56 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 368
ene 24, 2024 11:47:57 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 375
ene 24, 2024 11:47:57 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 378
ene 24, 2024 11:47:57 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 376
ene 24, 2024 11:47:58 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 377
2024.01.24 11:47:59 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:59 INFO  time: compiled root in 0.15s
2024.01.24 11:47:59 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:47:59 INFO  time: compiled root in 0.16s
ene 24, 2024 11:48:01 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 414
ene 24, 2024 11:48:02 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 418
ene 24, 2024 11:48:02 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 421
ene 24, 2024 11:48:04 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 429
ene 24, 2024 11:48:04 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 433
ene 24, 2024 11:48:04 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 432
ene 24, 2024 11:48:04 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 435
2024.01.24 11:48:04 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:04 INFO  time: compiled root in 0.17s
2024.01.24 11:48:06 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:06 INFO  time: compiled root in 0.17s
2024.01.24 11:48:08 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:08 INFO  time: compiled root in 0.17s
ene 24, 2024 11:48:10 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 476
ene 24, 2024 11:48:10 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 475
ene 24, 2024 11:48:10 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 480
ene 24, 2024 11:48:11 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 484
ene 24, 2024 11:48:11 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 488
ene 24, 2024 11:48:11 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 491
ene 24, 2024 11:48:11 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 496
ene 24, 2024 11:48:11 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 492
2024.01.24 11:48:14 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:14 INFO  time: compiled root in 0.16s
ene 24, 2024 11:48:16 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 521
ene 24, 2024 11:48:16 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 532
ene 24, 2024 11:48:16 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 528
ene 24, 2024 11:48:16 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 534
ene 24, 2024 11:48:17 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 540
ene 24, 2024 11:48:18 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 553
ene 24, 2024 11:48:18 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 555
2024.01.24 11:48:19 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:19 INFO  time: compiled root in 0.21s
ene 24, 2024 11:48:21 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 577
ene 24, 2024 11:48:21 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 582
ene 24, 2024 11:48:21 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 578
ene 24, 2024 11:48:21 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 584
ene 24, 2024 11:48:22 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 593
ene 24, 2024 11:48:22 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 587
ene 24, 2024 11:48:22 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 588
ene 24, 2024 11:48:22 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 591
ene 24, 2024 11:48:23 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 594
ene 24, 2024 11:48:23 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 596
ene 24, 2024 11:48:23 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 601
ene 24, 2024 11:48:23 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 598
ene 24, 2024 11:48:23 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 602
ene 24, 2024 11:48:23 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 600
ene 24, 2024 11:48:24 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 606
ene 24, 2024 11:48:24 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 608
ene 24, 2024 11:48:24 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 605
ene 24, 2024 11:48:24 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 607
2024.01.24 11:48:24 INFO  compiling root (3 scala sources and 26 java sources)
ene 24, 2024 11:48:24 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 613
2024.01.24 11:48:24 INFO  time: compiled root in 0.14s
2024.01.24 11:48:24 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:24 INFO  time: compiled root in 0.17s
ene 24, 2024 11:48:25 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 628
ene 24, 2024 11:48:26 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 632
ene 24, 2024 11:48:27 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 645
ene 24, 2024 11:48:28 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 655
ene 24, 2024 11:48:28 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 656
2024.01.24 11:48:29 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:29 INFO  time: compiled root in 0.16s
2024.01.24 11:48:29 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:29 INFO  time: compiled root in 0.16s
ene 24, 2024 11:48:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 706
ene 24, 2024 11:48:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 705
ene 24, 2024 11:48:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 710
ene 24, 2024 11:48:34 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 716
2024.01.24 11:48:34 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:34 INFO  time: compiled root in 0.15s
2024.01.24 11:48:34 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:34 INFO  time: compiled root in 0.12s
ene 24, 2024 11:48:37 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 742
ene 24, 2024 11:48:37 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 744
ene 24, 2024 11:48:37 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 749
ene 24, 2024 11:48:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 750
ene 24, 2024 11:48:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 756
ene 24, 2024 11:48:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 758
ene 24, 2024 11:48:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 760
ene 24, 2024 11:48:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 759
ene 24, 2024 11:48:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 766
ene 24, 2024 11:48:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 769
ene 24, 2024 11:48:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 770
ene 24, 2024 11:48:39 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 776
2024.01.24 11:48:39 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:39 INFO  time: compiled root in 0.16s
2024.01.24 11:48:41 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:41 INFO  time: compiled root in 0.14s
ene 24, 2024 11:48:42 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 796
ene 24, 2024 11:48:42 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 797
2024.01.24 11:48:43 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:43 INFO  time: compiled root in 0.13s
2024.01.24 11:48:43 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:43 INFO  time: compiled root in 0.12s
ene 24, 2024 11:48:45 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 827
ene 24, 2024 11:48:45 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 828
ene 24, 2024 11:48:45 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 830
2024.01.24 11:48:46 WARN  Using indexes to guess the definition of Action
ene 24, 2024 11:48:46 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 832
ene 24, 2024 11:48:46 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 840
ene 24, 2024 11:48:46 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 834
2024.01.24 11:48:46 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:46 INFO  time: compiled root in 0.12s
2024.01.24 11:48:46 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:46 INFO  time: compiled root in 0.13s
ene 24, 2024 11:48:48 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 865
2024.01.24 11:48:49 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:49 INFO  time: compiled root in 0.17s
2024.01.24 11:48:49 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:49 INFO  time: compiled root in 0.1s
2024.01.24 11:48:51 WARN  Using indexes to guess the definition of Action
ene 24, 2024 11:48:52 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 897
2024.01.24 11:48:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:52 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 7m 5.248s)
2024.01.24 11:48:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:52 INFO  time: compiled root in 0.12s
2024.01.24 11:48:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:52 INFO  time: compiled root in 0.11s
2024.01.24 11:48:54 WARN  Using indexes to guess the definition of Action
2024.01.24 11:48:55 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:55 INFO  time: compiled root in 0.18s
2024.01.24 11:48:56 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:56 INFO  time: compiled root in 0.11s
ene 24, 2024 11:48:57 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 955
ene 24, 2024 11:48:58 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 960
2024.01.24 11:48:58 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:58 INFO  time: compiled root in 0.12s
2024.01.24 11:48:58 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:48:58 INFO  time: compiled root in 0.11s
2024.01.24 11:49:00 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:00 INFO  time: compiled root in 0.12s
2024.01.24 11:49:02 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:02 INFO  time: compiled root in 0.15s
2024.01.24 11:49:03 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:03 INFO  time: compiled root in 0.13s
2024.01.24 11:49:04 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:04 INFO  time: compiled root in 88ms
2024.01.24 11:49:04 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:04 INFO  time: compiled root in 0.13s
ene 24, 2024 11:49:06 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1027
ene 24, 2024 11:49:06 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1028
ene 24, 2024 11:49:06 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1030
ene 24, 2024 11:49:09 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1058
ene 24, 2024 11:49:09 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1059
2024.01.24 11:49:10 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:10 INFO  time: compiled root in 0.12s
2024.01.24 11:49:10 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:10 INFO  time: compiled root in 0.13s
2024.01.24 11:49:12 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:12 INFO  time: compiled root in 0.1s
2024.01.24 11:49:12 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:12 INFO  time: compiled root in 0.14s
ene 24, 2024 11:49:15 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1109
ene 24, 2024 11:49:15 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1110
ene 24, 2024 11:49:15 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1116
2024.01.24 11:49:15 WARN  Using indexes to guess the definition of Invoker
2024.01.24 11:49:15 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:15 INFO  time: compiled root in 0.14s
2024.01.24 11:49:20 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:20 INFO  time: compiled root in 0.1s
ene 24, 2024 11:49:21 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1146
ene 24, 2024 11:49:21 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1147
2024.01.24 11:49:21 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:21 INFO  time: compiled root in 97ms
2024.01.24 11:49:22 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:22 INFO  time: compiled root in 0.13s
ene 24, 2024 11:49:24 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1165
ene 24, 2024 11:49:24 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1166
ene 24, 2024 11:49:24 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1167
ene 24, 2024 11:49:24 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1169
2024.01.24 11:49:24 WARN  Using indexes to guess the definition of Controller
ene 24, 2024 11:49:26 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1173
ene 24, 2024 11:49:26 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1179
ene 24, 2024 11:49:26 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1181
ene 24, 2024 11:49:26 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1174
2024.01.24 11:49:26 WARN  Using indexes to guess the definition of Controller
ene 24, 2024 11:49:26 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1183
ene 24, 2024 11:49:26 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1178
ene 24, 2024 11:49:26 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1185
ene 24, 2024 11:49:26 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1188
ene 24, 2024 11:49:27 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1187
ene 24, 2024 11:49:27 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1190
ene 24, 2024 11:49:27 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1194
ene 24, 2024 11:49:27 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1196
ene 24, 2024 11:49:27 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1197
ene 24, 2024 11:49:27 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1198
ene 24, 2024 11:49:27 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1193
ene 24, 2024 11:49:27 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1201
ene 24, 2024 11:49:28 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1202
ene 24, 2024 11:49:28 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1203
ene 24, 2024 11:49:29 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1206
ene 24, 2024 11:49:29 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1207
ene 24, 2024 11:49:29 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1209
ene 24, 2024 11:49:29 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1210
ene 24, 2024 11:49:29 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1215
2024.01.24 11:49:29 INFO  compiling root (3 scala sources and 26 java sources)
ene 24, 2024 11:49:29 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1212
ene 24, 2024 11:49:29 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1214
ene 24, 2024 11:49:29 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1219
ene 24, 2024 11:49:29 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1223
2024.01.24 11:49:29 INFO  time: compiled root in 0.11s
2024.01.24 11:49:29 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:29 INFO  time: compiled root in 73ms
ene 24, 2024 11:49:30 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1235
ene 24, 2024 11:49:30 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1236
2024.01.24 11:49:31 WARN  Using indexes to guess the definition of Action
2024.01.24 11:49:32 WARN  Using indexes to guess the definition of Invoker
ene 24, 2024 11:49:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1256
ene 24, 2024 11:49:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1257
ene 24, 2024 11:49:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1250
ene 24, 2024 11:49:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1251
ene 24, 2024 11:49:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1258
ene 24, 2024 11:49:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1260
ene 24, 2024 11:49:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1261
ene 24, 2024 11:49:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1267
ene 24, 2024 11:49:33 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1269
ene 24, 2024 11:49:34 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1274
ene 24, 2024 11:49:34 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1270
ene 24, 2024 11:49:34 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1276
ene 24, 2024 11:49:35 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1288
2024.01.24 11:49:35 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:35 INFO  time: compiled root in 0.1s
2024.01.24 11:49:35 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:35 INFO  time: compiled root in 0.11s
2024.01.24 11:49:37 WARN  Using indexes to guess the definition of Action
2024.01.24 11:49:37 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:37 INFO  time: compiled root in 0.14s
ene 24, 2024 11:49:38 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1328
2024.01.24 11:49:43 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:43 INFO  time: compiled root in 0.1s
2024.01.24 11:49:53 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:53 INFO  time: compiled root in 0.1s
2024.01.24 11:49:57 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:49:57 INFO  time: compiled root in 81ms
2024.01.24 11:50:02 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:50:02 INFO  time: compiled root in 57ms
2024.01.24 11:50:03 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:50:03 INFO  time: compiled root in 88ms
2024.01.24 11:50:12 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:50:12 INFO  time: compiled root in 88ms
2024.01.24 11:50:13 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:50:13 INFO  time: compiled root in 99ms
2024.01.24 11:50:15 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:50:15 INFO  time: compiled root in 0.11s
2024.01.24 11:50:15 WARN  Using indexes to guess the definition of Action
2024.01.24 11:50:16 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:50:16 INFO  time: compiled root in 65ms
2024.01.24 11:50:21 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:50:21 INFO  time: compiled root in 94ms
2024.01.24 11:50:23 WARN  Using indexes to guess the definition of Action
2024.01.24 11:50:24 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:50:24 INFO  time: compiled root in 82ms
2024.01.24 11:50:59 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:01 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:02 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:03 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:03 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:03 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:05 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:05 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:07 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:07 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:07 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:09 WARN  Using indexes to guess the definition of Metric
2024.01.24 11:51:09 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:51:09 WARN  Using indexes to guess the definition of Metric
2024.01.24 11:51:13 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:51:13 INFO  time: compiled root in 85ms
2024.01.24 11:51:16 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:51:16 INFO  time: compiled root in 83ms
2024.01.24 11:51:21 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:51:21 INFO  time: compiled root in 44ms
2024.01.24 11:51:28 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:51:28 INFO  time: compiled root in 82ms
ene 24, 2024 11:51:41 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1705
2024.01.24 11:51:44 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:51:44 INFO  time: compiled root in 86ms
2024.01.24 11:51:45 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:51:45 INFO  time: compiled root in 44ms
2024.01.24 11:51:47 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:51:47 INFO  time: compiled root in 46ms
ene 24, 2024 11:51:52 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1752
2024.01.24 11:52:00 WARN  Using indexes to guess the definition of InterfaceAction
2024.01.24 11:52:00 WARN  Using indexes to guess the definition of InterfaceAction
2024.01.24 11:52:10 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:52:10 INFO  time: compiled root in 46ms
2024.01.24 11:52:21 WARN  Using indexes to guess the definition of InterfaceAction
2024.01.24 11:52:27 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:52:27 INFO  time: compiled root in 46ms
2024.01.24 11:52:30 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:52:30 INFO  time: compiled root in 44ms
2024.01.24 11:52:30 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:52:30 INFO  time: compiled root in 65ms
ene 24, 2024 11:52:45 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1881
2024.01.24 11:52:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:52:52 INFO  time: compiled root in 45ms
2024.01.24 11:52:55 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:52:55 INFO  time: compiled root in 84ms
2024.01.24 11:52:57 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:52:57 INFO  time: compiled root in 45ms
2024.01.24 11:53:05 WARN  Using indexes to guess the definition of DistributionPolicy
2024.01.24 11:53:05 WARN  Using indexes to guess the definition of InsufficientMemoryException
2024.01.24 11:53:08 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:53:08 INFO  time: compiled root in 94ms
2024.01.24 11:53:13 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:53:13 INFO  time: compiled root in 0.11s
2024.01.24 11:53:41 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:53:41 INFO  time: compiled root in 83ms
2024.01.24 11:53:46 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:53:46 INFO  time: compiled root in 88ms
2024.01.24 11:53:51 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:53:51 INFO  time: compiled root in 79ms
2024.01.24 11:53:58 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:53:58 INFO  time: compiled root in 84ms
2024.01.24 11:54:01 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:54:01 INFO  time: compiled root in 77ms
2024.01.24 11:54:04 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:54:04 INFO  time: compiled root in 0.1s
2024.01.24 11:54:05 WARN  Using indexes to guess the definition of Metric
2024.01.24 11:54:05 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:54:05 INFO  time: compiled root in 91ms
2024.01.24 11:54:06 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:54:06 INFO  time: compiled root in 88ms
2024.01.24 11:54:08 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:54:08 INFO  time: compiled root in 0.11s
2024.01.24 11:54:12 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:54:12 INFO  time: compiled root in 85ms
2024.01.24 11:54:31 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:54:31 INFO  time: compiled root in 0.15s
2024.01.24 11:54:57 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:54:57 INFO  time: compiled root in 49ms
2024.01.24 11:55:27 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:55:27 INFO  time: compiled root in 48ms
2024.01.24 11:55:27 WARN  Using indexes to guess the definition of getInstance
2024.01.24 11:55:34 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:55:34 INFO  time: compiled root in 79ms
2024.01.24 11:55:37 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:55:37 INFO  time: compiled root in 78ms
2024.01.24 11:57:56 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:57:56 INFO  time: compiled root in 83ms
2024.01.24 11:58:26 WARN  Using indexes to guess the definition of getInstance
2024.01.24 11:58:30 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:58:30 WARN  Using indexes to guess the definition of getInstance
2024.01.24 11:58:30 INFO  time: compiled root in 96ms
2024.01.24 11:58:33 WARN  Using indexes to guess the definition of GreedyGroup
2024.01.24 11:58:33 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:58:33 INFO  time: compiled root in 94ms
2024.01.24 11:58:33 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:58:33 INFO  time: compiled root in 63ms
2024.01.24 11:58:50 WARN  Using indexes to guess the definition of RoundRobinImproved
2024.01.24 11:58:50 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:58:50 INFO  time: compiled root in 81ms
2024.01.24 11:58:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:58:52 INFO  time: compiled root in 0.1s
2024.01.24 11:58:55 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:58:55 INFO  time: compiled root in 49ms
2024.01.24 11:59:00 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:59:00 INFO  time: compiled root in 0.1s
2024.01.24 11:59:01 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:59:01 INFO  time: compiled root in 83ms
2024.01.24 11:59:08 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:59:08 INFO  time: compiled root in 83ms
2024.01.24 11:59:18 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:59:18 WARN  Using indexes to guess the definition of Controller
2024.01.24 11:59:22 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:59:22 WARN  Using indexes to guess the definition of getId
2024.01.24 11:59:22 INFO  time: compiled root in 84ms
2024.01.24 11:59:53 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 11:59:53 INFO  time: compiled root in 85ms
2024.01.24 12:00:04 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:04 INFO  time: compiled root in 84ms
2024.01.24 12:00:08 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:08 INFO  time: compiled root in 84ms
2024.01.24 12:00:12 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:12 INFO  time: compiled root in 83ms
2024.01.24 12:00:21 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:21 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 18m 34.208s)
2024.01.24 12:00:21 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:21 INFO  time: compiled root in 56ms
2024.01.24 12:00:22 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:22 INFO  time: compiled root in 0.1s
2024.01.24 12:00:26 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:26 INFO  time: compiled root in 41ms
2024.01.24 12:00:35 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:35 INFO  time: compiled root in 87ms
2024.01.24 12:00:38 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:38 INFO  time: compiled root in 92ms
2024.01.24 12:00:41 WARN  Using indexes to guess the definition of RoundRobinImproved
Exception in thread "pool-4-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:00:41 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:41 INFO  time: compiled root in 0.12s
2024.01.24 12:00:41 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:00:42 WARN  Using indexes to guess the definition of RoundRobinImproved
2024.01.24 12:00:42 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:42 WARN  Using indexes to guess the definition of UniformGroup
ene 24, 2024 12:00:42 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2693
2024.01.24 12:00:42 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:00:42 INFO  time: compiled root in 78ms
2024.01.24 12:00:42 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:42 INFO  time: compiled root in 68ms
Exception in thread "pool-4-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:00:45 WARN  Using indexes to guess the definition of GreedyGroup
2024.01.24 12:00:45 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:45 INFO  time: compiled root in 0.11s
2024.01.24 12:00:45 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:00:46 WARN  Using indexes to guess the definition of RoundRobin
2024.01.24 12:00:46 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:00:45 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:45 INFO  time: compiled root in 67ms
2024.01.24 12:00:46 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:46 INFO  time: compiled root in 71ms
2024.01.24 12:00:49 WARN  Using indexes to guess the definition of GreedyGroup
2024.01.24 12:00:49 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:49 INFO  time: compiled root in 87ms
2024.01.24 12:00:49 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:00:50 WARN  Using indexes to guess the definition of GreedyGroup
2024.01.24 12:00:50 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:00:49 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:50 INFO  time: compiled root in 70ms
2024.01.24 12:00:50 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:50 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:00:50 INFO  time: compiled root in 49ms
2024.01.24 12:00:52 WARN  Using indexes to guess the definition of setPolicy
2024.01.24 12:00:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:52 INFO  time: compiled root in 0.1s
2024.01.24 12:00:53 WARN  Using indexes to guess the definition of BigGroup
2024.01.24 12:00:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:52 INFO  time: compiled root in 61ms
2024.01.24 12:00:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:52 INFO  time: compiled root in 71ms
2024.01.24 12:00:58 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:00:58 INFO  time: compiled root in 79ms
2024.01.24 12:01:01 WARN  Using indexes to guess the definition of GreedyGroup
2024.01.24 12:01:01 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:01 INFO  time: compiled root in 81ms
ene 24, 2024 12:01:02 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2790
2024.01.24 12:01:05 WARN  Using indexes to guess the definition of RoundRobinImproved
2024.01.24 12:01:05 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:05 INFO  time: compiled root in 74ms
2024.01.24 12:01:05 INFO  compiling root (3 scala sources and 26 java sources)
Exception in thread "pool-4-thread-4" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:01:06 WARN  Using indexes to guess the definition of RoundRobin
2024.01.24 12:01:05 INFO  time: compiled root in 89ms
2024.01.24 12:01:05 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:06 WARN  Using indexes to guess the definition of GreedyGroup
2024.01.24 12:01:05 INFO  time: compiled root in 78ms
2024.01.24 12:01:05 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:06 INFO  time: compiled root in 68ms
2024.01.24 12:01:06 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:07 INFO  time: compiled root in 68ms
2024.01.24 12:01:11 WARN  Using indexes to guess the definition of RoundRobinImproved
2024.01.24 12:01:11 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:11 INFO  time: compiled root in 0.11s
2024.01.24 12:01:11 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:11 INFO  time: compiled root in 60ms
2024.01.24 12:01:12 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:12 INFO  time: compiled root in 61ms
2024.01.24 12:01:15 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:15 INFO  time: compiled root in 70ms
2024.01.24 12:01:30 WARN  Using indexes to guess the definition of distributeActions
2024.01.24 12:01:30 WARN  Using indexes to guess the definition of getInstance
2024.01.24 12:01:30 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:30 INFO  time: compiled root in 81ms
2024.01.24 12:01:35 WARN  Using indexes to guess the definition of RoundRobinImproved
2024.01.24 12:01:35 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:35 INFO  time: compiled root in 74ms
2024.01.24 12:01:35 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:01:35 WARN  Using indexes to guess the definition of RoundRobinImproved
2024.01.24 12:01:35 INFO  compiling root (3 scala sources and 26 java sources)
Exception in thread "pool-4-thread-5" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:01:35 INFO  time: compiled root in 60ms
2024.01.24 12:01:40 WARN  Using indexes to guess the definition of Controller
2024.01.24 12:01:41 WARN  Using indexes to guess the definition of ActionProxy
2024.01.24 12:01:41 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:41 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:01:41 INFO  time: compiled root in 73ms
2024.01.24 12:01:41 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:01:41 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:41 WARN  Using indexes to guess the definition of RoundRobinImproved
2024.01.24 12:01:41 WARN  Using indexes to guess the definition of RoundRobin
2024.01.24 12:01:41 WARN  Using indexes to guess the definition of GreedyGroup
2024.01.24 12:01:41 INFO  time: compiled root in 74ms
2024.01.24 12:01:41 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:41 WARN  Using indexes to guess the definition of BigGroup
2024.01.24 12:01:41 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 19m 55.001s)
2024.01.24 12:01:41 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:41 INFO  time: compiled root in 12ms
2024.01.24 12:01:41 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:41 INFO  time: compiled root in 0.13s
2024.01.24 12:01:45 WARN  Using indexes to guess the definition of Invoker
2024.01.24 12:01:45 WARN  Using indexes to guess the definition of ActionProxy
2024.01.24 12:01:45 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:45 INFO  time: compiled root in 77ms
2024.01.24 12:01:47 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:01:48 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:47 WARN  Using indexes to guess the definition of UniformGroup
2024.01.24 12:01:48 INFO  time: compiled root in 75ms
2024.01.24 12:01:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:01:52 INFO  time: compiled root in 71ms
2024.01.24 12:02:04 WARN  Using indexes to guess the definition of BigGroup
2024.01.24 12:02:04 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:05 WARN  Using indexes to guess the definition of BigGroup
2024.01.24 12:02:04 INFO  time: compiled root in 85ms
2024.01.24 12:02:04 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:04 INFO  time: compiled root in 0.16s
2024.01.24 12:02:07 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:07 INFO  time: compiled root in 45ms
Exception in thread "pool-4-thread-6" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:02:12 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:12 INFO  time: compiled root in 45ms
2024.01.24 12:02:15 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:15 INFO  time: compiled root in 50ms
2024.01.24 12:02:17 WARN  Using indexes to guess the definition of Adder
2024.01.24 12:02:22 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:22 INFO  time: compiled root in 42ms
2024.01.24 12:02:27 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:27 INFO  time: compiled root in 45ms
2024.01.24 12:02:30 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:30 INFO  time: compiled root in 40ms
2024.01.24 12:02:36 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:36 INFO  time: compiled root in 45ms
2024.01.24 12:02:47 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:47 INFO  time: compiled root in 44ms
2024.01.24 12:02:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:02:52 INFO  time: compiled root in 41ms
2024.01.24 12:03:00 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:00 INFO  time: compiled root in 42ms
2024.01.24 12:03:12 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:12 INFO  time: compiled root in 43ms
2024.01.24 12:03:15 WARN  Using indexes to guess the definition of ActionProxy
2024.01.24 12:03:15 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:15 INFO  time: compiled root in 45ms
2024.01.24 12:03:20 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:20 INFO  time: compiled root in 47ms
2024.01.24 12:03:21 WARN  Using indexes to guess the definition of DynamicProxy
2024.01.24 12:03:20 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:20 INFO  time: compiled root in 27ms
2024.01.24 12:03:22 WARN  Using indexes to guess the definition of DynamicProxy
2024.01.24 12:03:22 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:22 INFO  time: compiled root in 28ms
2024.01.24 12:03:22 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:22 INFO  time: compiled root in 27ms
2024.01.24 12:03:23 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:23 INFO  time: compiled root in 41ms
2024.01.24 12:03:25 WARN  Using indexes to guess the definition of RoundRobinImproved
2024.01.24 12:03:25 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:25 INFO  time: compiled root in 45ms
2024.01.24 12:03:25 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:25 INFO  time: compiled root in 27ms
2024.01.24 12:03:26 WARN  Using indexes to guess the definition of RoundRobinImproved
2024.01.24 12:03:25 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:25 INFO  time: compiled root in 47ms
ene 24, 2024 12:03:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3456
2024.01.24 12:03:39 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:39 INFO  time: compiled root in 49ms
2024.01.24 12:03:40 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:40 INFO  time: compiled root in 41ms
2024.01.24 12:03:44 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:03:44 INFO  time: compiled root in 45ms
2024.01.24 12:04:07 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:04:07 INFO  time: compiled root in 44ms
2024.01.24 12:04:11 WARN  Using indexes to guess the definition of Reduce
2024.01.24 12:04:15 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:04:15 INFO  time: compiled root in 44ms
2024.01.24 12:04:24 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:04:24 INFO  time: compiled root in 43ms
2024.01.24 12:04:27 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:04:27 INFO  time: compiled root in 42ms
2024.01.24 12:04:35 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:04:35 INFO  time: compiled root in 51ms
2024.01.24 12:04:42 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:04:42 INFO  time: compiled root in 44ms
2024.01.24 12:04:45 WARN  Using indexes to guess the definition of addAction
2024.01.24 12:04:45 WARN  Using indexes to guess the definition of getId
2024.01.24 12:04:47 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:04:47 INFO  time: compiled root in 44ms
2024.01.24 12:04:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:04:52 INFO  time: compiled root in 42ms
2024.01.24 12:04:58 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:04:58 INFO  time: compiled root in 60ms
2024.01.24 12:05:01 WARN  Using indexes to guess the definition of InterfaceInvoker
2024.01.24 12:05:01 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:01 INFO  time: compiled root in 43ms
2024.01.24 12:05:01 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:01 INFO  time: compiled root in 27ms
2024.01.24 12:05:05 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:05 INFO  time: compiled root in 48ms
2024.01.24 12:05:07 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:07 INFO  time: compiled root in 43ms
Exception in thread "pool-4-thread-7" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:05:15 WARN  Using indexes to guess the definition of GreedyGroup
2024.01.24 12:05:15 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:15 INFO  time: compiled root in 49ms
2024.01.24 12:05:15 WARN  Using indexes to guess the definition of Unit
2024.01.24 12:05:19 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:19 INFO  time: compiled root in 44ms
2024.01.24 12:05:25 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:25 INFO  time: compiled root in 44ms
2024.01.24 12:05:27 WARN  Using indexes to guess the definition of String
2024.01.24 12:05:27 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 24, 2024 12:05:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * This method does not do any precondition checks on its arguments.\n     * \u003cp\u003e\n     * Important: parameter order of this method is deliberately changed in order to\n     * disambiguate it against other similar methods of this class.\n     */\n    @SuppressWarnings(\"removal\")\n    private String(Charset charset, byte[] bytes, int offset, int length) {\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     *\n     * @param  noShare\n     *         {@code true} if the resulting string MUST NOT share the byte array,\n     *         {@code false} if the byte array can be exclusively used to construct\n     *         the string and is not modified or used for any other purpose.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                if (noShare || length !\u003d bytes.length) {\n                    return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n                } else {\n                    return new String(bytes, LATIN1);\n                }\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return val.clone();\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            int positives \u003d StringCoding.countPositives(val, 0, val.length);\n            byte[] dst \u003d val.clone();\n            if (positives \u003c dst.length) {\n                replaceNegatives(dst, positives);\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static void replaceNegatives(byte[] val, int fromIndex) {\n        for (int i \u003d fromIndex; i \u003c val.length; i++) {\n            if (val[i] \u003c 0) {\n                val[i] \u003d \u0027?\u0027;\n            }\n        }\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return val.clone();\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16) {\n            return encodeUTF8_UTF16(val, doReplace);\n        }\n\n        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n            return val.clone();\n        }\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(Charset.defaultCharset(), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(Charset.defaultCharset(), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger than the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            return v1.length \u003c\u003d v2.length \u0026\u0026 ArraysSupport.mismatch(v1, v2, v1.length) \u003c 0;\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte[] v1 \u003d s1.value;\n            byte[] v2 \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n                ooffset \u003c\u003c\u003d UTF16;\n                len \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(tv, toffset,\n                    ov, ooffset, len) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte[] ta \u003d value;\n        byte[] pa \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(ta, toffset,\n                    pa, 0, pc) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code ch} in the string.\n     * If stricter behavior is needed, {@link #indexOf(int, int, int)}\n     * should be considered instead.\n     * On a {@link String} {@code s}, for example,\n     * {@code s.indexOf(ch, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, length())\n                : StringUTF16.indexOf(value, ch, fromIndex, length());\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at {@code beginIndex} and\n     * stopping before {@code endIndex}.\n     *\n     * \u003cp\u003eIf a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code beginIndex} but smaller than\n     * {@code endIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code beginIndex} and before position\n     * {@code endIndex}, then {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code beginIndex} and less than {@code endIndex},\n     *          or {@code -1} if the character does not occur.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(int ch, int beginIndex, int endIndex) {\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return isLatin1() ? StringLatin1.indexOf(value, ch, beginIndex, endIndex)\n                : StringUTF16.indexOf(value, ch, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code str} in the string.\n     * If stricter behavior is needed, {@link #indexOf(String, int, int)}\n     * should be considered instead.\n     * On {@link String} {@code s} and a non-empty {@code str}, for example,\n     * {@code s.indexOf(str, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified substring\n     * within the specified index range of {@code this} string.\n     *\n     * \u003cp\u003eThis method returns the same result as the one of the invocation\n     * \u003cpre\u003e{@code\n     *     s.substring(beginIndex, endIndex).indexOf(str) + beginIndex\n     * }\u003c/pre\u003e\n     * if the index returned by {@link #indexOf(String)} is non-negative,\n     * and returns -1 otherwise.\n     * (No substring is instantiated, though.)\n     *\n     * @param   str         the substring to search for.\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the specified substring\n     *          within the specified index range,\n     *          or {@code -1} if there is no such occurrence.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(String str, int beginIndex, int endIndex) {\n        if (str.length() \u003d\u003d 1) {\n            /* Simple optimization, can be omitted without behavioral impact */\n            return indexOf(str.charAt(0), beginIndex, endIndex);\n        }\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return indexOf(value, coder(), endIndex, str, beginIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  last index (exclusive) in the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        fromIndex \u003d Math.clamp(fromIndex, 0, srcCount);\n        int tgtCount \u003d tgtStr.length();\n        if (tgtCount \u003e srcCount - fromIndex) {\n            return -1;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        return split(regex, limit, false);\n    }\n\n    /**\n     * Splits this string around matches of the given regular expression and\n     * returns both the strings and the matching delimiters.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.\n     * Each substring is immediately followed by the subsequence (the delimiter)\n     * that matches the given expression, \u003cem\u003eexcept\u003c/em\u003e for the last\n     * substring, which is not followed by anything.\n     * The substrings in the array and the delimiters are in the order in which\n     * they occur in the input.\n     * If the expression does not match any part of the input then the resulting\n     * array has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring nor the empty delimiter.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than 2 \u0026times; \u003ci\u003elimit\u003c/i\u003e - 1, and the array\u0027s last\n     *    entry will contain all input beyond the last matched delimiter.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The input {@code \"boo:::and::foo\"}, for example, yields the following\n     * results with these parameters:\n     *\n     * \u003ctable class\u003d\"plain\" style\u003d\"margin-left:2em;\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:+\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and::foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @apiNote An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code splitWithDelimiters(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#splitWithDelimiters(CharSequence,int) splitWithDelimiters}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression, alternating\n     *          substrings and matching delimiters\n     *\n     * @since   21\n     */\n    public String[] splitWithDelimiters(String regex, int limit) {\n        return split(regex, limit, true);\n    }\n\n    private String[] split(String regex, int limit, boolean withDelimiters) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n                \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n                (regex.length() \u003d\u003d 2 \u0026\u0026\n                        regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n                        (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n                (ch \u003c Character.MIN_HIGH_SURROGATE ||\n                        ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            // All the checks above can potentially be constant folded by\n            // a JIT/AOT compiler when the regex is a constant string.\n            // That requires method inlining of the checks, which is only\n            // possible when the actual split logic is in a separate method\n            // because the large split loop can usually not be inlined.\n            return split(ch, limit, withDelimiters);\n        }\n        Pattern pattern \u003d Pattern.compile(regex);\n        return withDelimiters\n                ? pattern.splitWithDelimiters(this, limit)\n                : pattern.split(this, limit);\n    }\n\n    private String[] split(char ch, int limit, boolean withDelimiters) {\n        int matchCount \u003d 0;\n        int off \u003d 0;\n        int next;\n        boolean limited \u003d limit \u003e 0;\n        ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        String del \u003d withDelimiters ? String.valueOf(ch) : null;\n        while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n            if (!limited || matchCount \u003c limit - 1) {\n                list.add(substring(off, next));\n                if (withDelimiters) {\n                    list.add(del);\n                }\n                off \u003d next + 1;\n                ++matchCount;\n            } else {    // last one\n                int last \u003d length();\n                list.add(substring(off, last));\n                off \u003d last;\n                ++matchCount;\n                break;\n            }\n        }\n        // If no match was found, return this\n        if (off \u003d\u003d 0)\n            return new String[] {this};\n\n        // Add remaining segment\n        if (!limited || matchCount \u003c limit)\n            list.add(substring(off, length()));\n\n        // Construct result\n        int resultSize \u003d list.size();\n        if (limit \u003d\u003d 0) {\n            while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                resultSize--;\n            }\n        }\n        String[] result \u003d new String[resultSize];\n        return list.subList(0, resultSize).toArray(result);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0, false);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a {@linkplain\n     * Character##unicode surrogate code point} is passed through\n     * uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        repeatCopyRest(multiple, 0, limit, len);\n        return new String(multiple, coder);\n    }\n\n    /**\n     * Used to perform copying after the initial insertion. Copying is optimized\n     * by using power of two duplication. First pass duplicates original copy,\n     * second pass then duplicates the original and the copy yielding four copies,\n     * third pass duplicates four copies yielding eight copies, and so on.\n     * Finally, the remainder is filled in with prior copies.\n     *\n     * @implNote The technique used here is significantly faster than hand-rolled\n     * loops or special casing small numbers due to the intensive optimization\n     * done by intrinsic {@code System.arraycopy}.\n     *\n     * @param buffer    destination buffer\n     * @param offset    offset in the destination buffer\n     * @param limit     total replicated including what is already in the buffer\n     * @param copied    number of bytes that have already in the buffer\n     */\n    static void repeatCopyRest(byte[] buffer, int offset, int limit, int copied) {\n        // Initial copy is in the buffer.\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            // Power of two duplicate.\n            System.arraycopy(buffer, offset, buffer, offset + copied, copied);\n        }\n        // Duplicate remainder.\n        System.arraycopy(buffer, offset, buffer, offset + copied, limit - copied);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @return  {@code offset} if the sub-range within bounds of the range\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static int checkBoundsOffCount(int offset, int count, int length) {\n        return Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 24, 2024 12:05:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.01.24 12:05:30 WARN  Using indexes to guess the definition of InsufficientMemoryException
2024.01.24 12:05:30 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:30 INFO  time: compiled root in 46ms
2024.01.24 12:05:31 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:31 INFO  time: compiled root in 27ms
2024.01.24 12:05:33 WARN  Using indexes to guess the definition of addAction
2024.01.24 12:05:33 WARN  Using indexes to guess the definition of GreedyGroup
2024.01.24 12:05:33 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:33 INFO  time: compiled root in 53ms
Exception in thread "pool-4-thread-8" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:05:34 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:34 INFO  time: compiled root in 51ms
2024.01.24 12:05:35 WARN  Using indexes to guess the definition of InvokerCacheDecorator
2024.01.24 12:05:35 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:35 INFO  time: compiled root in 48ms
2024.01.24 12:05:35 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:35 INFO  time: compiled root in 24ms
2024.01.24 12:05:36 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:36 INFO  time: compiled root in 26ms
2024.01.24 12:05:39 INFO  compiling root (3 scala sources and 25 java sources)
2024.01.24 12:05:39 INFO  time: compiled root in 45ms
2024.01.24 12:05:39 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:39 INFO  time: compiled root in 28ms
2024.01.24 12:05:39 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:39 INFO  time: compiled root in 28ms
2024.01.24 12:05:42 WARN  Using indexes to guess the definition of addInvoker
2024.01.24 12:05:42 WARN  Using indexes to guess the definition of String
2024.01.24 12:05:42 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 24, 2024 12:05:42 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * This method does not do any precondition checks on its arguments.\n     * \u003cp\u003e\n     * Important: parameter order of this method is deliberately changed in order to\n     * disambiguate it against other similar methods of this class.\n     */\n    @SuppressWarnings(\"removal\")\n    private String(Charset charset, byte[] bytes, int offset, int length) {\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     *\n     * @param  noShare\n     *         {@code true} if the resulting string MUST NOT share the byte array,\n     *         {@code false} if the byte array can be exclusively used to construct\n     *         the string and is not modified or used for any other purpose.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                if (noShare || length !\u003d bytes.length) {\n                    return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n                } else {\n                    return new String(bytes, LATIN1);\n                }\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return val.clone();\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            int positives \u003d StringCoding.countPositives(val, 0, val.length);\n            byte[] dst \u003d val.clone();\n            if (positives \u003c dst.length) {\n                replaceNegatives(dst, positives);\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static void replaceNegatives(byte[] val, int fromIndex) {\n        for (int i \u003d fromIndex; i \u003c val.length; i++) {\n            if (val[i] \u003c 0) {\n                val[i] \u003d \u0027?\u0027;\n            }\n        }\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return val.clone();\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16) {\n            return encodeUTF8_UTF16(val, doReplace);\n        }\n\n        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n            return val.clone();\n        }\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(Charset.defaultCharset(), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(Charset.defaultCharset(), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger than the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            return v1.length \u003c\u003d v2.length \u0026\u0026 ArraysSupport.mismatch(v1, v2, v1.length) \u003c 0;\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte[] v1 \u003d s1.value;\n            byte[] v2 \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n                ooffset \u003c\u003c\u003d UTF16;\n                len \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(tv, toffset,\n                    ov, ooffset, len) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte[] ta \u003d value;\n        byte[] pa \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(ta, toffset,\n                    pa, 0, pc) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code ch} in the string.\n     * If stricter behavior is needed, {@link #indexOf(int, int, int)}\n     * should be considered instead.\n     * On a {@link String} {@code s}, for example,\n     * {@code s.indexOf(ch, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, length())\n                : StringUTF16.indexOf(value, ch, fromIndex, length());\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at {@code beginIndex} and\n     * stopping before {@code endIndex}.\n     *\n     * \u003cp\u003eIf a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code beginIndex} but smaller than\n     * {@code endIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code beginIndex} and before position\n     * {@code endIndex}, then {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code beginIndex} and less than {@code endIndex},\n     *          or {@code -1} if the character does not occur.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(int ch, int beginIndex, int endIndex) {\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return isLatin1() ? StringLatin1.indexOf(value, ch, beginIndex, endIndex)\n                : StringUTF16.indexOf(value, ch, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code str} in the string.\n     * If stricter behavior is needed, {@link #indexOf(String, int, int)}\n     * should be considered instead.\n     * On {@link String} {@code s} and a non-empty {@code str}, for example,\n     * {@code s.indexOf(str, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified substring\n     * within the specified index range of {@code this} string.\n     *\n     * \u003cp\u003eThis method returns the same result as the one of the invocation\n     * \u003cpre\u003e{@code\n     *     s.substring(beginIndex, endIndex).indexOf(str) + beginIndex\n     * }\u003c/pre\u003e\n     * if the index returned by {@link #indexOf(String)} is non-negative,\n     * and returns -1 otherwise.\n     * (No substring is instantiated, though.)\n     *\n     * @param   str         the substring to search for.\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the specified substring\n     *          within the specified index range,\n     *          or {@code -1} if there is no such occurrence.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(String str, int beginIndex, int endIndex) {\n        if (str.length() \u003d\u003d 1) {\n            /* Simple optimization, can be omitted without behavioral impact */\n            return indexOf(str.charAt(0), beginIndex, endIndex);\n        }\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return indexOf(value, coder(), endIndex, str, beginIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  last index (exclusive) in the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        fromIndex \u003d Math.clamp(fromIndex, 0, srcCount);\n        int tgtCount \u003d tgtStr.length();\n        if (tgtCount \u003e srcCount - fromIndex) {\n            return -1;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        return split(regex, limit, false);\n    }\n\n    /**\n     * Splits this string around matches of the given regular expression and\n     * returns both the strings and the matching delimiters.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.\n     * Each substring is immediately followed by the subsequence (the delimiter)\n     * that matches the given expression, \u003cem\u003eexcept\u003c/em\u003e for the last\n     * substring, which is not followed by anything.\n     * The substrings in the array and the delimiters are in the order in which\n     * they occur in the input.\n     * If the expression does not match any part of the input then the resulting\n     * array has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring nor the empty delimiter.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than 2 \u0026times; \u003ci\u003elimit\u003c/i\u003e - 1, and the array\u0027s last\n     *    entry will contain all input beyond the last matched delimiter.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The input {@code \"boo:::and::foo\"}, for example, yields the following\n     * results with these parameters:\n     *\n     * \u003ctable class\u003d\"plain\" style\u003d\"margin-left:2em;\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:+\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and::foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @apiNote An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code splitWithDelimiters(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#splitWithDelimiters(CharSequence,int) splitWithDelimiters}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression, alternating\n     *          substrings and matching delimiters\n     *\n     * @since   21\n     */\n    public String[] splitWithDelimiters(String regex, int limit) {\n        return split(regex, limit, true);\n    }\n\n    private String[] split(String regex, int limit, boolean withDelimiters) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n                \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n                (regex.length() \u003d\u003d 2 \u0026\u0026\n                        regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n                        (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n                (ch \u003c Character.MIN_HIGH_SURROGATE ||\n                        ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            // All the checks above can potentially be constant folded by\n            // a JIT/AOT compiler when the regex is a constant string.\n            // That requires method inlining of the checks, which is only\n            // possible when the actual split logic is in a separate method\n            // because the large split loop can usually not be inlined.\n            return split(ch, limit, withDelimiters);\n        }\n        Pattern pattern \u003d Pattern.compile(regex);\n        return withDelimiters\n                ? pattern.splitWithDelimiters(this, limit)\n                : pattern.split(this, limit);\n    }\n\n    private String[] split(char ch, int limit, boolean withDelimiters) {\n        int matchCount \u003d 0;\n        int off \u003d 0;\n        int next;\n        boolean limited \u003d limit \u003e 0;\n        ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        String del \u003d withDelimiters ? String.valueOf(ch) : null;\n        while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n            if (!limited || matchCount \u003c limit - 1) {\n                list.add(substring(off, next));\n                if (withDelimiters) {\n                    list.add(del);\n                }\n                off \u003d next + 1;\n                ++matchCount;\n            } else {    // last one\n                int last \u003d length();\n                list.add(substring(off, last));\n                off \u003d last;\n                ++matchCount;\n                break;\n            }\n        }\n        // If no match was found, return this\n        if (off \u003d\u003d 0)\n            return new String[] {this};\n\n        // Add remaining segment\n        if (!limited || matchCount \u003c limit)\n            list.add(substring(off, length()));\n\n        // Construct result\n        int resultSize \u003d list.size();\n        if (limit \u003d\u003d 0) {\n            while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                resultSize--;\n            }\n        }\n        String[] result \u003d new String[resultSize];\n        return list.subList(0, resultSize).toArray(result);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0, false);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a {@linkplain\n     * Character##unicode surrogate code point} is passed through\n     * uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        repeatCopyRest(multiple, 0, limit, len);\n        return new String(multiple, coder);\n    }\n\n    /**\n     * Used to perform copying after the initial insertion. Copying is optimized\n     * by using power of two duplication. First pass duplicates original copy,\n     * second pass then duplicates the original and the copy yielding four copies,\n     * third pass duplicates four copies yielding eight copies, and so on.\n     * Finally, the remainder is filled in with prior copies.\n     *\n     * @implNote The technique used here is significantly faster than hand-rolled\n     * loops or special casing small numbers due to the intensive optimization\n     * done by intrinsic {@code System.arraycopy}.\n     *\n     * @param buffer    destination buffer\n     * @param offset    offset in the destination buffer\n     * @param limit     total replicated including what is already in the buffer\n     * @param copied    number of bytes that have already in the buffer\n     */\n    static void repeatCopyRest(byte[] buffer, int offset, int limit, int copied) {\n        // Initial copy is in the buffer.\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            // Power of two duplicate.\n            System.arraycopy(buffer, offset, buffer, offset + copied, copied);\n        }\n        // Duplicate remainder.\n        System.arraycopy(buffer, offset, buffer, offset + copied, limit - copied);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @return  {@code offset} if the sub-range within bounds of the range\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static int checkBoundsOffCount(int offset, int count, int length) {\n        return Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 24, 2024 12:05:42 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Exception in thread "pool-4-thread-9" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:05:46 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:46 INFO  time: compiled root in 45ms
2024.01.24 12:05:52 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:52 INFO  time: compiled root in 75ms
2024.01.24 12:05:53 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:05:53 INFO  time: compiled root in 74ms
2024.01.24 12:06:14 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:06:14 INFO  time: compiled root in 86ms
2024.01.24 12:06:17 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:06:17 INFO  time: compiled root in 48ms
ene 24, 2024 12:06:18 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4014
2024.01.24 12:06:21 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:06:21 INFO  time: compiled root in 76ms
2024.01.24 12:06:35 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:06:35 INFO  time: compiled root in 46ms
2024.01.24 12:06:40 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:06:40 INFO  time: compiled root in 41ms
2024.01.24 12:06:43 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:06:43 INFO  time: compiled root in 79ms
2024.01.24 12:06:47 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:06:47 INFO  time: compiled root in 47ms
2024.01.24 12:06:50 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:06:50 INFO  time: compiled root in 45ms
2024.01.24 12:06:51 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:06:51 INFO  time: compiled root in 36ms
2024.01.24 12:07:14 WARN  Using indexes to guess the definition of Adder
ene 24, 2024 12:07:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4130
2024.01.24 12:07:15 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:07:15 INFO  time: compiled root in 82ms
2024.01.24 12:07:17 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:07:17 INFO  time: compiled root in 98ms
2024.01.24 12:07:19 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:07:19 INFO  time: compiled root in 90ms
2024.01.24 12:08:12 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:08:12 INFO  time: compiled root in 91ms
2024.01.24 12:08:17 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:08:17 INFO  time: compiled root in 79ms
2024.01.24 12:08:19 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:08:19 INFO  time: compiled root in 96ms
2024.01.24 12:08:22 WARN  Using indexes to guess the definition of Adder
2024.01.24 12:08:22 WARN  Using indexes to guess the definition of Adder
2024.01.24 12:08:22 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:08:22 INFO  time: compiled root in 82ms
2024.01.24 12:08:51 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:08:51 INFO  time: compiled root in 82ms
2024.01.24 12:08:56 INFO  compiling root (3 scala sources and 26 java sources)
2024.01.24 12:08:59 WARN  javac: [options] bootstrap class path not set in conjunction with -source 8
2024.01.24 12:08:59 WARN  javac: [options] source value 8 is obsolete and will be removed in a future release
2024.01.24 12:08:59 WARN  javac: [options] target value 8 is obsolete and will be removed in a future release
2024.01.24 12:08:59 WARN  javac: [options] To suppress warnings about obsolete options, use -Xlint:-options.
2024.01.24 12:08:59 INFO  time: compiled root in 2.8s
2024.01.24 12:09:00 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:09:17 INFO  compiling root-test (1 scala source)
2024.01.24 12:09:17 INFO  time: compiled root-test in 0.82s
2024.01.24 12:09:20 INFO  compiling root-test (1 scala source)
2024.01.24 12:09:20 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.24 12:09:20 INFO  time: compiled root-test in 0.76s
2024.01.24 12:09:24 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:09:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:09:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:09:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:09:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:09:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:09:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
Exception in thread "pool-4-thread-10" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:09:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:09:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:09:26 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:09:27 INFO  compiling root-test (1 scala source)
2024.01.24 12:09:27 INFO  time: compiled root-test in 0.9s
2024.01.24 12:09:29 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.24 12:09:29 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.24 12:09:29 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.24 12:09:30 INFO  Trying to attach to remote debuggee VM 127.0.0.1:52771 .
2024.01.24 12:09:30 INFO  Attaching to debuggee VM succeeded.
2024.01.24 12:09:30 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.24 12:09:30 INFO  Closing debug server tcp://0.0.0.0:52767
ene 24, 2024 12:10:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4397
ene 24, 2024 12:10:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4399
ene 24, 2024 12:10:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4401
ene 24, 2024 12:10:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4400
2024.01.24 12:10:39 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.24 12:10:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
ene 24, 2024 12:10:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4427
2024.01.24 12:10:44 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.24 12:10:44 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.24 12:10:44 INFO  Starting debug proxy for [test.scala.Tests()]
2024.01.24 12:10:44 INFO  Trying to attach to remote debuggee VM 127.0.0.1:52816 .
2024.01.24 12:10:44 INFO  Attaching to debuggee VM succeeded.
2024.01.24 12:10:44 INFO  Canceling debug proxy for [test.scala.Tests()]
2024.01.24 12:10:44 INFO  Closing debug server tcp://0.0.0.0:52813
2024.01.24 12:12:51 INFO  Shutting down server
2024.01.24 12:12:51 INFO  shutting down Metals
2024.01.24 12:12:51 INFO  Shut down connection with build server.
2024.01.24 12:12:51 INFO  Shut down connection with build server.
2024.01.24 12:12:51 INFO  Exiting server
2024.01.24 12:17:49 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.24 12:17:50 INFO  Attempting to connect to the build server...
2024.01.24 12:17:50 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.24 12:17:50 INFO  skipping build import with status 'Failed'
2024.01.24 12:17:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.24 12:17:50 INFO  Attempting to connect to the build server...
2024.01.24 12:17:50 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.24 12:17:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.24 12:17:50 INFO  time: Connected to build server in 0.31s
2024.01.24 12:17:50 INFO  Connected to Build server: Bloop v1.5.13
2024.01.24 12:17:52 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.24 12:17:55 INFO  time: indexed workspace in 2.28s
2024.01.24 12:18:05 INFO  compiling root (1 scala source)
2024.01.24 12:18:05 INFO  time: compiled root in 0.24s
2024.01.24 12:19:23 INFO  compiling root (2 scala sources)
2024.01.24 12:19:23 INFO  time: compiled root in 0.95s
2024.01.24 12:19:24 INFO  compiling root (1 scala source)
2024.01.24 12:19:24 INFO  time: compiled root in 0.17s
2024.01.24 12:19:30 INFO  compiling root (1 scala source)
2024.01.24 12:19:30 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 1m 39.953s)
2024.01.24 12:19:30 INFO  compiling root (1 scala source)
2024.01.24 12:19:30 INFO  time: compiled root in 0.45s
2024.01.24 12:19:33 INFO  compiling root (1 scala source)
2024.01.24 12:19:33 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
2024.01.24 12:19:33 INFO  time: compiled root in 0.53s
2024.01.24 12:19:33 INFO  compiling root (1 scala source)
2024.01.24 12:19:33 INFO  time: compiled root in 0.14s
2024.01.24 12:19:34 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
2024.01.24 12:19:36 INFO  compiling root (1 scala source)
2024.01.24 12:19:36 INFO  time: compiled root in 0.56s
2024.01.24 12:19:36 INFO  compiling root (1 scala source)
2024.01.24 12:19:36 INFO  time: compiled root in 90ms
2024.01.24 12:19:40 INFO  compiling root (2 scala sources)
2024.01.24 12:19:40 INFO  time: compiled root in 42ms
2024.01.24 12:19:42 INFO  compiling root (2 scala sources)
2024.01.24 12:19:42 INFO  time: compiled root in 0.77s
2024.01.24 12:19:42 INFO  compiling root (1 scala source)
2024.01.24 12:19:42 INFO  time: compiled root in 74ms
2024.01.24 12:19:43 INFO  compiling root (2 scala sources)
2024.01.24 12:19:43 INFO  time: compiled root in 0.4s
2024.01.24 12:19:43 INFO  compiling root (1 scala source)
2024.01.24 12:19:43 INFO  time: compiled root in 84ms
2024.01.24 12:19:44 INFO  compiling root (3 scala sources)
2024.01.24 12:19:44 INFO  time: compiled root in 0.92s
ene 24, 2024 12:20:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 147
ene 24, 2024 12:20:16 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 152
ene 24, 2024 12:20:16 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 157
ene 24, 2024 12:20:17 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 162
2024.01.24 12:23:31 INFO  compiling root (1 scala source)
2024.01.24 12:23:31 INFO  time: compiled root in 0.19s
2024.01.24 12:23:34 INFO  compiling root (1 scala source)
2024.01.24 12:23:34 INFO  time: compiled root in 0.49s
2024.01.24 12:23:41 INFO  compiling root (1 scala source)
2024.01.24 12:23:41 INFO  time: compiled root in 0.48s
2024.01.24 12:23:41 INFO  compiling root (2 scala sources)
2024.01.24 12:23:41 INFO  time: compiled root in 0.14s
2024.01.24 12:23:41 INFO  compiling root (2 scala sources)
2024.01.24 12:23:41 INFO  time: compiled root in 28ms
2024.01.24 12:24:15 INFO  compiling root (2 scala sources)
2024.01.24 12:24:15 INFO  time: compiled root in 41ms
2024.01.24 12:24:20 INFO  compiling root (2 scala sources)
2024.01.24 12:24:20 INFO  time: compiled root in 48ms
2024.01.24 12:24:43 INFO  compiling root (3 scala sources)
2024.01.24 12:24:43 INFO  time: compiled root in 64ms
2024.01.24 12:24:43 INFO  compiling root (3 scala sources)
2024.01.24 12:24:43 INFO  time: compiled root in 32ms
ene 24, 2024 12:24:49 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set3.foreach(Set.scala:261)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 24, 2024 12:24:49 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set3.foreach(Set.scala:261)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

2024.01.24 12:24:53 INFO  compiling root (3 scala sources)
2024.01.24 12:24:53 INFO  time: compiled root in 55ms
2024.01.24 12:24:53 INFO  compiling root (2 scala sources)
2024.01.24 12:24:53 INFO  time: compiled root in 88ms
2024.01.24 12:24:53 INFO  compiling root (2 scala sources)
2024.01.24 12:24:53 INFO  time: compiled root in 87ms
2024.01.24 12:24:59 INFO  compiling root (2 scala sources)
2024.01.24 12:24:59 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunEx1.scala
2024.01.24 12:24:59 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunEx1.scala
2024.01.24 12:24:59 INFO  time: compiled root in 0.51s
2024.01.24 12:25:20 INFO  compiling root (1 scala source)
2024.01.24 12:25:20 INFO  time: compiled root in 77ms
2024.01.24 12:25:20 INFO  compiling root (2 scala sources)
2024.01.24 12:25:20 INFO  time: compiled root in 72ms
2024.01.24 12:25:20 INFO  compiling root (2 scala sources)
2024.01.24 12:25:20 INFO  time: compiled root in 64ms
2024.01.24 12:25:24 INFO  compiling root (2 scala sources)
2024.01.24 12:25:24 INFO  time: compiled root in 0.51s
2024.01.24 12:27:16 INFO  compiling root (1 scala source)
2024.01.24 12:27:16 INFO  time: compiled root in 0.45s
2024.01.24 12:27:16 INFO  compiling root (1 scala source)
2024.01.24 12:27:16 INFO  time: compiled root in 49ms
2024.01.24 12:27:18 INFO  compiling root (1 scala source)
2024.01.24 12:27:18 INFO  time: compiled root in 42ms
2024.01.24 12:27:20 INFO  compiling root (1 scala source)
2024.01.24 12:27:20 INFO  time: compiled root in 0.44s
2024.01.24 12:27:20 INFO  compiling root (1 scala source)
2024.01.24 12:27:20 INFO  time: compiled root in 52ms
2024.01.24 12:27:27 INFO  compiling root (2 scala sources)
2024.01.24 12:27:27 INFO  time: compiled root in 97ms
2024.01.24 12:27:27 INFO  compiling root (2 scala sources)
2024.01.24 12:27:27 INFO  time: compiled root in 67ms
ene 24, 2024 12:30:07 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 24, 2024 12:30:07 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 24, 2024 12:31:11 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set1.foreach(Set.scala:177)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 24, 2024 12:31:11 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set1.foreach(Set.scala:177)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:104)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 24, 2024 12:31:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 674
2024.01.24 12:31:26 INFO  compiling root (2 scala sources)
2024.01.24 12:31:26 INFO  time: compiled root in 0.1s
2024.01.24 12:31:26 INFO  compiling root (2 scala sources)
2024.01.24 12:31:26 INFO  time: compiled root in 66ms
2024.01.24 12:31:32 INFO  compiling root (2 scala sources)
2024.01.24 12:31:32 INFO  time: compiled root in 0.11s
2024.01.24 12:31:32 INFO  compiling root (2 scala sources)
2024.01.24 12:31:32 INFO  time: compiled root in 68ms
2024.01.24 12:31:35 INFO  compiling root (2 scala sources)
2024.01.24 12:31:35 INFO  time: compiled root in 81ms
2024.01.24 12:31:53 WARN  Using indexes to guess the definition of Directory
ene 24, 2024 12:31:55 P. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-24\r_compiler-error_(scala-projects-build)_12-31-55-704.md
Exception in thread "pool-6-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Exception in thread "pool-6-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:31:55 INFO  compiling root (2 scala sources)
2024.01.24 12:31:55 INFO  time: compiled root in 92ms
2024.01.24 12:31:59 INFO  compiling root (2 scala sources)
2024.01.24 12:31:59 INFO  time: compiled root in 95ms
2024.01.24 12:32:10 INFO  compiling root (2 scala sources)
2024.01.24 12:32:10 INFO  time: compiled root in 96ms
2024.01.24 12:34:24 INFO  compiling root (2 scala sources)
2024.01.24 12:34:24 INFO  time: compiled root in 45ms
2024.01.24 12:34:25 WARN  Using indexes to guess the definition of soup
2024.01.24 12:34:26 WARN  Using indexes to guess the definition of mainMenu
2024.01.24 12:34:27 INFO  compiling root (2 scala sources)
2024.01.24 12:34:27 INFO  time: compiled root in 39ms
2024.01.24 12:34:50 INFO  compiling root (2 scala sources)
2024.01.24 12:34:50 INFO  time: compiled root in 57ms
ene 24, 2024 12:34:51 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:150)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

ene 24, 2024 12:34:51 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
java.nio.file.NoSuchFileException: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\Ex1.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3268)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:415)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:242)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:253)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:264)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:168)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:168)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.pc.MetalsGlobal.symbolDocumentation(MetalsGlobal.scala:234)
	at scala.meta.internal.pc.Signatures$SignaturePrinter.<init>(Signatures.scala:276)
	at scala.meta.internal.pc.HoverProvider.toHover(HoverProvider.scala:245)
	at scala.meta.internal.pc.HoverProvider.hoverOffset(HoverProvider.scala:150)
	at scala.meta.internal.pc.HoverProvider.hover(HoverProvider.scala:22)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$hover$1(ScalaPresentationCompiler.scala:331)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:146)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withNonInterruptableCompiler$1(CompilerAccess.scala:132)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:232)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)

2024.01.24 12:34:52 WARN  Using indexes to guess the definition of addChild
2024.01.24 12:34:53 WARN  Using indexes to guess the definition of addChild
2024.01.24 12:34:54 INFO  compiling root (2 scala sources)
2024.01.24 12:34:54 INFO  time: compiled root in 39ms
2024.01.24 12:35:00 WARN  Using indexes to guess the definition of addChild
2024.01.24 12:35:07 WARN  Using indexes to guess the definition of pasta
2024.01.24 12:35:07 INFO  compiling root (2 scala sources)
2024.01.24 12:35:07 INFO  time: compiled root in 43ms
2024.01.24 12:35:12 WARN  Using indexes to guess the definition of getPrice
2024.01.24 12:35:13 WARN  Using indexes to guess the definition of mainMenu
2024.01.24 12:35:13 INFO  compiling root (2 scala sources)
2024.01.24 12:35:13 INFO  time: compiled root in 45ms
2024.01.24 12:35:37 INFO  compiling root (2 scala sources)
2024.01.24 12:35:37 INFO  time: compiled root in 45ms
2024.01.24 12:35:53 INFO  compiling root (2 scala sources)
2024.01.24 12:35:53 INFO  time: compiled root in 0.23s
2024.01.24 12:35:58 WARN  Using indexes to guess the definition of SingleItem
2024.01.24 12:35:58 INFO  compiling root (2 scala sources)
2024.01.24 12:35:58 WARN  Using indexes to guess the definition of dessert
2024.01.24 12:35:58 INFO  time: compiled root in 79ms
Exception in thread "pool-6-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:36:00 INFO  compiling root (2 scala sources)
2024.01.24 12:36:00 INFO  time: compiled root in 77ms
2024.01.24 12:36:08 WARN  Using indexes to guess the definition of soup
2024.01.24 12:36:10 INFO  compiling root (2 scala sources)
2024.01.24 12:36:10 INFO  time: compiled root in 71ms
2024.01.24 12:36:44 WARN  Using indexes to guess the definition of SingleItem
2024.01.24 12:36:45 WARN  Using indexes to guess the definition of pasta
2024.01.24 12:36:49 INFO  compiling root (2 scala sources)
2024.01.24 12:36:49 INFO  time: compiled root in 76ms
2024.01.24 12:36:49 WARN  Using indexes to guess the definition of SingleItem
2024.01.24 12:37:02 INFO  compiling root (2 scala sources)
2024.01.24 12:37:02 INFO  time: compiled root in 70ms
2024.01.24 12:37:05 INFO  compiling root (2 scala sources)
2024.01.24 12:37:05 INFO  time: compiled root in 68ms
Exception in thread "pool-6-thread-4" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:37:11 WARN  Using indexes to guess the definition of dessert
2024.01.24 12:37:16 WARN  Using indexes to guess the definition of dessert
2024.01.24 12:37:16 WARN  Using indexes to guess the definition of steak
2024.01.24 12:37:16 INFO  compiling root (2 scala sources)
2024.01.24 12:37:16 INFO  time: compiled root in 81ms
2024.01.24 12:38:42 WARN  Using indexes to guess the definition of SingleItem
2024.01.24 12:38:43 WARN  Using indexes to guess the definition of SingleItem
2024.01.24 12:38:47 WARN  Using indexes to guess the definition of appetizersCategory
2024.01.24 12:38:47 WARN  Using indexes to guess the definition of pastaSauce
2024.01.24 12:38:50 INFO  compiling root (2 scala sources)
2024.01.24 12:38:50 INFO  time: compiled root in 70ms
2024.01.24 12:38:52 INFO  compiling root (2 scala sources)
2024.01.24 12:38:52 INFO  time: compiled root in 71ms
2024.01.24 12:38:57 INFO  compiling root (2 scala sources)
2024.01.24 12:38:57 INFO  time: compiled root in 70ms
2024.01.24 12:39:03 INFO  compiling root (2 scala sources)
2024.01.24 12:39:03 INFO  time: compiled root in 74ms
2024.01.24 12:39:03 WARN  Using indexes to guess the definition of SingleItem
2024.01.24 12:39:07 INFO  compiling root (2 scala sources)
2024.01.24 12:39:07 INFO  time: compiled root in 70ms
2024.01.24 12:39:13 INFO  compiling root (2 scala sources)
2024.01.24 12:39:13 INFO  time: compiled root in 85ms
2024.01.24 12:39:17 INFO  compiling root (2 scala sources)
2024.01.24 12:39:17 INFO  time: compiled root in 69ms
2024.01.24 12:39:24 INFO  compiling root (2 scala sources)
2024.01.24 12:39:24 INFO  time: compiled root in 0.52s
2024.01.24 12:39:28 INFO  compiling root (1 scala source)
2024.01.24 12:39:28 INFO  time: compiled root in 0.37s
2024.01.24 12:39:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:40 INFO  compiling root (1 scala source)
2024.01.24 12:39:40 INFO  time: compiled root in 35ms
2024.01.24 12:39:41 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:42 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:43 INFO  compiling root (1 scala source)
2024.01.24 12:39:43 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:43 INFO  time: compiled root in 44ms
2024.01.24 12:39:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:46 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:48 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:49 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:50 INFO  compiling root (1 scala source)
2024.01.24 12:39:50 INFO  time: compiled root in 0.37s
2024.01.24 12:39:51 INFO  compiling root (1 scala source)
2024.01.24 12:39:51 INFO  time: compiled root in 0.37s
2024.01.24 12:39:58 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
Exception in thread "pool-6-thread-5" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.24 12:39:58 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:58 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:58 INFO  compiling root (1 scala source)
2024.01.24 12:39:58 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:58 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:58 INFO  time: compiled root in 45ms
2024.01.24 12:39:58 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:58 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:39:58 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:40:12 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:40:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:40:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:40:16 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:40:18 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:40:19 INFO  compiling root (1 scala source)
2024.01.24 12:40:20 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:40:19 INFO  time: compiled root in 0.38s
2024.01.24 12:40:24 INFO  compiling root (1 scala source)
2024.01.24 12:40:24 INFO  time: compiled root in 0.36s
2024.01.24 12:40:26 INFO  compiling root (1 scala source)
2024.01.24 12:40:26 INFO  time: compiled root in 0.37s
2024.01.24 12:40:30 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:40:30 INFO  compiling root (1 scala source)
2024.01.24 12:40:30 INFO  time: compiled root in 0.38s
2024.01.24 12:40:41 INFO  compiling root (1 scala source)
2024.01.24 12:40:41 INFO  time: compiled root in 0.51s
2024.01.24 12:40:44 INFO  compiling root (1 scala source)
2024.01.24 12:40:44 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:40:44 INFO  time: compiled root in 0.37s
2024.01.24 12:40:55 INFO  compiling root (1 scala source)
2024.01.24 12:40:55 INFO  time: compiled root in 0.37s
2024.01.24 12:40:59 INFO  compiling root (1 scala source)
2024.01.24 12:40:59 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:40:59 INFO  time: compiled root in 0.37s
2024.01.24 12:41:01 INFO  compiling root (1 scala source)
2024.01.24 12:41:01 INFO  time: compiled root in 0.38s
2024.01.24 12:41:15 INFO  compiling root (1 scala source)
2024.01.24 12:41:15 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:41:15 INFO  time: compiled root in 0.36s
2024.01.24 12:41:18 INFO  compiling root (1 scala source)
2024.01.24 12:41:18 WARN  Using indexes to guess the definition of addChild
2024.01.24 12:41:18 INFO  time: compiled root in 0.39s
2024.01.24 12:41:29 INFO  compiling root (1 scala source)
2024.01.24 12:41:29 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:41:29 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:41:29 INFO  time: compiled root in 0.38s
2024.01.24 12:41:32 INFO  compiling root (1 scala source)
2024.01.24 12:41:32 INFO  time: compiled root in 0.36s
2024.01.24 12:41:35 INFO  compiling root (1 scala source)
2024.01.24 12:41:35 INFO  time: compiled root in 0.35s
2024.01.24 12:41:41 INFO  compiling root (1 scala source)
2024.01.24 12:41:41 INFO  time: compiled root in 0.36s
2024.01.24 12:41:57 INFO  compiling root (1 scala source)
2024.01.24 12:41:57 INFO  time: compiled root in 0.51s
ene 24, 2024 12:42:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2212
2024.01.24 12:42:06 INFO  compiling root (1 scala source)
2024.01.24 12:42:06 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:42:06 INFO  time: compiled root in 0.37s
2024.01.24 12:42:09 INFO  compiling root (1 scala source)
2024.01.24 12:42:09 INFO  time: compiled root in 0.36s
2024.01.24 12:42:11 INFO  compiling root (1 scala source)
2024.01.24 12:42:11 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\composite\RunMenu.scala
2024.01.24 12:42:11 INFO  time: compiled root in 0.37s
2024.01.24 12:43:31 INFO  compiling root (1 scala source)
2024.01.24 12:43:31 INFO  time: compiled root in 0.38s
2024.01.24 12:43:34 INFO  compiling root (1 scala source)
2024.01.24 12:43:34 INFO  time: compiled root in 0.39s
2024.01.24 12:44:04 INFO  compiling root (1 scala source)
2024.01.24 12:44:04 INFO  time: compiled root in 0.38s
2024.01.24 12:44:26 INFO  compiling root-test (1 scala source)
2024.01.24 12:44:26 INFO  time: compiled root-test in 0.57s
2024.01.24 12:44:28 INFO  compiling root-test (1 scala source)
2024.01.24 12:44:28 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.24 12:44:28 INFO  time: compiled root-test in 0.21s
2024.01.24 12:44:38 INFO  compiling root-test (1 scala source)
2024.01.24 12:44:38 INFO  time: compiled root-test in 0.56s
2024.01.24 12:44:42 INFO  compiling root-test (1 scala source)
2024.01.24 12:44:42 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala
2024.01.24 12:44:42 INFO  time: compiled root-test in 0.6s
2024.01.24 12:44:50 INFO  compiling root-test (1 scala source)
2024.01.24 12:44:50 INFO  time: compiled root-test in 0.17s
2024.01.24 12:44:54 INFO  compiling root-test (1 scala source)
2024.01.24 12:44:54 INFO  time: compiled root-test in 0.73s
ene 24, 2024 12:44:58 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.01.24 12:46:12 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
ene 24, 2024 12:46:16 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.01.24 13:26:04 INFO  compiling root-test (1 scala source)
2024.01.24 13:26:04 INFO  time: compiled root-test in 99ms
ene 24, 2024 1:26:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2604
ene 24, 2024 1:26:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2607
ene 24, 2024 1:26:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2610
ene 24, 2024 1:26:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2624
ene 24, 2024 1:26:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2625
2024.01.24 13:58:54 INFO  Shutting down server
2024.01.24 13:58:54 INFO  shutting down Metals
2024.01.24 13:58:54 INFO  Shut down connection with build server.
2024.01.24 13:58:54 INFO  Shut down connection with build server.
2024.01.24 13:58:54 INFO  Exiting server
2024.01.25 11:19:25 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.25 11:19:26 INFO  Attempting to connect to the build server...
2024.01.25 11:19:26 INFO  skipping build import with status 'Failed'
2024.01.25 11:19:26 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
ene 25, 2024 11:19:28 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10
2024.01.25 11:19:30 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.25 11:19:31 WARN  no build target for: C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\java\interfaces\DistributionPolicy.java
2024.01.25 11:19:32 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.25 11:19:32 INFO  Attempting to connect to the build server...
2024.01.25 11:19:32 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
ene 25, 2024 11:19:32 A. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-25\r_compiler-error_11-19-32-883.md
2024.01.25 11:19:32 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.25 11:19:32 INFO  time: Connected to build server in 6.21s
2024.01.25 11:19:32 INFO  Connected to Build server: Bloop v1.5.13
2024.01.25 11:19:33 INFO  time: Imported build in 0.14s
ene 25, 2024 11:19:33 A. M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\.reports\metals-full\2024-01-25\r_compiler-error_11-19-33-991.md
2024.01.25 11:19:36 INFO  time: indexed workspace in 3.18s
2024.01.25 11:19:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:19:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
ene 25, 2024 11:19:40 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 41
2024.01.25 11:19:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:19:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
ene 25, 2024 11:19:42 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 51
ene 25, 2024 11:19:42 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 52
2024.01.25 11:19:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:19:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:19:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:19:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:19:59 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:19:59 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:28:44 INFO  compiling root (1 scala source and 7 java sources)
2024.01.25 11:28:45 INFO  time: compiled root in 1.55s
2024.01.25 11:28:47 INFO  compiling root (1 scala source and 7 java sources)
2024.01.25 11:28:47 INFO  time: compiled root in 0.48s
2024.01.25 11:28:52 INFO  compiling root (1 scala source and 7 java sources)
2024.01.25 11:28:52 INFO  time: compiled root in 0.45s
2024.01.25 11:28:57 INFO  compiling root (1 scala source and 7 java sources)
2024.01.25 11:28:57 INFO  time: compiled root in 0.33s
2024.01.25 11:33:48 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:33:49 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:33:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:33:51 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:43:36 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.25 11:44:43 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1583)
```

ene 25, 2024 11:44:43 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.Preconditions;\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n        this.hashIsZero \u003d original.hashIsZero;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char[] value) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char[] value, int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link Charset}, charset name,\n     * or that use the {@link Charset#defaultCharset() default charset}.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte[] ascii, int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * This method does not do any precondition checks on its arguments.\n     * \u003cp\u003e\n     * Important: parameter order of this method is deliberately changed in order to\n     * disambiguate it against other similar methods of this class.\n     */\n    @SuppressWarnings(\"removal\")\n    private String(Charset charset, byte[] bytes, int offset, int length) {\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                int dp \u003d StringCoding.countPositives(bytes, offset, length);\n                if (dp \u003d\u003d length) {\n                    this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                int sl \u003d offset + length;\n                byte[] dst \u003d new byte[length];\n                if (dp \u003e 0) {\n                    System.arraycopy(bytes, offset, dst, 0, dp);\n                    offset +\u003d dp;\n                }\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset++];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte)b1;\n                        continue;\n                    }\n                    if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                        int b2 \u003d bytes[offset];\n                        if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                            dst[dp++] \u003d (byte)decode2(b1, b2);\n                            offset++;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    offset--;\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            } else { // !COMPACT_STRINGS\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen;\n            try {\n                caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            } catch (CharacterCodingException x) {\n                // Substitution is enabled, so this shouldn\u0027t happen\n                throw new Error(x);\n            }\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     *\n     * @param  noShare\n     *         {@code true} if the resulting string MUST NOT share the byte array,\n     *         {@code false} if the byte array can be exclusively used to construct\n     *         the string and is not modified or used for any other purpose.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int dp;\n        byte[] dst;\n        if (COMPACT_STRINGS) {\n            dp \u003d StringCoding.countPositives(bytes, offset, length);\n            int sl \u003d offset + length;\n            if (dp \u003d\u003d length) {\n                if (noShare || length !\u003d bytes.length) {\n                    return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n                } else {\n                    return new String(bytes, LATIN1);\n                }\n            }\n            dst \u003d new byte[length];\n            System.arraycopy(bytes, offset, dst, 0, dp);\n            offset +\u003d dp;\n            while (offset \u003c sl) {\n                int b1 \u003d bytes[offset++];\n                if (b1 \u003e\u003d 0) {\n                    dst[dp++] \u003d (byte)b1;\n                    continue;\n                }\n                if ((b1 \u0026 0xfe) \u003d\u003d 0xc2 \u0026\u0026 offset \u003c sl) { // b1 either 0xc2 or 0xc3\n                    int b2 \u003d bytes[offset];\n                    if (b2 \u003c -64) { // continuation bytes are always negative values in the range -128 to -65\n                        dst[dp++] \u003d (byte)decode2(b1, b2);\n                        offset++;\n                        continue;\n                    }\n                }\n                // anything not a latin1, including the REPL\n                // we have to go with the utf16\n                offset--;\n                break;\n            }\n            if (offset \u003d\u003d sl) {\n                if (dp !\u003d dst.length) {\n                    dst \u003d Arrays.copyOf(dst, dp);\n                }\n                return new String(dst, LATIN1);\n            }\n            if (dp \u003d\u003d 0) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n        } else { // !COMPACT_STRINGS\n            dst \u003d new byte[length \u003c\u003c 1];\n            dp \u003d decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n        }\n        if (dp !\u003d length) {\n            dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n        }\n        return new String(dst, UTF16);\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen;\n        try {\n            caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        } catch (CharacterCodingException x) {\n            // throw via IAE\n            throw new IllegalArgumentException(x);\n        }\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        // fastpath with ArrayEncoder implies `doReplace`.\n        if (doReplace \u0026\u0026 ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return val.clone();\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            int positives \u003d StringCoding.countPositives(val, 0, val.length);\n            byte[] dst \u003d val.clone();\n            if (positives \u003c dst.length) {\n                replaceNegatives(dst, positives);\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static void replaceNegatives(byte[] val, int fromIndex) {\n        for (int i \u003d fromIndex; i \u003c val.length; i++) {\n            if (val[i] \u003c 0) {\n                val[i] \u003d \u0027?\u0027;\n            }\n        }\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return val.clone();\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        int count \u003d StringCoding.countPositives(sa, sp, len);\n        while (count \u003c len) {\n            if (sa[sp + count] \u003c 0) {\n                break;\n            }\n            count++;\n        }\n        StringLatin1.inflate(sa, sp, da, dp, count);\n        return count;\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n                                            throws CharacterCodingException {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        CoderResult cr \u003d cd.decode(bb, cb, true);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        cr \u003d cd.flush(cb);\n        if (!cr.isUnderflow())\n            cr.throwException();\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d StringCoding.countPositives(val, 0, val.length);\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16) {\n            return encodeUTF8_UTF16(val, doReplace);\n        }\n\n        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n            return val.clone();\n        }\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        while (sp \u003c sl) {\n            // ascii fast loop;\n            char c \u003d StringUTF16.getChar(val, sp);\n            if (c \u003e\u003d \u0027\\u0080\u0027) {\n                break;\n            }\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            char c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, String charsetName)\n            throws UnsupportedEncodingException {\n        this(lookupCharset(charsetName), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte[] bytes, Charset charset) {\n        this(Objects.requireNonNull(charset), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the {@link Charset#defaultCharset() default charset}.\n     * The length of the new {@code String} is a function of the charset,\n     * and hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(Charset.defaultCharset(), bytes, checkBoundsOffCount(offset, length, bytes.length), length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the {@link Charset#defaultCharset() default charset}. The length\n     * of the new {@code String} is a function of the charset, and hence may not\n     * be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(Charset.defaultCharset(), bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        checkIndex(i, length());\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        Objects.checkFromToIndex(beginIndex, endIndex, length());\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger than the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the {@link Charset#defaultCharset()\n     * default charset}.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * {@link Charset#defaultCharset() default charset}, storing the result\n     * into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            return v1.length \u003c\u003d v2.length \u0026\u0026 ArraysSupport.mismatch(v1, v2, v1.length) \u003c 0;\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte[] v1 \u003d value;\n        byte[] v2 \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte[] v1 \u003d s1.value;\n            byte[] v2 \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n                ooffset \u003c\u003c\u003d UTF16;\n                len \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(tv, toffset,\n                    ov, ooffset, len) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte[] tv \u003d value;\n        byte[] ov \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte[] ta \u003d value;\n        byte[] pa \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            if (coder \u003d\u003d UTF16) {\n                toffset \u003c\u003c\u003d UTF16;\n            }\n            return ArraysSupport.mismatch(ta, toffset,\n                    pa, 0, pc) \u003c 0;\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code ch} in the string.\n     * If stricter behavior is needed, {@link #indexOf(int, int, int)}\n     * should be considered instead.\n     * On a {@link String} {@code s}, for example,\n     * {@code s.indexOf(ch, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, length())\n                : StringUTF16.indexOf(value, ch, fromIndex, length());\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at {@code beginIndex} and\n     * stopping before {@code endIndex}.\n     *\n     * \u003cp\u003eIf a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code beginIndex} but smaller than\n     * {@code endIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) \u0026amp;\u0026amp; (beginIndex \u0026lt;\u003d \u003ci\u003ek\u003c/i\u003e \u0026lt; endIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code beginIndex} and before position\n     * {@code endIndex}, then {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code beginIndex} and less than {@code endIndex},\n     *          or {@code -1} if the character does not occur.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(int ch, int beginIndex, int endIndex) {\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return isLatin1() ? StringLatin1.indexOf(value, ch, beginIndex, endIndex)\n                : StringUTF16.indexOf(value, ch, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @apiNote\n     * Unlike {@link #substring(int)}, for example, this method does not throw\n     * an exception when {@code fromIndex} is outside the valid range.\n     * Rather, it returns -1 when {@code fromIndex} is larger than the length of\n     * the string.\n     * This result is, by itself, indistinguishable from a genuine absence of\n     * {@code str} in the string.\n     * If stricter behavior is needed, {@link #indexOf(String, int, int)}\n     * should be considered instead.\n     * On {@link String} {@code s} and a non-empty {@code str}, for example,\n     * {@code s.indexOf(str, fromIndex, s.length())} would throw if\n     * {@code fromIndex} were larger than the string length, or were negative.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified substring\n     * within the specified index range of {@code this} string.\n     *\n     * \u003cp\u003eThis method returns the same result as the one of the invocation\n     * \u003cpre\u003e{@code\n     *     s.substring(beginIndex, endIndex).indexOf(str) + beginIndex\n     * }\u003c/pre\u003e\n     * if the index returned by {@link #indexOf(String)} is non-negative,\n     * and returns -1 otherwise.\n     * (No substring is instantiated, though.)\n     *\n     * @param   str         the substring to search for.\n     * @param   beginIndex  the index to start the search from (included).\n     * @param   endIndex    the index to stop the search at (excluded).\n     * @return  the index of the first occurrence of the specified substring\n     *          within the specified index range,\n     *          or {@code -1} if there is no such occurrence.\n     * @throws  StringIndexOutOfBoundsException if {@code beginIndex}\n     *          is negative, or {@code endIndex} is larger than the length of\n     *          this {@code String} object, or {@code beginIndex} is larger than\n     *          {@code endIndex}.\n     * @since   21\n     */\n    public int indexOf(String str, int beginIndex, int endIndex) {\n        if (str.length() \u003d\u003d 1) {\n            /* Simple optimization, can be omitted without behavioral impact */\n            return indexOf(str.charAt(0), beginIndex, endIndex);\n        }\n        checkBoundsBeginEnd(beginIndex, endIndex, length());\n        return indexOf(value, coder(), endIndex, str, beginIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  last index (exclusive) in the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        fromIndex \u003d Math.clamp(fromIndex, 0, srcCount);\n        int tgtCount \u003d tgtStr.length();\n        if (tgtCount \u003e srcCount - fromIndex) {\n            return -1;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        return split(regex, limit, false);\n    }\n\n    /**\n     * Splits this string around matches of the given regular expression and\n     * returns both the strings and the matching delimiters.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.\n     * Each substring is immediately followed by the subsequence (the delimiter)\n     * that matches the given expression, \u003cem\u003eexcept\u003c/em\u003e for the last\n     * substring, which is not followed by anything.\n     * The substrings in the array and the delimiters are in the order in which\n     * they occur in the input.\n     * If the expression does not match any part of the input then the resulting\n     * array has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring nor the empty delimiter.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than 2 \u0026times; \u003ci\u003elimit\u003c/i\u003e - 1, and the array\u0027s last\n     *    entry will contain all input beyond the last matched delimiter.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/li\u003e\n     *\n     *    \u003cli\u003e If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The input {@code \"boo:::and::foo\"}, for example, yields the following\n     * results with these parameters:\n     *\n     * \u003ctable class\u003d\"plain\" style\u003d\"margin-left:2em;\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:+\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and::foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \":::\", \"and\", \"::\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-1\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"o\", \"\", \"o\", \":::and::f\", \"o\", \"\", \"o\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @apiNote An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code splitWithDelimiters(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#splitWithDelimiters(CharSequence,int) splitWithDelimiters}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression, alternating\n     *          substrings and matching delimiters\n     *\n     * @since   21\n     */\n    public String[] splitWithDelimiters(String regex, int limit) {\n        return split(regex, limit, true);\n    }\n\n    private String[] split(String regex, int limit, boolean withDelimiters) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n                \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n                (regex.length() \u003d\u003d 2 \u0026\u0026\n                        regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n                        (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n                        ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n                (ch \u003c Character.MIN_HIGH_SURROGATE ||\n                        ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            // All the checks above can potentially be constant folded by\n            // a JIT/AOT compiler when the regex is a constant string.\n            // That requires method inlining of the checks, which is only\n            // possible when the actual split logic is in a separate method\n            // because the large split loop can usually not be inlined.\n            return split(ch, limit, withDelimiters);\n        }\n        Pattern pattern \u003d Pattern.compile(regex);\n        return withDelimiters\n                ? pattern.splitWithDelimiters(this, limit)\n                : pattern.split(this, limit);\n    }\n\n    private String[] split(char ch, int limit, boolean withDelimiters) {\n        int matchCount \u003d 0;\n        int off \u003d 0;\n        int next;\n        boolean limited \u003d limit \u003e 0;\n        ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n        String del \u003d withDelimiters ? String.valueOf(ch) : null;\n        while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n            if (!limited || matchCount \u003c limit - 1) {\n                list.add(substring(off, next));\n                if (withDelimiters) {\n                    list.add(del);\n                }\n                off \u003d next + 1;\n                ++matchCount;\n            } else {    // last one\n                int last \u003d length();\n                list.add(substring(off, last));\n                off \u003d last;\n                ++matchCount;\n                break;\n            }\n        }\n        // If no match was found, return this\n        if (off \u003d\u003d 0)\n            return new String[] {this};\n\n        // Add remaining segment\n        if (!limited || matchCount \u003c limit)\n            list.add(substring(off, length()));\n\n        // Construct result\n        int resultSize \u003d list.size();\n        if (limit \u003d\u003d 0) {\n            while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                resultSize--;\n            }\n        }\n        String[] result \u003d new String[resultSize];\n        return list.subList(0, resultSize).toArray(result);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0, false);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop will add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of lowercase mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toLowerCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting {@code String}\n     * and this {@code String} may differ in length.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     *\n     * @apiNote This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a {@linkplain\n     * Character##unicode surrogate code point} is passed through\n     * uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char[] data, int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char[] data) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        repeatCopyRest(multiple, 0, limit, len);\n        return new String(multiple, coder);\n    }\n\n    /**\n     * Used to perform copying after the initial insertion. Copying is optimized\n     * by using power of two duplication. First pass duplicates original copy,\n     * second pass then duplicates the original and the copy yielding four copies,\n     * third pass duplicates four copies yielding eight copies, and so on.\n     * Finally, the remainder is filled in with prior copies.\n     *\n     * @implNote The technique used here is significantly faster than hand-rolled\n     * loops or special casing small numbers due to the intensive optimization\n     * done by intrinsic {@code System.arraycopy}.\n     *\n     * @param buffer    destination buffer\n     * @param offset    offset in the destination buffer\n     * @param limit     total replicated including what is already in the buffer\n     * @param copied    number of bytes that have already in the buffer\n     */\n    static void repeatCopyRest(byte[] buffer, int offset, int limit, int copied) {\n        // Initial copy is in the buffer.\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            // Power of two duplicate.\n            System.arraycopy(buffer, offset, buffer, offset + copied, copied);\n        }\n        // Duplicate remainder.\n        System.arraycopy(buffer, offset, buffer, offset + copied, limit - copied);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            // only try to compress val if some characters were deleted.\n            if (COMPACT_STRINGS \u0026\u0026 asb.maybeLatin1) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @return  {@code offset} if the sub-range within bounds of the range\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static int checkBoundsOffCount(int offset, int count, int length) {\n        return Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 25, 2024 11:44:43 A. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-21/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-21/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

ene 25, 2024 12:08:05 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.01.25 12:09:47 INFO  Shutting down server
2024.01.25 12:09:47 INFO  shutting down Metals
2024.01.25 12:09:47 INFO  Shut down connection with build server.
2024.01.25 12:09:47 INFO  Shut down connection with build server.
2024.01.25 12:09:47 INFO  Exiting server
2024.01.25 12:14:04 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.25 12:14:05 INFO  Attempting to connect to the build server...
2024.01.25 12:14:05 INFO  skipping build import with status 'Failed'
2024.01.25 12:14:05 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.25 12:14:05 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.25 12:14:05 INFO  Attempting to connect to the build server...
2024.01.25 12:14:05 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.25 12:14:05 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.25 12:14:05 INFO  time: Connected to build server in 0.41s
2024.01.25 12:14:05 INFO  Connected to Build server: Bloop v1.5.13
2024.01.25 12:14:09 INFO  time: indexed workspace in 3.41s
2024.01.25 12:14:25 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.25 12:14:25 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.25 12:14:25 INFO  Starting debug proxy for [test.scala.Tests(word count test)]
2024.01.25 12:14:26 INFO  Trying to attach to remote debuggee VM 127.0.0.1:63020 .
2024.01.25 12:14:26 INFO  Attaching to debuggee VM succeeded.
2024.01.25 12:14:27 INFO  Canceling debug proxy for [test.scala.Tests(word count test)]
2024.01.25 12:14:26 INFO  Closing debug server tcp://0.0.0.0:63016
Exception in thread "pool-4-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2024.01.25 12:14:51 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.25 12:14:51 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.25 12:14:51 INFO  Starting debug proxy for [test.scala.Tests(word count test)]
2024.01.25 12:14:51 INFO  Trying to attach to remote debuggee VM 127.0.0.1:63028 .
2024.01.25 12:14:51 INFO  Attaching to debuggee VM succeeded.
2024.01.25 12:14:52 INFO  Canceling debug proxy for [test.scala.Tests(word count test)]
2024.01.25 12:14:51 INFO  Closing debug server tcp://0.0.0.0:63025
2024.01.25 12:15:14 INFO  compiling root-test (1 scala source)
2024.01.25 12:15:16 INFO  time: compiled root-test in 1.85s
2024.01.25 12:15:19 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.25 12:15:19 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.25 12:15:19 INFO  Starting debug proxy for [test.scala.Tests(word count test)]
2024.01.25 12:15:19 INFO  Trying to attach to remote debuggee VM 127.0.0.1:63037 .
2024.01.25 12:15:19 INFO  Attaching to debuggee VM succeeded.
2024.01.25 12:15:20 INFO  Canceling debug proxy for [test.scala.Tests(word count test)]
2024.01.25 12:15:19 INFO  Closing debug server tcp://0.0.0.0:63034
2024.01.25 12:15:33 INFO  compiling root-test (1 scala source)
2024.01.25 12:15:34 INFO  time: compiled root-test in 1.01s
2024.01.25 12:15:39 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.25 12:15:39 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.25 12:15:39 INFO  Starting debug proxy for [test.scala.Tests(word count test)]
2024.01.25 12:15:39 INFO  Trying to attach to remote debuggee VM 127.0.0.1:63048 .
2024.01.25 12:15:39 INFO  Attaching to debuggee VM succeeded.
2024.01.25 12:15:39 INFO  Canceling debug proxy for [test.scala.Tests(word count test)]
2024.01.25 12:15:39 INFO  Closing debug server tcp://0.0.0.0:63044
2024.01.25 12:46:07 INFO  Shutting down server
2024.01.25 12:46:07 INFO  shutting down Metals
2024.01.25 12:46:07 INFO  Shut down connection with build server.
2024.01.25 12:46:07 INFO  Shut down connection with build server.
2024.01.25 12:46:07 INFO  Exiting server
2024.01.26 12:39:27 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.26 12:39:28 INFO  Attempting to connect to the build server...
2024.01.26 12:39:28 INFO  skipping build import with status 'Failed'
2024.01.26 12:39:28 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.26 12:39:31 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.26 12:39:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.26 12:39:33 INFO  Attempting to connect to the build server...
2024.01.26 12:39:33 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.26 12:39:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.26 12:39:33 INFO  time: Connected to build server in 4.84s
2024.01.26 12:39:33 INFO  Connected to Build server: Bloop v1.5.13
2024.01.26 12:39:33 INFO  time: Imported build in 0.16s
2024.01.26 12:39:36 INFO  time: indexed workspace in 2.62s
2024.01.26 12:43:00 INFO  Shutting down server
2024.01.26 12:43:00 INFO  shutting down Metals
2024.01.26 12:43:00 INFO  Shut down connection with build server.
2024.01.26 12:43:00 INFO  Shut down connection with build server.
2024.01.26 12:43:00 INFO  Exiting server
2024.01.26 15:59:29 INFO  Started: Metals version 1.2.0 in folders 'C:\URV\Progra\RepositorioGitHub\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.26 15:59:31 INFO  Attempting to connect to the build server...
2024.01.26 15:59:31 INFO  skipping build import with status 'Failed'
2024.01.26 15:59:31 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.26 15:59:31 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.26 15:59:31 INFO  Attempting to connect to the build server...
2024.01.26 15:59:31 INFO  Bloop uses C:\Program Files\Java\jdk-21 defined at C:\Users\adria\.bloop\bloop.json
2024.01.26 15:59:31 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.26 15:59:31 INFO  time: Connected to build server in 0.37s
2024.01.26 15:59:31 INFO  Connected to Build server: Bloop v1.5.13
2024.01.26 15:59:31 INFO  time: Imported build in 0.12s
2024.01.26 15:59:34 INFO  no build target found for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\test\scala\Tests.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.26 15:59:36 INFO  time: indexed workspace in 2.7s
2024.01.26 16:01:29 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.26 16:01:40 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.26 16:01:43 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.26 16:01:48 INFO  compiling root (1 scala source)
2024.01.26 16:01:48 WARN  Could not load snapshot text for C:\URV\Progra\RepositorioGitHub\Scala-Projects\src\main\scala\JavaFunctions.scala
2024.01.26 16:01:51 INFO  time: compiled root in 2.66s
2024.01.26 16:08:35 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-server.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.26 16:08:35 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\URV\Progra\RepositorioGitHub\Scala-Projects\.metals\dap-client.trace.json or C:\Users\adria\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.26 16:08:35 INFO  Starting debug proxy for [test.scala.Tests()]
2024.01.26 16:08:35 INFO  Trying to attach to remote debuggee VM 127.0.0.1:54333 .
2024.01.26 16:08:35 INFO  Attaching to debuggee VM succeeded.
2024.01.26 16:08:36 INFO  Canceling debug proxy for [test.scala.Tests()]
2024.01.26 16:08:35 INFO  Closing debug server tcp://0.0.0.0:54329
ene 26, 2024 4:09:05 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 78
ene 26, 2024 4:09:05 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 80
ene 26, 2024 4:09:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 87
ene 26, 2024 4:09:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 90
ene 26, 2024 4:09:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 89
ene 26, 2024 4:09:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 91
ene 26, 2024 4:09:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 100
ene 26, 2024 4:13:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 514
2024.01.26 16:14:48 INFO  compiling root-test (1 scala source)
2024.01.26 16:14:49 INFO  time: compiled root-test in 1.46s
2024.01.26 16:14:53 INFO  compiling root-test (1 scala source)
2024.01.26 16:14:54 INFO  time: compiled root-test in 1.16s
ene 26, 2024 4:15:00 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.01.27 12:12:45 INFO  Started: Metals version 1.2.0 in folders 'C:\Users\ARNAU\Desktop\TAP\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.27 12:12:46 INFO  Attempting to connect to the build server...
2024.01.27 12:12:46 INFO  Setting up current java home C:\Program Files\Java\jdk-17 in C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 12:12:50 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\ARNAU\AppData\Local\Temp\metals17399976529270571606\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.01.27 12:12:50 ERROR [info] [launcher] getting org.scala-sbt sbt 1.9.7  (this may take some time)...
2024.01.27 12:12:50 ERROR Starting the bsp launcher for bloop...
2024.01.27 12:12:50 ERROR Opening a bsp server connection with 'bsp --protocol tcp --port 25748'...
2024.01.27 12:12:50 ERROR Waiting for the bsp connection to come up...
2024.01.27 12:12:50 ERROR Waiting for the bsp connection to come up...
2024.01.27 12:12:50 ERROR Waiting for the bsp connection to come up...
2024.01.27 12:12:50 ERROR Waiting for the bsp connection to come up...
2024.01.27 12:12:50 ERROR error: The command bsp --protocol tcp --port 25748 returned with an error
2024.01.27 12:12:50 ERROR > No server running at 127.0.0.1:8212, let's fire one...
2024.01.27 12:12:50 ERROR > Resolving ch.epfl.scala:bloop-frontend_2.12:1.5.13...
2024.01.27 12:12:50 ERROR > Starting bloop server at 127.0.0.1:8212...
2024.01.27 12:12:50 ERROR > Attempting a connection to the server...
2024.01.27 12:12:50 ERROR > Attempting a connection to the server...
2024.01.27 12:12:50 ERROR > Attempting a connection to the server...
2024.01.27 12:12:50 ERROR > Attempting a connection to the server...
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-compiler\2.13.12\scala-compiler-2.13.12.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-compiler\2.13.12\scala-compiler-2.13.12.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.12\scala-reflect-2.13.12.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.12\scala-reflect-2.13.12.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\io\github\java-diff-utils\java-diff-utils\4.12\java-diff-utils-4.12.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\io\github\java-diff-utils\java-diff-utils\4.12\java-diff-utils-4.12.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\org\jline\jline\3.22.0\jline-3.22.0.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\org\jline\jline\3.22.0\jline-3.22.0.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\net\java\dev\jna\jna\5.13.0\jna-5.13.0.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[33m[W][0m Scala instance jar C:\Users\adria\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\net\java\dev\jna\jna\5.13.0\jna-5.13.0.jar doesn't exist!
2024.01.27 12:12:50 ERROR > [0m[31m[E][0m Failed to load project from c:\Users\ARNAU\Desktop\TAP\Scala-Projects\.bloop\root.json
2024.01.27 12:12:50 ERROR error: The launcher failed to establish a bsp connection, aborting...
2024.01.27 12:12:50 ERROR Failed to connect with build server, no functionality will work.
java.lang.RuntimeException: The server did not start, got FailedToOpenBspConnection
	at bloop.launcher.LauncherMain.failPromise$1(Launcher.scala:92)
	at bloop.launcher.LauncherMain.runLauncher(Launcher.scala:119)
	at scala.meta.internal.metals.BloopServers$$anon$2.run(BloopServers.scala:501)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:842)

2024.01.27 12:12:52 ERROR [info] [launcher] getting Scala 2.12.18 (for sbt)...
2024.01.27 12:12:53 INFO  [info] welcome to sbt 1.9.7 (Oracle Corporation Java 17.0.9)
2024.01.27 12:12:55 INFO  [info] loading settings for project scala-projects-build-build from metals.sbt ...
2024.01.27 12:12:55 INFO  [info] loading project definition from C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\project
2024.01.27 12:12:57 INFO  [info] loading settings for project scala-projects-build from metals.sbt ...
2024.01.27 12:12:57 INFO  [info] loading project definition from C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project
2024.01.27 12:13:00 INFO  [success] Generated .bloop\scala-projects-build.json
2024.01.27 12:13:00 INFO  [info] compiling 1 Scala source to C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\target\scala-2.12\sbt-1.0\classes ...
2024.01.27 12:13:00 INFO  [info] Non-compiled module 'compiler-bridge_2.12' for Scala 2.12.18. Compiling...
2024.01.27 12:13:07 INFO  [info]   Compilation completed in 6.348s.
2024.01.27 12:13:07 INFO  [info] done compiling
2024.01.27 12:13:07 INFO  [success] Total time: 10 s, completed 27 ene 2024 12:13:08
2024.01.27 12:13:09 INFO  [info] loading settings for project root from build.sbt ...
2024.01.27 12:13:09 INFO  [info] set current project to P2 TAP (in build file:/C:/Users/ARNAU/Desktop/TAP/Scala-Projects/)
2024.01.27 12:13:09 INFO  [success] Generated .bloop\root.json
2024.01.27 12:13:09 INFO  [success] Generated .bloop\root-test.json
2024.01.27 12:13:09 INFO  [success] Total time: 1 s, completed 27 ene 2024 12:13:10
2024.01.27 12:13:10 INFO  time: ran 'sbt bloopInstall' in 20s
2024.01.27 12:13:10 INFO  Attempting to connect to the build server...
2024.01.27 12:13:10 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 12:13:12 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 12:13:12 INFO  Attempting to connect to the build server...
2024.01.27 12:13:12 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 12:13:12 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 12:13:12 INFO  time: Connected to build server in 2.33s
2024.01.27 12:13:12 INFO  Connected to Build server: Bloop v1.5.13
2024.01.27 12:13:19 INFO  time: indexed workspace in 6.59s
2024.01.27 12:13:25 INFO  compiling root (5 scala sources and 26 java sources)
2024.01.27 12:13:30 INFO  time: compiled root in 5.23s
2024.01.27 12:21:27 INFO  Started: Metals version 1.2.0 in folders 'C:\Users\ARNAU\Desktop\TAP\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.27 12:21:32 INFO  Attempting to connect to the build server...
2024.01.27 12:21:32 INFO  skipping build import with status 'Installed'
2024.01.27 12:21:32 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 12:21:36 INFO  no build target found for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\main\scala\JavaFunctions.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.27 12:21:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 12:21:36 INFO  Attempting to connect to the build server...
2024.01.27 12:21:36 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 12:21:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 12:21:36 INFO  time: Connected to build server in 4.47s
2024.01.27 12:21:36 INFO  Connected to Build server: Bloop v1.5.13
2024.01.27 12:21:36 INFO  time: Imported build in 0.16s
2024.01.27 12:21:41 INFO  time: indexed workspace in 4.25s
2024.01.27 12:23:58 INFO  compiling root (5 scala sources and 26 java sources)
2024.01.27 12:24:03 INFO  compiling root-test (1 scala source)
2024.01.27 12:24:03 INFO  time: compiled root in 5.47s
2024.01.27 12:24:04 INFO  time: compiled root-test in 1.28s
ene 27, 2024 12:26:09 P.M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.01.27 12:26:23 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:26:23 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:26:23 INFO  Starting debug proxy for [test.scala.Tests()]
2024.01.27 12:26:24 INFO  Trying to attach to remote debuggee VM 127.0.0.1:50623 .
2024.01.27 12:26:24 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:26:24 INFO  Canceling debug proxy for [test.scala.Tests()]
2024.01.27 12:26:24 INFO  Closing debug server tcp://0.0.0.0:50618
ene 27, 2024 12:26:28 P.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.01.27 12:26:29 WARN  no build target for: C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\project\metals.sbt
ene 27, 2024 12:28:39 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 93
2024.01.27 12:29:53 INFO  compiling root (1 scala source)
2024.01.27 12:29:53 INFO  time: compiled root in 0.68s
ene 27, 2024 12:32:31 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 269
ene 27, 2024 12:33:20 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 308
ene 27, 2024 12:34:15 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 330
Exception in thread "pool-7-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
ene 27, 2024 12:34:42 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 401
ene 27, 2024 12:34:56 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 428
2024.01.27 12:35:15 INFO  compiling root-test (1 scala source)
2024.01.27 12:35:15 INFO  time: compiled root-test in 0.26s
2024.01.27 12:35:48 INFO  compiling root-test (1 scala source)
2024.01.27 12:35:48 INFO  time: compiled root-test in 0.9s
2024.01.27 12:36:53 INFO  compiling root-test (1 scala source)
2024.01.27 12:36:54 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:36:54 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:36:54 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:36:53 INFO  time: compiled root-test in 0.88s
2024.01.27 12:37:15 INFO  compiling root-test (1 scala source)
2024.01.27 12:37:15 INFO  time: compiled root-test in 0.77s
2024.01.27 12:37:17 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:37:17 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:37:17 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:37:17 INFO  Trying to attach to remote debuggee VM 127.0.0.1:50915 .
2024.01.27 12:37:17 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:37:18 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:37:17 INFO  Closing debug server tcp://0.0.0.0:50912
2024.01.27 12:37:32 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:37:32 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:37:32 INFO  Starting debug proxy for [test.scala.Tests()]
2024.01.27 12:37:32 INFO  Trying to attach to remote debuggee VM 127.0.0.1:50923 .
2024.01.27 12:37:32 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:37:33 INFO  Canceling debug proxy for [test.scala.Tests()]
2024.01.27 12:37:32 INFO  Closing debug server tcp://0.0.0.0:50920
Exception in thread "pool-7-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024.01.27 12:38:35 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:38:35 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:38:35 INFO  compiling root-test (1 scala source)
2024.01.27 12:38:35 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:38:35 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:38:35 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:38:35 INFO  time: compiled root-test in 0.73s
2024.01.27 12:38:40 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:38:40 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:38:40 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:38:40 INFO  Trying to attach to remote debuggee VM 127.0.0.1:50931 .
2024.01.27 12:38:40 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:38:41 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:38:40 INFO  Closing debug server tcp://0.0.0.0:50928
2024.01.27 12:39:34 ERROR Failed to tokenize input for semantic tokens for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
scala.meta.tokenizers.TokenizeException: <input>:130: error: illegal character '\u00a1'
    assertEquals(1,invoker.getActions().le)
                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:842)

ene 27, 2024 12:39:35 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1087
ene 27, 2024 12:39:35 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1088
2024.01.27 12:39:39 INFO  compiling root-test (1 scala source)
2024.01.27 12:39:39 INFO  time: compiled root-test in 0.79s
2024.01.27 12:39:41 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:39:41 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:39:41 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:39:41 INFO  Trying to attach to remote debuggee VM 127.0.0.1:50944 .
2024.01.27 12:39:41 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:39:41 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:39:41 INFO  Closing debug server tcp://0.0.0.0:50941
2024.01.27 12:39:48 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:842)
```

ene 27, 2024 12:39:48 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/util/ArrayList.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.util;\n\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.util.ArraysSupport;\n\n/**\n * Resizable-array implementation of the {@code List} interface.  Implements\n * all optional list operations, and permits all elements, including\n * {@code null}.  In addition to implementing the {@code List} interface,\n * this class provides methods to manipulate the size of the array that is\n * used internally to store the list.  (This class is roughly equivalent to\n * {@code Vector}, except that it is unsynchronized.)\n *\n * \u003cp\u003eThe {@code size}, {@code isEmpty}, {@code get}, {@code set},\n * {@code iterator}, and {@code listIterator} operations run in constant\n * time.  The {@code add} operation runs in \u003ci\u003eamortized constant time\u003c/i\u003e,\n * that is, adding n elements requires O(n) time.  All of the other operations\n * run in linear time (roughly speaking).  The constant factor is low compared\n * to that for the {@code LinkedList} implementation.\n *\n * \u003cp\u003eEach {@code ArrayList} instance has a \u003ci\u003ecapacity\u003c/i\u003e.  The capacity is\n * the size of the array used to store the elements in the list.  It is always\n * at least as large as the list size.  As elements are added to an ArrayList,\n * its capacity grows automatically.  The details of the growth policy are not\n * specified beyond the fact that adding an element has constant amortized\n * time cost.\n *\n * \u003cp\u003eAn application can increase the capacity of an {@code ArrayList} instance\n * before adding a large number of elements using the {@code ensureCapacity}\n * operation.  This may reduce the amount of incremental reallocation.\n *\n * \u003cp\u003e\u003cstrong\u003eNote that this implementation is not synchronized.\u003c/strong\u003e\n * If multiple threads access an {@code ArrayList} instance concurrently,\n * and at least one of the threads modifies the list structurally, it\n * \u003ci\u003emust\u003c/i\u003e be synchronized externally.  (A structural modification is\n * any operation that adds or deletes one or more elements, or explicitly\n * resizes the backing array; merely setting the value of an element is not\n * a structural modification.)  This is typically accomplished by\n * synchronizing on some object that naturally encapsulates the list.\n *\n * If no such object exists, the list should be \"wrapped\" using the\n * {@link Collections#synchronizedList Collections.synchronizedList}\n * method.  This is best done at creation time, to prevent accidental\n * unsynchronized access to the list:\u003cpre\u003e\n *   List list \u003d Collections.synchronizedList(new ArrayList(...));\u003c/pre\u003e\n *\n * \u003cp id\u003d\"fail-fast\"\u003e\n * The iterators returned by this class\u0027s {@link #iterator() iterator} and\n * {@link #listIterator(int) listIterator} methods are \u003cem\u003efail-fast\u003c/em\u003e:\n * if the list is structurally modified at any time after the iterator is\n * created, in any way except through the iterator\u0027s own\n * {@link ListIterator#remove() remove} or\n * {@link ListIterator#add(Object) add} methods, the iterator will throw a\n * {@link ConcurrentModificationException}.  Thus, in the face of\n * concurrent modification, the iterator fails quickly and cleanly, rather\n * than risking arbitrary, non-deterministic behavior at an undetermined\n * time in the future.\n *\n * \u003cp\u003eNote that the fail-fast behavior of an iterator cannot be guaranteed\n * as it is, generally speaking, impossible to make any hard guarantees in the\n * presence of unsynchronized concurrent modification.  Fail-fast iterators\n * throw {@code ConcurrentModificationException} on a best-effort basis.\n * Therefore, it would be wrong to write a program that depended on this\n * exception for its correctness:  \u003ci\u003ethe fail-fast behavior of iterators\n * should be used only to detect bugs.\u003c/i\u003e\n *\n * \u003cp\u003eThis class is a member of the\n * \u003ca href\u003d\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\n * Java Collections Framework\u003c/a\u003e.\n *\n * @param \u003cE\u003e the type of elements in this list\n *\n * @author  Josh Bloch\n * @author  Neal Gafter\n * @see     Collection\n * @see     List\n * @see     LinkedList\n * @see     Vector\n * @since   1.2\n */\npublic class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e\n        implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable\n{\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 8683452581122892189L;\n\n    /**\n     * Default initial capacity.\n     */\n    private static final int DEFAULT_CAPACITY \u003d 10;\n\n    /**\n     * Shared empty array instance used for empty instances.\n     */\n    private static final Object[] EMPTY_ELEMENTDATA \u003d {};\n\n    /**\n     * Shared empty array instance used for default sized empty instances. We\n     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n     * first element is added.\n     */\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA \u003d {};\n\n    /**\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer. Any\n     * empty ArrayList with elementData \u003d\u003d DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * The size of the ArrayList (the number of elements it contains).\n     *\n     * @serial\n     */\n    private int size;\n\n    /**\n     * Constructs an empty list with the specified initial capacity.\n     *\n     * @param  initialCapacity  the initial capacity of the list\n     * @throws IllegalArgumentException if the specified initial capacity\n     *         is negative\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity \u003e 0) {\n            this.elementData \u003d new Object[initialCapacity];\n        } else if (initialCapacity \u003d\u003d 0) {\n            this.elementData \u003d EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     * Constructs an empty list with an initial capacity of ten.\n     */\n    public ArrayList() {\n        this.elementData \u003d DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * Constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection\u0027s\n     * iterator.\n     *\n     * @param c the collection whose elements are to be placed into this list\n     * @throws NullPointerException if the specified collection is null\n     */\n    public ArrayList(Collection\u003c? extends E\u003e c) {\n        Object[] a \u003d c.toArray();\n        if ((size \u003d a.length) !\u003d 0) {\n            if (c.getClass() \u003d\u003d ArrayList.class) {\n                elementData \u003d a;\n            } else {\n                elementData \u003d Arrays.copyOf(a, size, Object[].class);\n            }\n        } else {\n            // replace with empty array.\n            elementData \u003d EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     * Trims the capacity of this {@code ArrayList} instance to be the\n     * list\u0027s current size.  An application can use this operation to minimize\n     * the storage of an {@code ArrayList} instance.\n     */\n    public void trimToSize() {\n        modCount++;\n        if (size \u003c elementData.length) {\n            elementData \u003d (size \u003d\u003d 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n\n    /**\n     * Increases the capacity of this {@code ArrayList} instance, if\n     * necessary, to ensure that it can hold at least the number of elements\n     * specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     */\n    public void ensureCapacity(int minCapacity) {\n        if (minCapacity \u003e elementData.length\n            \u0026\u0026 !(elementData \u003d\u003d DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n                 \u0026\u0026 minCapacity \u003c\u003d DEFAULT_CAPACITY)) {\n            modCount++;\n            grow(minCapacity);\n        }\n    }\n\n    /**\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     * @throws OutOfMemoryError if minCapacity is less than zero\n     */\n    private Object[] grow(int minCapacity) {\n        int oldCapacity \u003d elementData.length;\n        if (oldCapacity \u003e 0 || elementData !\u003d DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            int newCapacity \u003d ArraysSupport.newLength(oldCapacity,\n                    minCapacity - oldCapacity, /* minimum growth */\n                    oldCapacity \u003e\u003e 1           /* preferred growth */);\n            return elementData \u003d Arrays.copyOf(elementData, newCapacity);\n        } else {\n            return elementData \u003d new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n        }\n    }\n\n    private Object[] grow() {\n        return grow(size + 1);\n    }\n\n    /**\n     * Returns the number of elements in this list.\n     *\n     * @return the number of elements in this list\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Returns {@code true} if this list contains no elements.\n     *\n     * @return {@code true} if this list contains no elements\n     */\n    public boolean isEmpty() {\n        return size \u003d\u003d 0;\n    }\n\n    /**\n     * Returns {@code true} if this list contains the specified element.\n     * More formally, returns {@code true} if and only if this list contains\n     * at least one element {@code e} such that\n     * {@code Objects.equals(o, e)}.\n     *\n     * @param o element whose presence in this list is to be tested\n     * @return {@code true} if this list contains the specified element\n     */\n    public boolean contains(Object o) {\n        return indexOf(o) \u003e\u003d 0;\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the lowest index {@code i} such that\n     * {@code Objects.equals(o, get(i))},\n     * or -1 if there is no such index.\n     */\n    public int indexOf(Object o) {\n        return indexOfRange(o, 0, size);\n    }\n\n    int indexOfRange(Object o, int start, int end) {\n        Object[] es \u003d elementData;\n        if (o \u003d\u003d null) {\n            for (int i \u003d start; i \u003c end; i++) {\n                if (es[i] \u003d\u003d null) {\n                    return i;\n                }\n            }\n        } else {\n            for (int i \u003d start; i \u003c end; i++) {\n                if (o.equals(es[i])) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the index of the last occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the highest index {@code i} such that\n     * {@code Objects.equals(o, get(i))},\n     * or -1 if there is no such index.\n     */\n    public int lastIndexOf(Object o) {\n        return lastIndexOfRange(o, 0, size);\n    }\n\n    int lastIndexOfRange(Object o, int start, int end) {\n        Object[] es \u003d elementData;\n        if (o \u003d\u003d null) {\n            for (int i \u003d end - 1; i \u003e\u003d start; i--) {\n                if (es[i] \u003d\u003d null) {\n                    return i;\n                }\n            }\n        } else {\n            for (int i \u003d end - 1; i \u003e\u003d start; i--) {\n                if (o.equals(es[i])) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns a shallow copy of this {@code ArrayList} instance.  (The\n     * elements themselves are not copied.)\n     *\n     * @return a clone of this {@code ArrayList} instance\n     */\n    public Object clone() {\n        try {\n            ArrayList\u003c?\u003e v \u003d (ArrayList\u003c?\u003e) super.clone();\n            v.elementData \u003d Arrays.copyOf(elementData, size);\n            v.modCount \u003d 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // this shouldn\u0027t happen, since we are Cloneable\n            throw new InternalError(e);\n        }\n    }\n\n    /**\n     * Returns an array containing all of the elements in this list\n     * in proper sequence (from first to last element).\n     *\n     * \u003cp\u003eThe returned array will be \"safe\" in that no references to it are\n     * maintained by this list.  (In other words, this method must allocate\n     * a new array).  The caller is thus free to modify the returned array.\n     *\n     * \u003cp\u003eThis method acts as bridge between array-based and collection-based\n     * APIs.\n     *\n     * @return an array containing all of the elements in this list in\n     *         proper sequence\n     */\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * Returns an array containing all of the elements in this list in proper\n     * sequence (from first to last element); the runtime type of the returned\n     * array is that of the specified array.  If the list fits in the\n     * specified array, it is returned therein.  Otherwise, a new array is\n     * allocated with the runtime type of the specified array and the size of\n     * this list.\n     *\n     * \u003cp\u003eIf the list fits in the specified array with room to spare\n     * (i.e., the array has more elements than the list), the element in\n     * the array immediately following the end of the collection is set to\n     * {@code null}.  (This is useful in determining the length of the\n     * list \u003ci\u003eonly\u003c/i\u003e if the caller knows that the list does not contain\n     * any null elements.)\n     *\n     * @param a the array into which the elements of the list are to\n     *          be stored, if it is big enough; otherwise, a new array of the\n     *          same runtime type is allocated for this purpose.\n     * @return an array containing the elements of the list\n     * @throws ArrayStoreException if the runtime type of the specified array\n     *         is not a supertype of the runtime type of every element in\n     *         this list\n     * @throws NullPointerException if the specified array is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public \u003cT\u003e T[] toArray(T[] a) {\n        if (a.length \u003c size)\n            // Make a new array of a\u0027s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length \u003e size)\n            a[size] \u003d null;\n        return a;\n    }\n\n    // Positional Access Operations\n\n    @SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static \u003cE\u003e E elementAt(Object[] es, int index) {\n        return (E) es[index];\n    }\n\n    /**\n     * Returns the element at the specified position in this list.\n     *\n     * @param  index index of the element to return\n     * @return the element at the specified position in this list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E get(int index) {\n        Objects.checkIndex(index, size);\n        return elementData(index);\n    }\n\n    /**\n     * Replaces the element at the specified position in this list with\n     * the specified element.\n     *\n     * @param index index of the element to replace\n     * @param element element to be stored at the specified position\n     * @return the element previously at the specified position\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E set(int index, E element) {\n        Objects.checkIndex(index, size);\n        E oldValue \u003d elementData(index);\n        elementData[index] \u003d element;\n        return oldValue;\n    }\n\n    /**\n     * This helper method split out from add(E) to keep method\n     * bytecode size under 35 (the -XX:MaxInlineSize default value),\n     * which helps when add(E) is called in a C1-compiled loop.\n     */\n    private void add(E e, Object[] elementData, int s) {\n        if (s \u003d\u003d elementData.length)\n            elementData \u003d grow();\n        elementData[s] \u003d e;\n        size \u003d s + 1;\n    }\n\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n        modCount++;\n        add(e, elementData, size);\n        return true;\n    }\n\n    /**\n     * Inserts the specified element at the specified position in this\n     * list. Shifts the element currently at that position (if any) and\n     * any subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n        modCount++;\n        final int s;\n        Object[] elementData;\n        if ((s \u003d size) \u003d\u003d (elementData \u003d this.elementData).length)\n            elementData \u003d grow();\n        System.arraycopy(elementData, index,\n                         elementData, index + 1,\n                         s - index);\n        elementData[index] \u003d element;\n        size \u003d s + 1;\n    }\n\n    /**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their\n     * indices).\n     *\n     * @param index the index of the element to be removed\n     * @return the element that was removed from the list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        Objects.checkIndex(index, size);\n        final Object[] es \u003d elementData;\n\n        @SuppressWarnings(\"unchecked\") E oldValue \u003d (E) es[index];\n        fastRemove(es, index);\n\n        return oldValue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object o) {\n        if (o \u003d\u003d this) {\n            return true;\n        }\n\n        if (!(o instanceof List)) {\n            return false;\n        }\n\n        final int expectedModCount \u003d modCount;\n        // ArrayList can be subclassed and given arbitrary behavior, but we can\n        // still deal with the common case where o is ArrayList precisely\n        boolean equal \u003d (o.getClass() \u003d\u003d ArrayList.class)\n            ? equalsArrayList((ArrayList\u003c?\u003e) o)\n            : equalsRange((List\u003c?\u003e) o, 0, size);\n\n        checkForComodification(expectedModCount);\n        return equal;\n    }\n\n    boolean equalsRange(List\u003c?\u003e other, int from, int to) {\n        final Object[] es \u003d elementData;\n        if (to \u003e es.length) {\n            throw new ConcurrentModificationException();\n        }\n        var oit \u003d other.iterator();\n        for (; from \u003c to; from++) {\n            if (!oit.hasNext() || !Objects.equals(es[from], oit.next())) {\n                return false;\n            }\n        }\n        return !oit.hasNext();\n    }\n\n    private boolean equalsArrayList(ArrayList\u003c?\u003e other) {\n        final int otherModCount \u003d other.modCount;\n        final int s \u003d size;\n        boolean equal;\n        if (equal \u003d (s \u003d\u003d other.size)) {\n            final Object[] otherEs \u003d other.elementData;\n            final Object[] es \u003d elementData;\n            if (s \u003e es.length || s \u003e otherEs.length) {\n                throw new ConcurrentModificationException();\n            }\n            for (int i \u003d 0; i \u003c s; i++) {\n                if (!Objects.equals(es[i], otherEs[i])) {\n                    equal \u003d false;\n                    break;\n                }\n            }\n        }\n        other.checkForComodification(otherModCount);\n        return equal;\n    }\n\n    private void checkForComodification(final int expectedModCount) {\n        if (modCount !\u003d expectedModCount) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        int expectedModCount \u003d modCount;\n        int hash \u003d hashCodeRange(0, size);\n        checkForComodification(expectedModCount);\n        return hash;\n    }\n\n    int hashCodeRange(int from, int to) {\n        final Object[] es \u003d elementData;\n        if (to \u003e es.length) {\n            throw new ConcurrentModificationException();\n        }\n        int hashCode \u003d 1;\n        for (int i \u003d from; i \u003c to; i++) {\n            Object e \u003d es[i];\n            hashCode \u003d 31 * hashCode + (e \u003d\u003d null ? 0 : e.hashCode());\n        }\n        return hashCode;\n    }\n\n    /**\n     * Removes the first occurrence of the specified element from this list,\n     * if it is present.  If the list does not contain the element, it is\n     * unchanged.  More formally, removes the element with the lowest index\n     * {@code i} such that\n     * {@code Objects.equals(o, get(i))}\n     * (if such an element exists).  Returns {@code true} if this list\n     * contained the specified element (or equivalently, if this list\n     * changed as a result of the call).\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if this list contained the specified element\n     */\n    public boolean remove(Object o) {\n        final Object[] es \u003d elementData;\n        final int size \u003d this.size;\n        int i \u003d 0;\n        found: {\n            if (o \u003d\u003d null) {\n                for (; i \u003c size; i++)\n                    if (es[i] \u003d\u003d null)\n                        break found;\n            } else {\n                for (; i \u003c size; i++)\n                    if (o.equals(es[i]))\n                        break found;\n            }\n            return false;\n        }\n        fastRemove(es, i);\n        return true;\n    }\n\n    /**\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */\n    private void fastRemove(Object[] es, int i) {\n        modCount++;\n        final int newSize;\n        if ((newSize \u003d size - 1) \u003e i)\n            System.arraycopy(es, i + 1, es, i, newSize - i);\n        es[size \u003d newSize] \u003d null;\n    }\n\n    /**\n     * Removes all of the elements from this list.  The list will\n     * be empty after this call returns.\n     */\n    public void clear() {\n        modCount++;\n        final Object[] es \u003d elementData;\n        for (int to \u003d size, i \u003d size \u003d 0; i \u003c to; i++)\n            es[i] \u003d null;\n    }\n\n    /**\n     * Appends all of the elements in the specified collection to the end of\n     * this list, in the order that they are returned by the\n     * specified collection\u0027s Iterator.  The behavior of this operation is\n     * undefined if the specified collection is modified while the operation\n     * is in progress.  (This implies that the behavior of this call is\n     * undefined if the specified collection is this list, and this\n     * list is nonempty.)\n     *\n     * @param c collection containing elements to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws NullPointerException if the specified collection is null\n     */\n    public boolean addAll(Collection\u003c? extends E\u003e c) {\n        Object[] a \u003d c.toArray();\n        modCount++;\n        int numNew \u003d a.length;\n        if (numNew \u003d\u003d 0)\n            return false;\n        Object[] elementData;\n        final int s;\n        if (numNew \u003e (elementData \u003d this.elementData).length - (s \u003d size))\n            elementData \u003d grow(s + numNew);\n        System.arraycopy(a, 0, elementData, s, numNew);\n        size \u003d s + numNew;\n        return true;\n    }\n\n    /**\n     * Inserts all of the elements in the specified collection into this\n     * list, starting at the specified position.  Shifts the element\n     * currently at that position (if any) and any subsequent elements to\n     * the right (increases their indices).  The new elements will appear\n     * in the list in the order that they are returned by the\n     * specified collection\u0027s iterator.\n     *\n     * @param index index at which to insert the first element from the\n     *              specified collection\n     * @param c collection containing elements to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     * @throws NullPointerException if the specified collection is null\n     */\n    public boolean addAll(int index, Collection\u003c? extends E\u003e c) {\n        rangeCheckForAdd(index);\n\n        Object[] a \u003d c.toArray();\n        modCount++;\n        int numNew \u003d a.length;\n        if (numNew \u003d\u003d 0)\n            return false;\n        Object[] elementData;\n        final int s;\n        if (numNew \u003e (elementData \u003d this.elementData).length - (s \u003d size))\n            elementData \u003d grow(s + numNew);\n\n        int numMoved \u003d s - index;\n        if (numMoved \u003e 0)\n            System.arraycopy(elementData, index,\n                             elementData, index + numNew,\n                             numMoved);\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size \u003d s + numNew;\n        return true;\n    }\n\n    /**\n     * Removes from this list all of the elements whose index is between\n     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.\n     * Shifts any succeeding elements to the left (reduces their index).\n     * This call shortens the list by {@code (toIndex - fromIndex)} elements.\n     * (If {@code toIndex\u003d\u003dfromIndex}, this operation has no effect.)\n     *\n     * @throws IndexOutOfBoundsException if {@code fromIndex} or\n     *         {@code toIndex} is out of range\n     *         ({@code fromIndex \u003c 0 ||\n     *          toIndex \u003e size() ||\n     *          toIndex \u003c fromIndex})\n     */\n    protected void removeRange(int fromIndex, int toIndex) {\n        if (fromIndex \u003e toIndex) {\n            throw new IndexOutOfBoundsException(\n                    outOfBoundsMsg(fromIndex, toIndex));\n        }\n        modCount++;\n        shiftTailOverGap(elementData, fromIndex, toIndex);\n    }\n\n    /** Erases the gap from lo to hi, by sliding down following elements. */\n    private void shiftTailOverGap(Object[] es, int lo, int hi) {\n        System.arraycopy(es, hi, es, lo, size - hi);\n        for (int to \u003d size, i \u003d (size -\u003d hi - lo); i \u003c to; i++)\n            es[i] \u003d null;\n    }\n\n    /**\n     * A version of rangeCheck used by add and addAll.\n     */\n    private void rangeCheckForAdd(int index) {\n        if (index \u003e size || index \u003c 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * Constructs an IndexOutOfBoundsException detail message.\n     * Of the many possible refactorings of the error handling code,\n     * this \"outlining\" performs best with both server and client VMs.\n     */\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \"+index+\", Size: \"+size;\n    }\n\n    /**\n     * A version used in checking (fromIndex \u003e toIndex) condition\n     */\n    private static String outOfBoundsMsg(int fromIndex, int toIndex) {\n        return \"From Index: \" + fromIndex + \" \u003e To Index: \" + toIndex;\n    }\n\n    /**\n     * Removes from this list all of its elements that are contained in the\n     * specified collection.\n     *\n     * @param c collection containing elements to be removed from this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws ClassCastException if the class of an element of this list\n     *         is incompatible with the specified collection\n     * (\u003ca href\u003d\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\n     * @throws NullPointerException if this list contains a null element and the\n     *         specified collection does not permit null elements\n     * (\u003ca href\u003d\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e),\n     *         or if the specified collection is null\n     * @see Collection#contains(Object)\n     */\n    public boolean removeAll(Collection\u003c?\u003e c) {\n        return batchRemove(c, false, 0, size);\n    }\n\n    /**\n     * Retains only the elements in this list that are contained in the\n     * specified collection.  In other words, removes from this list all\n     * of its elements that are not contained in the specified collection.\n     *\n     * @param c collection containing elements to be retained in this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws ClassCastException if the class of an element of this list\n     *         is incompatible with the specified collection\n     * (\u003ca href\u003d\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\n     * @throws NullPointerException if this list contains a null element and the\n     *         specified collection does not permit null elements\n     * (\u003ca href\u003d\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e),\n     *         or if the specified collection is null\n     * @see Collection#contains(Object)\n     */\n    public boolean retainAll(Collection\u003c?\u003e c) {\n        return batchRemove(c, true, 0, size);\n    }\n\n    boolean batchRemove(Collection\u003c?\u003e c, boolean complement,\n                        final int from, final int end) {\n        Objects.requireNonNull(c);\n        final Object[] es \u003d elementData;\n        int r;\n        // Optimize for initial run of survivors\n        for (r \u003d from;; r++) {\n            if (r \u003d\u003d end)\n                return false;\n            if (c.contains(es[r]) !\u003d complement)\n                break;\n        }\n        int w \u003d r++;\n        try {\n            for (Object e; r \u003c end; r++)\n                if (c.contains(e \u003d es[r]) \u003d\u003d complement)\n                    es[w++] \u003d e;\n        } catch (Throwable ex) {\n            // Preserve behavioral compatibility with AbstractCollection,\n            // even if c.contains() throws.\n            System.arraycopy(es, r, es, w, end - r);\n            w +\u003d end - r;\n            throw ex;\n        } finally {\n            modCount +\u003d end - w;\n            shiftTailOverGap(es, w, end);\n        }\n        return true;\n    }\n\n    /**\n     * Saves the state of the {@code ArrayList} instance to a stream\n     * (that is, serializes it).\n     *\n     * @param s the stream\n     * @throws java.io.IOException if an I/O error occurs\n     * @serialData The length of the array backing the {@code ArrayList}\n     *             instance is emitted (int), followed by all of its elements\n     *             (each an {@code Object}) in the proper order.\n     */\n    @java.io.Serial\n    private void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException {\n        // Write out element count, and any hidden stuff\n        int expectedModCount \u003d modCount;\n        s.defaultWriteObject();\n\n        // Write out size as capacity for behavioral compatibility with clone()\n        s.writeInt(size);\n\n        // Write out all elements in the proper order.\n        for (int i\u003d0; i\u003csize; i++) {\n            s.writeObject(elementData[i]);\n        }\n\n        if (modCount !\u003d expectedModCount) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    /**\n     * Reconstitutes the {@code ArrayList} instance from a stream (that is,\n     * deserializes it).\n     * @param s the stream\n     * @throws ClassNotFoundException if the class of a serialized object\n     *         could not be found\n     * @throws java.io.IOException if an I/O error occurs\n     */\n    @java.io.Serial\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n\n        // Read in size, and any hidden stuff\n        s.defaultReadObject();\n\n        // Read in capacity\n        s.readInt(); // ignored\n\n        if (size \u003e 0) {\n            // like clone(), allocate array based upon size not capacity\n            SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);\n            Object[] elements \u003d new Object[size];\n\n            // Read in all elements in the proper order.\n            for (int i \u003d 0; i \u003c size; i++) {\n                elements[i] \u003d s.readObject();\n            }\n\n            elementData \u003d elements;\n        } else if (size \u003d\u003d 0) {\n            elementData \u003d EMPTY_ELEMENTDATA;\n        } else {\n            throw new java.io.InvalidObjectException(\"Invalid size: \" + size);\n        }\n    }\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper\n     * sequence), starting at the specified position in the list.\n     * The specified index indicates the first element that would be\n     * returned by an initial call to {@link ListIterator#next next}.\n     * An initial call to {@link ListIterator#previous previous} would\n     * return the element with the specified index minus one.\n     *\n     * \u003cp\u003eThe returned list iterator is \u003ca href\u003d\"#fail-fast\"\u003e\u003ci\u003efail-fast\u003c/i\u003e\u003c/a\u003e.\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public ListIterator\u003cE\u003e listIterator(int index) {\n        rangeCheckForAdd(index);\n        return new ListItr(index);\n    }\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper\n     * sequence).\n     *\n     * \u003cp\u003eThe returned list iterator is \u003ca href\u003d\"#fail-fast\"\u003e\u003ci\u003efail-fast\u003c/i\u003e\u003c/a\u003e.\n     *\n     * @see #listIterator(int)\n     */\n    public ListIterator\u003cE\u003e listIterator() {\n        return new ListItr(0);\n    }\n\n    /**\n     * Returns an iterator over the elements in this list in proper sequence.\n     *\n     * \u003cp\u003eThe returned iterator is \u003ca href\u003d\"#fail-fast\"\u003e\u003ci\u003efail-fast\u003c/i\u003e\u003c/a\u003e.\n     *\n     * @return an iterator over the elements in this list in proper sequence\n     */\n    public Iterator\u003cE\u003e iterator() {\n        return new Itr();\n    }\n\n    /**\n     * An optimized version of AbstractList.Itr\n     */\n    private class Itr implements Iterator\u003cE\u003e {\n        int cursor;       // index of next element to return\n        int lastRet \u003d -1; // index of last element returned; -1 if no such\n        int expectedModCount \u003d modCount;\n\n        // prevent creating a synthetic constructor\n        Itr() {}\n\n        public boolean hasNext() {\n            return cursor !\u003d size;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public E next() {\n            checkForComodification();\n            int i \u003d cursor;\n            if (i \u003e\u003d size)\n                throw new NoSuchElementException();\n            Object[] elementData \u003d ArrayList.this.elementData;\n            if (i \u003e\u003d elementData.length)\n                throw new ConcurrentModificationException();\n            cursor \u003d i + 1;\n            return (E) elementData[lastRet \u003d i];\n        }\n\n        public void remove() {\n            if (lastRet \u003c 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try {\n                ArrayList.this.remove(lastRet);\n                cursor \u003d lastRet;\n                lastRet \u003d -1;\n                expectedModCount \u003d modCount;\n            } catch (IndexOutOfBoundsException ex) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        @Override\n        public void forEachRemaining(Consumer\u003c? super E\u003e action) {\n            Objects.requireNonNull(action);\n            final int size \u003d ArrayList.this.size;\n            int i \u003d cursor;\n            if (i \u003c size) {\n                final Object[] es \u003d elementData;\n                if (i \u003e\u003d es.length)\n                    throw new ConcurrentModificationException();\n                for (; i \u003c size \u0026\u0026 modCount \u003d\u003d expectedModCount; i++)\n                    action.accept(elementAt(es, i));\n                // update once at end to reduce heap write traffic\n                cursor \u003d i;\n                lastRet \u003d i - 1;\n                checkForComodification();\n            }\n        }\n\n        final void checkForComodification() {\n            if (modCount !\u003d expectedModCount)\n                throw new ConcurrentModificationException();\n        }\n    }\n\n    /**\n     * An optimized version of AbstractList.ListItr\n     */\n    private class ListItr extends Itr implements ListIterator\u003cE\u003e {\n        ListItr(int index) {\n            super();\n            cursor \u003d index;\n        }\n\n        public boolean hasPrevious() {\n            return cursor !\u003d 0;\n        }\n\n        public int nextIndex() {\n            return cursor;\n        }\n\n        public int previousIndex() {\n            return cursor - 1;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public E previous() {\n            checkForComodification();\n            int i \u003d cursor - 1;\n            if (i \u003c 0)\n                throw new NoSuchElementException();\n            Object[] elementData \u003d ArrayList.this.elementData;\n            if (i \u003e\u003d elementData.length)\n                throw new ConcurrentModificationException();\n            cursor \u003d i;\n            return (E) elementData[lastRet \u003d i];\n        }\n\n        public void set(E e) {\n            if (lastRet \u003c 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try {\n                ArrayList.this.set(lastRet, e);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        public void add(E e) {\n            checkForComodification();\n\n            try {\n                int i \u003d cursor;\n                ArrayList.this.add(i, e);\n                cursor \u003d i + 1;\n                lastRet \u003d -1;\n                expectedModCount \u003d modCount;\n            } catch (IndexOutOfBoundsException ex) {\n                throw new ConcurrentModificationException();\n            }\n        }\n    }\n\n    /**\n     * Returns a view of the portion of this list between the specified\n     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If\n     * {@code fromIndex} and {@code toIndex} are equal, the returned list is\n     * empty.)  The returned list is backed by this list, so non-structural\n     * changes in the returned list are reflected in this list, and vice-versa.\n     * The returned list supports all of the optional list operations.\n     *\n     * \u003cp\u003eThis method eliminates the need for explicit range operations (of\n     * the sort that commonly exist for arrays).  Any operation that expects\n     * a list can be used as a range operation by passing a subList view\n     * instead of a whole list.  For example, the following idiom\n     * removes a range of elements from a list:\n     * \u003cpre\u003e\n     *      list.subList(from, to).clear();\n     * \u003c/pre\u003e\n     * Similar idioms may be constructed for {@link #indexOf(Object)} and\n     * {@link #lastIndexOf(Object)}, and all of the algorithms in the\n     * {@link Collections} class can be applied to a subList.\n     *\n     * \u003cp\u003eThe semantics of the list returned by this method become undefined if\n     * the backing list (i.e., this list) is \u003ci\u003estructurally modified\u003c/i\u003e in\n     * any way other than via the returned list.  (Structural modifications are\n     * those that change the size of this list, or otherwise perturb it in such\n     * a fashion that iterations in progress may yield incorrect results.)\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     */\n    public List\u003cE\u003e subList(int fromIndex, int toIndex) {\n        subListRangeCheck(fromIndex, toIndex, size);\n        return new SubList\u003c\u003e(this, fromIndex, toIndex);\n    }\n\n    private static class SubList\u003cE\u003e extends AbstractList\u003cE\u003e implements RandomAccess {\n        private final ArrayList\u003cE\u003e root;\n        private final SubList\u003cE\u003e parent;\n        private final int offset;\n        private int size;\n\n        /**\n         * Constructs a sublist of an arbitrary ArrayList.\n         */\n        public SubList(ArrayList\u003cE\u003e root, int fromIndex, int toIndex) {\n            this.root \u003d root;\n            this.parent \u003d null;\n            this.offset \u003d fromIndex;\n            this.size \u003d toIndex - fromIndex;\n            this.modCount \u003d root.modCount;\n        }\n\n        /**\n         * Constructs a sublist of another SubList.\n         */\n        private SubList(SubList\u003cE\u003e parent, int fromIndex, int toIndex) {\n            this.root \u003d parent.root;\n            this.parent \u003d parent;\n            this.offset \u003d parent.offset + fromIndex;\n            this.size \u003d toIndex - fromIndex;\n            this.modCount \u003d parent.modCount;\n        }\n\n        public E set(int index, E element) {\n            Objects.checkIndex(index, size);\n            checkForComodification();\n            E oldValue \u003d root.elementData(offset + index);\n            root.elementData[offset + index] \u003d element;\n            return oldValue;\n        }\n\n        public E get(int index) {\n            Objects.checkIndex(index, size);\n            checkForComodification();\n            return root.elementData(offset + index);\n        }\n\n        public int size() {\n            checkForComodification();\n            return size;\n        }\n\n        public void add(int index, E element) {\n            rangeCheckForAdd(index);\n            checkForComodification();\n            root.add(offset + index, element);\n            updateSizeAndModCount(1);\n        }\n\n        public E remove(int index) {\n            Objects.checkIndex(index, size);\n            checkForComodification();\n            E result \u003d root.remove(offset + index);\n            updateSizeAndModCount(-1);\n            return result;\n        }\n\n        protected void removeRange(int fromIndex, int toIndex) {\n            checkForComodification();\n            root.removeRange(offset + fromIndex, offset + toIndex);\n            updateSizeAndModCount(fromIndex - toIndex);\n        }\n\n        public boolean addAll(Collection\u003c? extends E\u003e c) {\n            return addAll(this.size, c);\n        }\n\n        public boolean addAll(int index, Collection\u003c? extends E\u003e c) {\n            rangeCheckForAdd(index);\n            int cSize \u003d c.size();\n            if (cSize\u003d\u003d0)\n                return false;\n            checkForComodification();\n            root.addAll(offset + index, c);\n            updateSizeAndModCount(cSize);\n            return true;\n        }\n\n        public void replaceAll(UnaryOperator\u003cE\u003e operator) {\n            root.replaceAllRange(operator, offset, offset + size);\n        }\n\n        public boolean removeAll(Collection\u003c?\u003e c) {\n            return batchRemove(c, false);\n        }\n\n        public boolean retainAll(Collection\u003c?\u003e c) {\n            return batchRemove(c, true);\n        }\n\n        private boolean batchRemove(Collection\u003c?\u003e c, boolean complement) {\n            checkForComodification();\n            int oldSize \u003d root.size;\n            boolean modified \u003d\n                root.batchRemove(c, complement, offset, offset + size);\n            if (modified)\n                updateSizeAndModCount(root.size - oldSize);\n            return modified;\n        }\n\n        public boolean removeIf(Predicate\u003c? super E\u003e filter) {\n            checkForComodification();\n            int oldSize \u003d root.size;\n            boolean modified \u003d root.removeIf(filter, offset, offset + size);\n            if (modified)\n                updateSizeAndModCount(root.size - oldSize);\n            return modified;\n        }\n\n        public Object[] toArray() {\n            checkForComodification();\n            return Arrays.copyOfRange(root.elementData, offset, offset + size);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public \u003cT\u003e T[] toArray(T[] a) {\n            checkForComodification();\n            if (a.length \u003c size)\n                return (T[]) Arrays.copyOfRange(\n                        root.elementData, offset, offset + size, a.getClass());\n            System.arraycopy(root.elementData, offset, a, 0, size);\n            if (a.length \u003e size)\n                a[size] \u003d null;\n            return a;\n        }\n\n        public boolean equals(Object o) {\n            if (o \u003d\u003d this) {\n                return true;\n            }\n\n            if (!(o instanceof List)) {\n                return false;\n            }\n\n            boolean equal \u003d root.equalsRange((List\u003c?\u003e)o, offset, offset + size);\n            checkForComodification();\n            return equal;\n        }\n\n        public int hashCode() {\n            int hash \u003d root.hashCodeRange(offset, offset + size);\n            checkForComodification();\n            return hash;\n        }\n\n        public int indexOf(Object o) {\n            int index \u003d root.indexOfRange(o, offset, offset + size);\n            checkForComodification();\n            return index \u003e\u003d 0 ? index - offset : -1;\n        }\n\n        public int lastIndexOf(Object o) {\n            int index \u003d root.lastIndexOfRange(o, offset, offset + size);\n            checkForComodification();\n            return index \u003e\u003d 0 ? index - offset : -1;\n        }\n\n        public boolean contains(Object o) {\n            return indexOf(o) \u003e\u003d 0;\n        }\n\n        public Iterator\u003cE\u003e iterator() {\n            return listIterator();\n        }\n\n        public ListIterator\u003cE\u003e listIterator(int index) {\n            checkForComodification();\n            rangeCheckForAdd(index);\n\n            return new ListIterator\u003cE\u003e() {\n                int cursor \u003d index;\n                int lastRet \u003d -1;\n                int expectedModCount \u003d SubList.this.modCount;\n\n                public boolean hasNext() {\n                    return cursor !\u003d SubList.this.size;\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                public E next() {\n                    checkForComodification();\n                    int i \u003d cursor;\n                    if (i \u003e\u003d SubList.this.size)\n                        throw new NoSuchElementException();\n                    Object[] elementData \u003d root.elementData;\n                    if (offset + i \u003e\u003d elementData.length)\n                        throw new ConcurrentModificationException();\n                    cursor \u003d i + 1;\n                    return (E) elementData[offset + (lastRet \u003d i)];\n                }\n\n                public boolean hasPrevious() {\n                    return cursor !\u003d 0;\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                public E previous() {\n                    checkForComodification();\n                    int i \u003d cursor - 1;\n                    if (i \u003c 0)\n                        throw new NoSuchElementException();\n                    Object[] elementData \u003d root.elementData;\n                    if (offset + i \u003e\u003d elementData.length)\n                        throw new ConcurrentModificationException();\n                    cursor \u003d i;\n                    return (E) elementData[offset + (lastRet \u003d i)];\n                }\n\n                public void forEachRemaining(Consumer\u003c? super E\u003e action) {\n                    Objects.requireNonNull(action);\n                    final int size \u003d SubList.this.size;\n                    int i \u003d cursor;\n                    if (i \u003c size) {\n                        final Object[] es \u003d root.elementData;\n                        if (offset + i \u003e\u003d es.length)\n                            throw new ConcurrentModificationException();\n                        for (; i \u003c size \u0026\u0026 root.modCount \u003d\u003d expectedModCount; i++)\n                            action.accept(elementAt(es, offset + i));\n                        // update once at end to reduce heap write traffic\n                        cursor \u003d i;\n                        lastRet \u003d i - 1;\n                        checkForComodification();\n                    }\n                }\n\n                public int nextIndex() {\n                    return cursor;\n                }\n\n                public int previousIndex() {\n                    return cursor - 1;\n                }\n\n                public void remove() {\n                    if (lastRet \u003c 0)\n                        throw new IllegalStateException();\n                    checkForComodification();\n\n                    try {\n                        SubList.this.remove(lastRet);\n                        cursor \u003d lastRet;\n                        lastRet \u003d -1;\n                        expectedModCount \u003d SubList.this.modCount;\n                    } catch (IndexOutOfBoundsException ex) {\n                        throw new ConcurrentModificationException();\n                    }\n                }\n\n                public void set(E e) {\n                    if (lastRet \u003c 0)\n                        throw new IllegalStateException();\n                    checkForComodification();\n\n                    try {\n                        root.set(offset + lastRet, e);\n                    } catch (IndexOutOfBoundsException ex) {\n                        throw new ConcurrentModificationException();\n                    }\n                }\n\n                public void add(E e) {\n                    checkForComodification();\n\n                    try {\n                        int i \u003d cursor;\n                        SubList.this.add(i, e);\n                        cursor \u003d i + 1;\n                        lastRet \u003d -1;\n                        expectedModCount \u003d SubList.this.modCount;\n                    } catch (IndexOutOfBoundsException ex) {\n                        throw new ConcurrentModificationException();\n                    }\n                }\n\n                final void checkForComodification() {\n                    if (root.modCount !\u003d expectedModCount)\n                        throw new ConcurrentModificationException();\n                }\n            };\n        }\n\n        public List\u003cE\u003e subList(int fromIndex, int toIndex) {\n            subListRangeCheck(fromIndex, toIndex, size);\n            return new SubList\u003c\u003e(this, fromIndex, toIndex);\n        }\n\n        private void rangeCheckForAdd(int index) {\n            if (index \u003c 0 || index \u003e this.size)\n                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n        }\n\n        private String outOfBoundsMsg(int index) {\n            return \"Index: \"+index+\", Size: \"+this.size;\n        }\n\n        private void checkForComodification() {\n            if (root.modCount !\u003d modCount)\n                throw new ConcurrentModificationException();\n        }\n\n        private void updateSizeAndModCount(int sizeChange) {\n            SubList\u003cE\u003e slist \u003d this;\n            do {\n                slist.size +\u003d sizeChange;\n                slist.modCount \u003d root.modCount;\n                slist \u003d slist.parent;\n            } while (slist !\u003d null);\n        }\n\n        public Spliterator\u003cE\u003e spliterator() {\n            checkForComodification();\n\n            // ArrayListSpliterator not used here due to late-binding\n            return new Spliterator\u003cE\u003e() {\n                private int index \u003d offset; // current index, modified on advance/split\n                private int fence \u003d -1; // -1 until used; then one past last index\n                private int expectedModCount; // initialized when fence set\n\n                private int getFence() { // initialize fence to size on first use\n                    int hi; // (a specialized variant appears in method forEach)\n                    if ((hi \u003d fence) \u003c 0) {\n                        expectedModCount \u003d modCount;\n                        hi \u003d fence \u003d offset + size;\n                    }\n                    return hi;\n                }\n\n                public ArrayList\u003cE\u003e.ArrayListSpliterator trySplit() {\n                    int hi \u003d getFence(), lo \u003d index, mid \u003d (lo + hi) \u003e\u003e\u003e 1;\n                    // ArrayListSpliterator can be used here as the source is already bound\n                    return (lo \u003e\u003d mid) ? null : // divide range in half unless too small\n                        root.new ArrayListSpliterator(lo, index \u003d mid, expectedModCount);\n                }\n\n                public boolean tryAdvance(Consumer\u003c? super E\u003e action) {\n                    Objects.requireNonNull(action);\n                    int hi \u003d getFence(), i \u003d index;\n                    if (i \u003c hi) {\n                        index \u003d i + 1;\n                        @SuppressWarnings(\"unchecked\") E e \u003d (E)root.elementData[i];\n                        action.accept(e);\n                        if (root.modCount !\u003d expectedModCount)\n                            throw new ConcurrentModificationException();\n                        return true;\n                    }\n                    return false;\n                }\n\n                public void forEachRemaining(Consumer\u003c? super E\u003e action) {\n                    Objects.requireNonNull(action);\n                    int i, hi, mc; // hoist accesses and checks from loop\n                    ArrayList\u003cE\u003e lst \u003d root;\n                    Object[] a;\n                    if ((a \u003d lst.elementData) !\u003d null) {\n                        if ((hi \u003d fence) \u003c 0) {\n                            mc \u003d modCount;\n                            hi \u003d offset + size;\n                        }\n                        else\n                            mc \u003d expectedModCount;\n                        if ((i \u003d index) \u003e\u003d 0 \u0026\u0026 (index \u003d hi) \u003c\u003d a.length) {\n                            for (; i \u003c hi; ++i) {\n                                @SuppressWarnings(\"unchecked\") E e \u003d (E) a[i];\n                                action.accept(e);\n                            }\n                            if (lst.modCount \u003d\u003d mc)\n                                return;\n                        }\n                    }\n                    throw new ConcurrentModificationException();\n                }\n\n                public long estimateSize() {\n                    return getFence() - index;\n                }\n\n                public int characteristics() {\n                    return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;\n                }\n            };\n        }\n    }\n\n    /**\n     * @throws NullPointerException {@inheritDoc}\n     */\n    @Override\n    public void forEach(Consumer\u003c? super E\u003e action) {\n        Objects.requireNonNull(action);\n        final int expectedModCount \u003d modCount;\n        final Object[] es \u003d elementData;\n        final int size \u003d this.size;\n        for (int i \u003d 0; modCount \u003d\u003d expectedModCount \u0026\u0026 i \u003c size; i++)\n            action.accept(elementAt(es, i));\n        if (modCount !\u003d expectedModCount)\n            throw new ConcurrentModificationException();\n    }\n\n    /**\n     * Creates a \u003cem\u003e\u003ca href\u003d\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e\n     * and \u003cem\u003efail-fast\u003c/em\u003e {@link Spliterator} over the elements in this\n     * list.\n     *\n     * \u003cp\u003eThe {@code Spliterator} reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.\n     * Overriding implementations should document the reporting of additional\n     * characteristic values.\n     *\n     * @return a {@code Spliterator} over the elements in this list\n     * @since 1.8\n     */\n    @Override\n    public Spliterator\u003cE\u003e spliterator() {\n        return new ArrayListSpliterator(0, -1, 0);\n    }\n\n    /** Index-based split-by-two, lazily initialized Spliterator */\n    final class ArrayListSpliterator implements Spliterator\u003cE\u003e {\n\n        /*\n         * If ArrayLists were immutable, or structurally immutable (no\n         * adds, removes, etc), we could implement their spliterators\n         * with Arrays.spliterator. Instead we detect as much\n         * interference during traversal as practical without\n         * sacrificing much performance. We rely primarily on\n         * modCounts. These are not guaranteed to detect concurrency\n         * violations, and are sometimes overly conservative about\n         * within-thread interference, but detect enough problems to\n         * be worthwhile in practice. To carry this out, we (1) lazily\n         * initialize fence and expectedModCount until the latest\n         * point that we need to commit to the state we are checking\n         * against; thus improving precision.  (This doesn\u0027t apply to\n         * SubLists, that create spliterators with current non-lazy\n         * values).  (2) We perform only a single\n         * ConcurrentModificationException check at the end of forEach\n         * (the most performance-sensitive method). When using forEach\n         * (as opposed to iterators), we can normally only detect\n         * interference after actions, not before. Further\n         * CME-triggering checks apply to all other possible\n         * violations of assumptions for example null or too-small\n         * elementData array given its size(), that could only have\n         * occurred due to interference.  This allows the inner loop\n         * of forEach to run without any further checks, and\n         * simplifies lambda-resolution. While this does entail a\n         * number of checks, note that in the common case of\n         * list.stream().forEach(a), no checks or other computation\n         * occur anywhere other than inside forEach itself.  The other\n         * less-often-used methods cannot take advantage of most of\n         * these streamlinings.\n         */\n\n        private int index; // current index, modified on advance/split\n        private int fence; // -1 until used; then one past last index\n        private int expectedModCount; // initialized when fence set\n\n        /** Creates new spliterator covering the given range. */\n        ArrayListSpliterator(int origin, int fence, int expectedModCount) {\n            this.index \u003d origin;\n            this.fence \u003d fence;\n            this.expectedModCount \u003d expectedModCount;\n        }\n\n        private int getFence() { // initialize fence to size on first use\n            int hi; // (a specialized variant appears in method forEach)\n            if ((hi \u003d fence) \u003c 0) {\n                expectedModCount \u003d modCount;\n                hi \u003d fence \u003d size;\n            }\n            return hi;\n        }\n\n        public ArrayListSpliterator trySplit() {\n            int hi \u003d getFence(), lo \u003d index, mid \u003d (lo + hi) \u003e\u003e\u003e 1;\n            return (lo \u003e\u003d mid) ? null : // divide range in half unless too small\n                new ArrayListSpliterator(lo, index \u003d mid, expectedModCount);\n        }\n\n        public boolean tryAdvance(Consumer\u003c? super E\u003e action) {\n            if (action \u003d\u003d null)\n                throw new NullPointerException();\n            int hi \u003d getFence(), i \u003d index;\n            if (i \u003c hi) {\n                index \u003d i + 1;\n                @SuppressWarnings(\"unchecked\") E e \u003d (E)elementData[i];\n                action.accept(e);\n                if (modCount !\u003d expectedModCount)\n                    throw new ConcurrentModificationException();\n                return true;\n            }\n            return false;\n        }\n\n        public void forEachRemaining(Consumer\u003c? super E\u003e action) {\n            int i, hi, mc; // hoist accesses and checks from loop\n            Object[] a;\n            if (action \u003d\u003d null)\n                throw new NullPointerException();\n            if ((a \u003d elementData) !\u003d null) {\n                if ((hi \u003d fence) \u003c 0) {\n                    mc \u003d modCount;\n                    hi \u003d size;\n                }\n                else\n                    mc \u003d expectedModCount;\n                if ((i \u003d index) \u003e\u003d 0 \u0026\u0026 (index \u003d hi) \u003c\u003d a.length) {\n                    for (; i \u003c hi; ++i) {\n                        @SuppressWarnings(\"unchecked\") E e \u003d (E) a[i];\n                        action.accept(e);\n                    }\n                    if (modCount \u003d\u003d mc)\n                        return;\n                }\n            }\n            throw new ConcurrentModificationException();\n        }\n\n        public long estimateSize() {\n            return getFence() - index;\n        }\n\n        public int characteristics() {\n            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;\n        }\n    }\n\n    // A tiny bit set implementation\n\n    private static long[] nBits(int n) {\n        return new long[((n - 1) \u003e\u003e 6) + 1];\n    }\n    private static void setBit(long[] bits, int i) {\n        bits[i \u003e\u003e 6] |\u003d 1L \u003c\u003c i;\n    }\n    private static boolean isClear(long[] bits, int i) {\n        return (bits[i \u003e\u003e 6] \u0026 (1L \u003c\u003c i)) \u003d\u003d 0;\n    }\n\n    /**\n     * @throws NullPointerException {@inheritDoc}\n     */\n    @Override\n    public boolean removeIf(Predicate\u003c? super E\u003e filter) {\n        return removeIf(filter, 0, size);\n    }\n\n    /**\n     * Removes all elements satisfying the given predicate, from index\n     * i (inclusive) to index end (exclusive).\n     */\n    boolean removeIf(Predicate\u003c? super E\u003e filter, int i, final int end) {\n        Objects.requireNonNull(filter);\n        int expectedModCount \u003d modCount;\n        final Object[] es \u003d elementData;\n        // Optimize for initial run of survivors\n        for (; i \u003c end \u0026\u0026 !filter.test(elementAt(es, i)); i++)\n            ;\n        // Tolerate predicates that reentrantly access the collection for\n        // read (but writers still get CME), so traverse once to find\n        // elements to delete, a second pass to physically expunge.\n        if (i \u003c end) {\n            final int beg \u003d i;\n            final long[] deathRow \u003d nBits(end - beg);\n            deathRow[0] \u003d 1L;   // set bit 0\n            for (i \u003d beg + 1; i \u003c end; i++)\n                if (filter.test(elementAt(es, i)))\n                    setBit(deathRow, i - beg);\n            if (modCount !\u003d expectedModCount)\n                throw new ConcurrentModificationException();\n            modCount++;\n            int w \u003d beg;\n            for (i \u003d beg; i \u003c end; i++)\n                if (isClear(deathRow, i - beg))\n                    es[w++] \u003d es[i];\n            shiftTailOverGap(es, w, end);\n            return true;\n        } else {\n            if (modCount !\u003d expectedModCount)\n                throw new ConcurrentModificationException();\n            return false;\n        }\n    }\n\n    @Override\n    public void replaceAll(UnaryOperator\u003cE\u003e operator) {\n        replaceAllRange(operator, 0, size);\n        // TODO(8203662): remove increment of modCount from ...\n        modCount++;\n    }\n\n    private void replaceAllRange(UnaryOperator\u003cE\u003e operator, int i, int end) {\n        Objects.requireNonNull(operator);\n        final int expectedModCount \u003d modCount;\n        final Object[] es \u003d elementData;\n        for (; modCount \u003d\u003d expectedModCount \u0026\u0026 i \u003c end; i++)\n            es[i] \u003d operator.apply(elementAt(es, i));\n        if (modCount !\u003d expectedModCount)\n            throw new ConcurrentModificationException();\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void sort(Comparator\u003c? super E\u003e c) {\n        final int expectedModCount \u003d modCount;\n        Arrays.sort((E[]) elementData, 0, size, c);\n        if (modCount !\u003d expectedModCount)\n            throw new ConcurrentModificationException();\n        modCount++;\n    }\n\n    void checkInvariants() {\n        // assert size \u003e\u003d 0;\n        // assert size \u003d\u003d elementData.length || elementData[size] \u003d\u003d null;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

ene 27, 2024 12:39:48 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/util/ArrayList.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.01.27 12:39:59 INFO  compiling root-test (1 scala source)
2024.01.27 12:40:00 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:39:59 INFO  time: compiled root-test in 0.68s
2024.01.27 12:40:03 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:40:03 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:40:03 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:40:03 INFO  Trying to attach to remote debuggee VM 127.0.0.1:50957 .
2024.01.27 12:40:03 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:40:03 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:40:03 INFO  Closing debug server tcp://0.0.0.0:50954
ene 27, 2024 12:40:20 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1204
2024.01.27 12:40:23 INFO  compiling root-test (1 scala source)
2024.01.27 12:40:23 INFO  time: compiled root-test in 0.68s
2024.01.27 12:40:25 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:40:25 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:40:25 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:40:25 INFO  Trying to attach to remote debuggee VM 127.0.0.1:50965 .
2024.01.27 12:40:25 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:40:26 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:40:25 INFO  Closing debug server tcp://0.0.0.0:50962
2024.01.27 12:41:10 INFO  compiling root-test (1 scala source)
2024.01.27 12:41:10 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:41:10 INFO  time: compiled root-test in 0.7s
2024.01.27 12:41:13 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:41:13 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:41:13 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:41:13 INFO  Trying to attach to remote debuggee VM 127.0.0.1:50987 .
2024.01.27 12:41:13 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:41:13 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:41:13 INFO  Closing debug server tcp://0.0.0.0:50984
2024.01.27 12:41:18 INFO  compiling root-test (1 scala source)
2024.01.27 12:41:18 INFO  time: compiled root-test in 0.69s
2024.01.27 12:41:18 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 19m 42.99s)
2024.01.27 12:41:18 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 19m 43.012s)
2024.01.27 12:41:19 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:41:19 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:41:19 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:41:18 INFO  Trying to attach to remote debuggee VM 127.0.0.1:50995 .
2024.01.27 12:41:18 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:41:20 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:41:20 INFO  Closing debug server tcp://0.0.0.0:50992
2024.01.27 12:41:24 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:41:24 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:41:24 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:41:24 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51003 .
2024.01.27 12:41:24 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:41:24 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:41:24 INFO  Closing debug server tcp://0.0.0.0:51000
2024.01.27 12:46:40 ERROR Failed to tokenize input for semantic tokens for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
scala.meta.tokenizers.TokenizeException: <input>:139: error: Invalid literal number
    assertEquals(2s,controller.getMetrics().size())
                 ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:842)

2024.01.27 12:46:43 INFO  compiling root-test (1 scala source)
2024.01.27 12:46:43 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:46:43 INFO  time: compiled root-test in 0.8s
2024.01.27 12:46:57 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:46:57 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:46:57 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:46:57 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51058 .
2024.01.27 12:46:57 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:46:58 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:46:57 INFO  Closing debug server tcp://0.0.0.0:51055
2024.01.27 12:47:08 INFO  compiling root-test (1 scala source)
2024.01.27 12:47:08 INFO  time: compiled root-test in 0.65s
2024.01.27 12:47:08 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 25m 32.515s)
2024.01.27 12:47:08 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 25m 32.537s)
2024.01.27 12:47:09 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:47:09 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:47:09 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:47:08 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51067 .
2024.01.27 12:47:08 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:47:09 INFO  Closing debug server tcp://0.0.0.0:51064
2024.01.27 12:47:09 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:47:17 INFO  compiling root-test (1 scala source)
2024.01.27 12:47:17 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:47:17 INFO  time: compiled root-test in 0.64s
2024.01.27 12:47:21 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:47:21 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:47:21 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:47:21 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51075 .
2024.01.27 12:47:21 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:47:22 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 12:47:21 INFO  Closing debug server tcp://0.0.0.0:51072
2024.01.27 12:49:03 INFO  compiling root-test (1 scala source)
2024.01.27 12:49:03 INFO  time: compiled root-test in 0.64s
2024.01.27 12:49:12 INFO  compiling root-test (1 scala source)
2024.01.27 12:49:12 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:49:12 INFO  time: compiled root-test in 0.63s
2024.01.27 12:49:13 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:49:13 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:49:14 INFO  Starting debug proxy for [test.scala.Tests(read temporal)]
2024.01.27 12:49:14 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51084 .
2024.01.27 12:49:14 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:49:14 INFO  Canceling debug proxy for [test.scala.Tests(read temporal)]
2024.01.27 12:49:14 INFO  Closing debug server tcp://0.0.0.0:51081
ene 27, 2024 12:49:43 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1559
2024.01.27 12:50:28 INFO  Shutting down server
2024.01.27 12:50:28 INFO  shutting down Metals
2024.01.27 12:50:28 INFO  Shut down connection with build server.
2024.01.27 12:50:28 INFO  Shut down connection with build server.
ene 27, 2024 12:50:28 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFO: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.ClosedChannelException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:39)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:126)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:180)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:150)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$register$2(BuildServerConnection.scala:425)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$register$1(BuildServerConnection.scala:425)
	at scala.meta.internal.metals.Cancelable$$anon$1.cancel(Cancelable.scala:18)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:365)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1(BuildServerConnection.scala:157)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1$adapted(BuildServerConnection.scala:149)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: java.nio.channels.ClosedChannelException
	at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:527)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:123)
	at java.base/java.nio.channels.Channels.writeFullyImpl(Channels.java:74)
	at java.base/java.nio.channels.Channels.writeFully(Channels.java:93)
	at java.base/java.nio.channels.Channels$1.write(Channels.java:171)
	at java.base/java.io.OutputStream.write(OutputStream.java:127)
	at java.base/java.nio.channels.Channels$1.write(Channels.java:151)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:137)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:108)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 20 more

2024.01.27 12:50:28 INFO  Cancelling compilation on Bloop server
2024.01.27 12:50:28 INFO  Exiting server
2024.01.27 12:50:39 INFO  Started: Metals version 1.2.0 in folders 'C:\Users\ARNAU\Desktop\TAP\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.27 12:50:40 INFO  Attempting to connect to the build server...
2024.01.27 12:50:40 INFO  skipping build import with status 'Installed'
2024.01.27 12:50:40 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 12:50:40 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 12:50:40 INFO  Attempting to connect to the build server...
2024.01.27 12:50:40 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 12:50:40 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 12:50:40 INFO  time: Connected to build server in 0.28s
2024.01.27 12:50:40 INFO  Connected to Build server: Bloop v1.5.13
2024.01.27 12:50:43 INFO  no build target found for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.27 12:50:46 INFO  time: indexed workspace in 3.06s
2024.01.27 12:50:46 INFO  compiling root-test (1 scala source)
2024.01.27 12:50:48 INFO  time: compiled root-test in 1.56s
2024.01.27 12:50:52 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 12:50:52 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 12:50:52 INFO  Starting debug proxy for [test.scala.Tests(read temporal)]
2024.01.27 12:50:52 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51154 .
2024.01.27 12:50:52 INFO  Attaching to debuggee VM succeeded.
2024.01.27 12:50:52 INFO  Closing debug server tcp://0.0.0.0:51151
2024.01.27 12:50:53 INFO  Canceling debug proxy for [test.scala.Tests(read temporal)]
ene 27, 2024 12:53:11 P.M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Downloading https://repo1.maven.org/maven2/org/scalameta/scalafmt-core_2.13/3.7.15/scalafmt-core_2.13-3.7.15.pom
Downloaded https://repo1.maven.org/maven2/org/scalameta/scalafmt-core_2.13/3.7.15/scalafmt-core_2.13-3.7.15.pom
Downloading https://repo1.maven.org/maven2/org/scalameta/scalafmt-sysops_2.13/3.7.15/scalafmt-sysops_2.13-3.7.15.pom
Downloading https://repo1.maven.org/maven2/org/scalameta/scalafmt-config_2.13/3.7.15/scalafmt-config_2.13-3.7.15.pom
Downloading https://repo1.maven.org/maven2/org/scalameta/scalameta_2.13/4.8.12/scalameta_2.13-4.8.12.pom
Downloaded https://repo1.maven.org/maven2/org/scalameta/scalafmt-sysops_2.13/3.7.15/scalafmt-sysops_2.13-3.7.15.pom
Downloaded https://repo1.maven.org/maven2/org/scalameta/scalameta_2.13/4.8.12/scalameta_2.13-4.8.12.pom
Downloaded https://repo1.maven.org/maven2/org/scalameta/scalafmt-config_2.13/3.7.15/scalafmt-config_2.13-3.7.15.pom
Downloading https://repo1.maven.org/maven2/org/scalameta/parsers_2.13/4.8.12/parsers_2.13-4.8.12.pom
Downloaded https://repo1.maven.org/maven2/org/scalameta/parsers_2.13/4.8.12/parsers_2.13-4.8.12.pom
Downloading https://repo1.maven.org/maven2/org/scalameta/trees_2.13/4.8.12/trees_2.13-4.8.12.pom
Downloaded https://repo1.maven.org/maven2/org/scalameta/trees_2.13/4.8.12/trees_2.13-4.8.12.pom
Downloading https://repo1.maven.org/maven2/org/scalameta/common_2.13/4.8.12/common_2.13-4.8.12.pom
Downloaded https://repo1.maven.org/maven2/org/scalameta/common_2.13/4.8.12/common_2.13-4.8.12.pom
Downloading https://repo1.maven.org/maven2/org/scalameta/trees_2.13/4.8.12/trees_2.13-4.8.12.jar
Downloading https://repo1.maven.org/maven2/org/scalameta/scalameta_2.13/4.8.12/scalameta_2.13-4.8.12.jar
Downloading https://repo1.maven.org/maven2/org/scalameta/common_2.13/4.8.12/common_2.13-4.8.12.jar
Downloading https://repo1.maven.org/maven2/org/scalameta/scalafmt-core_2.13/3.7.15/scalafmt-core_2.13-3.7.15.jar
Downloading https://repo1.maven.org/maven2/org/scalameta/parsers_2.13/4.8.12/parsers_2.13-4.8.12.jar
Downloading https://repo1.maven.org/maven2/org/scalameta/scalafmt-config_2.13/3.7.15/scalafmt-config_2.13-3.7.15.jar
Downloaded https://repo1.maven.org/maven2/org/scalameta/scalafmt-config_2.13/3.7.15/scalafmt-config_2.13-3.7.15.jar
Downloading https://repo1.maven.org/maven2/org/scalameta/scalafmt-sysops_2.13/3.7.15/scalafmt-sysops_2.13-3.7.15.jar
Downloaded https://repo1.maven.org/maven2/org/scalameta/parsers_2.13/4.8.12/parsers_2.13-4.8.12.jar
Downloaded https://repo1.maven.org/maven2/org/scalameta/scalafmt-sysops_2.13/3.7.15/scalafmt-sysops_2.13-3.7.15.jar
Downloaded https://repo1.maven.org/maven2/org/scalameta/scalameta_2.13/4.8.12/scalameta_2.13-4.8.12.jar
Downloaded https://repo1.maven.org/maven2/org/scalameta/trees_2.13/4.8.12/trees_2.13-4.8.12.jar
Downloaded https://repo1.maven.org/maven2/org/scalameta/common_2.13/4.8.12/common_2.13-4.8.12.jar
Downloaded https://repo1.maven.org/maven2/org/scalameta/scalafmt-core_2.13/3.7.15/scalafmt-core_2.13-3.7.15.jar
2024.01.27 12:55:18 INFO  compiling root-test (1 scala source)
2024.01.27 12:55:18 INFO  time: compiled root-test in 0.22s
2024.01.27 12:55:28 INFO  compiling root-test (1 scala source)
2024.01.27 12:55:28 INFO  time: compiled root-test in 0.14s
2024.01.27 12:55:36 INFO  compiling root-test (1 scala source)
2024.01.27 12:55:36 INFO  time: compiled root-test in 0.16s
2024.01.27 12:56:04 INFO  compiling root-test (1 scala source)
2024.01.27 12:56:04 INFO  time: compiled root-test in 0.14s
2024.01.27 12:56:17 INFO  compiling root-test (1 scala source)
2024.01.27 12:56:17 INFO  time: compiled root-test in 0.14s
2024.01.27 12:56:41 WARN  Using indexes to guess the definition of Menu
2024.01.27 12:56:45 WARN  Using indexes to guess the definition of Menu
2024.01.27 12:56:46 WARN  Using indexes to guess the definition of appetizersCategory
2024.01.27 12:56:46 WARN  Using indexes to guess the definition of MenuCategory
2024.01.27 12:56:54 INFO  compiling root-test (1 scala source)
2024.01.27 12:56:54 INFO  time: compiled root-test in 0.16s
2024.01.27 12:57:04 INFO  compiling root-test (1 scala source)
2024.01.27 12:57:04 INFO  time: compiled root-test in 0.14s
Exception in thread "pool-4-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024.01.27 12:57:14 WARN  Using indexes to guess the definition of appetizersCategory
2024.01.27 12:57:14 WARN  Using indexes to guess the definition of MenuCategory
2024.01.27 12:57:18 WARN  Using indexes to guess the definition of MenuCategory
2024.01.27 12:57:19 WARN  Using indexes to guess the definition of MenuCategory
2024.01.27 12:57:24 INFO  compiling root-test (1 scala source)
2024.01.27 12:57:24 INFO  time: compiled root-test in 0.16s
2024.01.27 12:57:46 INFO  compiling root-test (1 scala source)
2024.01.27 12:57:46 INFO  time: compiled root-test in 0.12s
2024.01.27 12:58:17 INFO  compiling root-test (1 scala source)
2024.01.27 12:58:17 INFO  time: compiled root-test in 0.12s
2024.01.27 12:58:54 INFO  compiling root-test (1 scala source)
2024.01.27 12:58:54 INFO  time: compiled root-test in 0.6s
ene 27, 2024 12:59:02 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 887
ene 27, 2024 12:59:16 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 962
2024.01.27 12:59:21 INFO  compiling root-test (1 scala source)
2024.01.27 12:59:21 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 12:59:21 INFO  time: compiled root-test in 0.73s
Exception in thread "pool-6-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
ene 27, 2024 12:59:32 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1016
2024.01.27 12:59:34 INFO  compiling root-test (1 scala source)
2024.01.27 12:59:34 INFO  time: compiled root-test in 0.13s
2024.01.27 12:59:46 INFO  compiling root-test (1 scala source)
ene 27, 2024 12:59:46 P.M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.01.27 12:59:46 INFO  time: compiled root-test in 0.58s
ene 27, 2024 1:00:00 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1123
Exception in thread "pool-6-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024.01.27 13:01:00 INFO  compiling root-test (1 scala source)
2024.01.27 13:01:00 INFO  time: compiled root-test in 0.13s
2024.01.27 13:01:08 INFO  compiling root-test (1 scala source)
2024.01.27 13:01:08 INFO  time: compiled root-test in 0.13s
2024.01.27 13:01:11 INFO  compiling root-test (1 scala source)
2024.01.27 13:01:11 INFO  time: compiled root-test in 0.13s
2024.01.27 13:01:16 INFO  compiling root-test (1 scala source)
2024.01.27 13:01:16 INFO  time: compiled root-test in 0.12s
2024.01.27 13:01:21 INFO  compiling root-test (1 scala source)
2024.01.27 13:01:21 INFO  time: compiled root-test in 0.12s
2024.01.27 13:02:01 INFO  compiling root-test (1 scala source)
2024.01.27 13:02:01 INFO  time: compiled root-test in 0.58s
2024.01.27 13:02:28 INFO  compiling root-test (1 scala source)
2024.01.27 13:02:29 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:02:28 INFO  time: compiled root-test in 0.61s
Exception in thread "pool-4-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024.01.27 13:03:25 INFO  compiling root-test (1 scala source)
2024.01.27 13:03:25 INFO  time: compiled root-test in 0.12s
2024.01.27 13:03:30 INFO  compiling root-test (1 scala source)
2024.01.27 13:03:30 INFO  time: compiled root-test in 0.12s
2024.01.27 13:03:33 INFO  compiling root-test (1 scala source)
2024.01.27 13:03:33 INFO  time: compiled root-test in 0.58s
2024.01.27 13:04:00 ERROR Failed to tokenize input for semantic tokens for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
scala.meta.tokenizers.TokenizeException: <input>:151: error: illegal character '\u00a1'
    mainCourses.addChild(pasta)
                               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:842)

2024.01.27 13:04:06 INFO  compiling root-test (1 scala source)
2024.01.27 13:04:06 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:04:06 INFO  time: compiled root-test in 0.57s
2024.01.27 13:04:49 INFO  compiling root-test (1 scala source)
2024.01.27 13:04:49 INFO  time: compiled root-test in 0.58s
2024.01.27 13:04:50 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 13:04:50 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 13:04:50 INFO  Starting debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 13:04:50 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51225 .
2024.01.27 13:04:50 INFO  Attaching to debuggee VM succeeded.
2024.01.27 13:04:51 INFO  Canceling debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 13:04:50 INFO  Closing debug server tcp://0.0.0.0:51222
2024.01.27 13:04:55 INFO  compiling root-test (1 scala source)
2024.01.27 13:04:55 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:04:55 INFO  time: compiled root-test in 0.61s
2024.01.27 13:04:55 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 14m 15.574s)
2024.01.27 13:04:55 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 14m 15.592s)
2024.01.27 13:04:56 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 13:04:56 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 13:04:56 INFO  Starting debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 13:04:55 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51233 .
2024.01.27 13:04:55 INFO  Attaching to debuggee VM succeeded.
2024.01.27 13:04:56 INFO  Canceling debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 13:04:56 INFO  Closing debug server tcp://0.0.0.0:51230
2024.01.27 13:05:04 INFO  compiling root-test (1 scala source)
2024.01.27 13:05:04 INFO  time: compiled root-test in 0.72s
2024.01.27 13:05:05 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 13:05:05 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 13:05:06 INFO  Starting debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 13:05:06 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51241 .
2024.01.27 13:05:06 INFO  Attaching to debuggee VM succeeded.
2024.01.27 13:05:06 INFO  Canceling debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 13:05:06 INFO  Closing debug server tcp://0.0.0.0:51238
Exception in thread "pool-6-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Exception in thread "pool-4-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024.01.27 13:06:26 ERROR Failed to tokenize input for semantic tokens for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
scala.meta.tokenizers.TokenizeException: <input>:158: error: illegal character '\u00a1'
    assertEquals(12.99,mainCourses.getPrice);
                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:842)

2024.01.27 13:06:39 INFO  compiling root-test (1 scala source)
2024.01.27 13:06:39 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:06:39 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:06:39 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:06:39 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:06:39 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:06:39 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:06:39 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:06:39 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:06:40 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 13:06:39 INFO  time: compiled root-test in 0.6s
2024.01.27 13:06:42 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 13:06:42 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 13:06:42 INFO  Starting debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 13:06:42 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51260 .
2024.01.27 13:06:42 INFO  Attaching to debuggee VM succeeded.
2024.01.27 13:06:43 INFO  Canceling debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 13:06:42 INFO  Closing debug server tcp://0.0.0.0:51257
2024.01.27 13:07:04 INFO  compiling root-test (1 scala source)
2024.01.27 13:07:04 INFO  time: compiled root-test in 0.58s
2024.01.27 13:07:05 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 13:07:05 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 13:07:06 INFO  Starting debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 13:07:06 INFO  Trying to attach to remote debuggee VM 127.0.0.1:51269 .
2024.01.27 13:07:06 INFO  Attaching to debuggee VM succeeded.
2024.01.27 13:07:06 INFO  Canceling debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 13:07:06 INFO  Closing debug server tcp://0.0.0.0:51266
ene 27, 2024 1:10:37 P.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.01.27 13:16:44 INFO  Shutting down server
2024.01.27 13:16:44 INFO  shutting down Metals
2024.01.27 13:16:44 INFO  Shut down connection with build server.
2024.01.27 13:16:44 INFO  Shut down connection with build server.
2024.01.27 13:16:44 INFO  Exiting server
2024.01.27 13:16:52 INFO  Started: Metals version 1.2.0 in folders 'C:\Users\ARNAU\Desktop\TAP\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.27 13:16:53 INFO  Attempting to connect to the build server...
2024.01.27 13:16:53 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 13:16:53 INFO  skipping build import with status 'Installed'
2024.01.27 13:16:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 13:16:53 INFO  Attempting to connect to the build server...
2024.01.27 13:16:53 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 13:16:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 13:16:53 INFO  time: Connected to build server in 0.3s
2024.01.27 13:16:53 INFO  Connected to Build server: Bloop v1.5.13
2024.01.27 13:16:54 INFO  time: Imported build in 0.14s
2024.01.27 13:16:57 INFO  time: indexed workspace in 3.76s
2024.01.27 13:17:33 INFO  Shutting down server
2024.01.27 13:17:33 INFO  shutting down Metals
2024.01.27 13:17:33 INFO  Shut down connection with build server.
2024.01.27 13:17:33 INFO  Shut down connection with build server.
2024.01.27 13:17:33 INFO  Exiting server
2024.01.27 13:17:41 INFO  Started: Metals version 1.2.0 in folders 'C:\Users\ARNAU\Desktop\TAP\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.27 13:17:42 INFO  Attempting to connect to the build server...
2024.01.27 13:17:42 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 13:17:42 INFO  skipping build import with status 'Installed'
2024.01.27 13:17:42 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 13:17:42 INFO  Attempting to connect to the build server...
2024.01.27 13:17:42 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 13:17:42 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 13:17:42 INFO  time: Connected to build server in 0.35s
2024.01.27 13:17:42 INFO  Connected to Build server: Bloop v1.5.13
2024.01.27 13:17:46 INFO  time: indexed workspace in 3.76s
2024.01.27 13:33:25 INFO  Shutting down server
2024.01.27 13:33:25 INFO  shutting down Metals
2024.01.27 13:33:25 INFO  Shut down connection with build server.
2024.01.27 13:33:25 INFO  Shut down connection with build server.
2024.01.27 13:33:25 INFO  Exiting server
2024.01.27 13:33:34 INFO  Started: Metals version 1.2.0 in folders 'C:\Users\ARNAU\Desktop\TAP\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.27 13:33:35 INFO  Attempting to connect to the build server...
2024.01.27 13:33:35 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 13:33:35 INFO  skipping build import with status 'Installed'
2024.01.27 13:33:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 13:33:35 INFO  Attempting to connect to the build server...
2024.01.27 13:33:35 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 13:33:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 13:33:35 INFO  time: Connected to build server in 0.31s
2024.01.27 13:33:35 INFO  Connected to Build server: Bloop v1.5.13
2024.01.27 13:33:39 INFO  time: indexed workspace in 3.91s
2024.01.27 13:34:10 INFO  Shutting down server
2024.01.27 13:34:10 INFO  shutting down Metals
2024.01.27 13:34:10 INFO  Shut down connection with build server.
2024.01.27 13:34:10 INFO  Shut down connection with build server.
2024.01.27 13:34:10 INFO  Exiting server
2024.01.27 15:29:52 INFO  Started: Metals version 1.2.0 in folders 'C:\Users\ARNAU\Desktop\TAP\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.27 15:29:53 INFO  Attempting to connect to the build server...
2024.01.27 15:29:53 INFO  skipping build import with status 'Installed'
2024.01.27 15:29:53 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 15:29:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 15:29:53 INFO  Attempting to connect to the build server...
2024.01.27 15:29:53 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 15:29:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 15:29:53 INFO  time: Connected to build server in 0.31s
2024.01.27 15:29:53 INFO  Connected to Build server: Bloop v1.5.13
ene 27, 2024 3:29:53 P.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.01.27 15:30:01 INFO  time: indexed workspace in 7.12s
2024.01.27 15:30:13 INFO  compiling root-test (1 scala source)
2024.01.27 15:30:13 INFO  time: compiled root-test in 0.59s
ene 27, 2024 3:31:10 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 207
Exception in thread "pool-6-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
ene 27, 2024 3:31:10 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 209
ene 27, 2024 3:31:10 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 210
2024.01.27 15:31:41 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:842)
```

ene 27, 2024 3:31:41 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/util/ArrayList.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.util;\n\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.util.ArraysSupport;\n\n/**\n * Resizable-array implementation of the {@code List} interface.  Implements\n * all optional list operations, and permits all elements, including\n * {@code null}.  In addition to implementing the {@code List} interface,\n * this class provides methods to manipulate the size of the array that is\n * used internally to store the list.  (This class is roughly equivalent to\n * {@code Vector}, except that it is unsynchronized.)\n *\n * \u003cp\u003eThe {@code size}, {@code isEmpty}, {@code get}, {@code set},\n * {@code iterator}, and {@code listIterator} operations run in constant\n * time.  The {@code add} operation runs in \u003ci\u003eamortized constant time\u003c/i\u003e,\n * that is, adding n elements requires O(n) time.  All of the other operations\n * run in linear time (roughly speaking).  The constant factor is low compared\n * to that for the {@code LinkedList} implementation.\n *\n * \u003cp\u003eEach {@code ArrayList} instance has a \u003ci\u003ecapacity\u003c/i\u003e.  The capacity is\n * the size of the array used to store the elements in the list.  It is always\n * at least as large as the list size.  As elements are added to an ArrayList,\n * its capacity grows automatically.  The details of the growth policy are not\n * specified beyond the fact that adding an element has constant amortized\n * time cost.\n *\n * \u003cp\u003eAn application can increase the capacity of an {@code ArrayList} instance\n * before adding a large number of elements using the {@code ensureCapacity}\n * operation.  This may reduce the amount of incremental reallocation.\n *\n * \u003cp\u003e\u003cstrong\u003eNote that this implementation is not synchronized.\u003c/strong\u003e\n * If multiple threads access an {@code ArrayList} instance concurrently,\n * and at least one of the threads modifies the list structurally, it\n * \u003ci\u003emust\u003c/i\u003e be synchronized externally.  (A structural modification is\n * any operation that adds or deletes one or more elements, or explicitly\n * resizes the backing array; merely setting the value of an element is not\n * a structural modification.)  This is typically accomplished by\n * synchronizing on some object that naturally encapsulates the list.\n *\n * If no such object exists, the list should be \"wrapped\" using the\n * {@link Collections#synchronizedList Collections.synchronizedList}\n * method.  This is best done at creation time, to prevent accidental\n * unsynchronized access to the list:\u003cpre\u003e\n *   List list \u003d Collections.synchronizedList(new ArrayList(...));\u003c/pre\u003e\n *\n * \u003cp id\u003d\"fail-fast\"\u003e\n * The iterators returned by this class\u0027s {@link #iterator() iterator} and\n * {@link #listIterator(int) listIterator} methods are \u003cem\u003efail-fast\u003c/em\u003e:\n * if the list is structurally modified at any time after the iterator is\n * created, in any way except through the iterator\u0027s own\n * {@link ListIterator#remove() remove} or\n * {@link ListIterator#add(Object) add} methods, the iterator will throw a\n * {@link ConcurrentModificationException}.  Thus, in the face of\n * concurrent modification, the iterator fails quickly and cleanly, rather\n * than risking arbitrary, non-deterministic behavior at an undetermined\n * time in the future.\n *\n * \u003cp\u003eNote that the fail-fast behavior of an iterator cannot be guaranteed\n * as it is, generally speaking, impossible to make any hard guarantees in the\n * presence of unsynchronized concurrent modification.  Fail-fast iterators\n * throw {@code ConcurrentModificationException} on a best-effort basis.\n * Therefore, it would be wrong to write a program that depended on this\n * exception for its correctness:  \u003ci\u003ethe fail-fast behavior of iterators\n * should be used only to detect bugs.\u003c/i\u003e\n *\n * \u003cp\u003eThis class is a member of the\n * \u003ca href\u003d\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\n * Java Collections Framework\u003c/a\u003e.\n *\n * @param \u003cE\u003e the type of elements in this list\n *\n * @author  Josh Bloch\n * @author  Neal Gafter\n * @see     Collection\n * @see     List\n * @see     LinkedList\n * @see     Vector\n * @since   1.2\n */\npublic class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e\n        implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable\n{\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 8683452581122892189L;\n\n    /**\n     * Default initial capacity.\n     */\n    private static final int DEFAULT_CAPACITY \u003d 10;\n\n    /**\n     * Shared empty array instance used for empty instances.\n     */\n    private static final Object[] EMPTY_ELEMENTDATA \u003d {};\n\n    /**\n     * Shared empty array instance used for default sized empty instances. We\n     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n     * first element is added.\n     */\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA \u003d {};\n\n    /**\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer. Any\n     * empty ArrayList with elementData \u003d\u003d DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * The size of the ArrayList (the number of elements it contains).\n     *\n     * @serial\n     */\n    private int size;\n\n    /**\n     * Constructs an empty list with the specified initial capacity.\n     *\n     * @param  initialCapacity  the initial capacity of the list\n     * @throws IllegalArgumentException if the specified initial capacity\n     *         is negative\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity \u003e 0) {\n            this.elementData \u003d new Object[initialCapacity];\n        } else if (initialCapacity \u003d\u003d 0) {\n            this.elementData \u003d EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     * Constructs an empty list with an initial capacity of ten.\n     */\n    public ArrayList() {\n        this.elementData \u003d DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * Constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection\u0027s\n     * iterator.\n     *\n     * @param c the collection whose elements are to be placed into this list\n     * @throws NullPointerException if the specified collection is null\n     */\n    public ArrayList(Collection\u003c? extends E\u003e c) {\n        Object[] a \u003d c.toArray();\n        if ((size \u003d a.length) !\u003d 0) {\n            if (c.getClass() \u003d\u003d ArrayList.class) {\n                elementData \u003d a;\n            } else {\n                elementData \u003d Arrays.copyOf(a, size, Object[].class);\n            }\n        } else {\n            // replace with empty array.\n            elementData \u003d EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     * Trims the capacity of this {@code ArrayList} instance to be the\n     * list\u0027s current size.  An application can use this operation to minimize\n     * the storage of an {@code ArrayList} instance.\n     */\n    public void trimToSize() {\n        modCount++;\n        if (size \u003c elementData.length) {\n            elementData \u003d (size \u003d\u003d 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n\n    /**\n     * Increases the capacity of this {@code ArrayList} instance, if\n     * necessary, to ensure that it can hold at least the number of elements\n     * specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     */\n    public void ensureCapacity(int minCapacity) {\n        if (minCapacity \u003e elementData.length\n            \u0026\u0026 !(elementData \u003d\u003d DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n                 \u0026\u0026 minCapacity \u003c\u003d DEFAULT_CAPACITY)) {\n            modCount++;\n            grow(minCapacity);\n        }\n    }\n\n    /**\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     * @throws OutOfMemoryError if minCapacity is less than zero\n     */\n    private Object[] grow(int minCapacity) {\n        int oldCapacity \u003d elementData.length;\n        if (oldCapacity \u003e 0 || elementData !\u003d DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            int newCapacity \u003d ArraysSupport.newLength(oldCapacity,\n                    minCapacity - oldCapacity, /* minimum growth */\n                    oldCapacity \u003e\u003e 1           /* preferred growth */);\n            return elementData \u003d Arrays.copyOf(elementData, newCapacity);\n        } else {\n            return elementData \u003d new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n        }\n    }\n\n    private Object[] grow() {\n        return grow(size + 1);\n    }\n\n    /**\n     * Returns the number of elements in this list.\n     *\n     * @return the number of elements in this list\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Returns {@code true} if this list contains no elements.\n     *\n     * @return {@code true} if this list contains no elements\n     */\n    public boolean isEmpty() {\n        return size \u003d\u003d 0;\n    }\n\n    /**\n     * Returns {@code true} if this list contains the specified element.\n     * More formally, returns {@code true} if and only if this list contains\n     * at least one element {@code e} such that\n     * {@code Objects.equals(o, e)}.\n     *\n     * @param o element whose presence in this list is to be tested\n     * @return {@code true} if this list contains the specified element\n     */\n    public boolean contains(Object o) {\n        return indexOf(o) \u003e\u003d 0;\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the lowest index {@code i} such that\n     * {@code Objects.equals(o, get(i))},\n     * or -1 if there is no such index.\n     */\n    public int indexOf(Object o) {\n        return indexOfRange(o, 0, size);\n    }\n\n    int indexOfRange(Object o, int start, int end) {\n        Object[] es \u003d elementData;\n        if (o \u003d\u003d null) {\n            for (int i \u003d start; i \u003c end; i++) {\n                if (es[i] \u003d\u003d null) {\n                    return i;\n                }\n            }\n        } else {\n            for (int i \u003d start; i \u003c end; i++) {\n                if (o.equals(es[i])) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the index of the last occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the highest index {@code i} such that\n     * {@code Objects.equals(o, get(i))},\n     * or -1 if there is no such index.\n     */\n    public int lastIndexOf(Object o) {\n        return lastIndexOfRange(o, 0, size);\n    }\n\n    int lastIndexOfRange(Object o, int start, int end) {\n        Object[] es \u003d elementData;\n        if (o \u003d\u003d null) {\n            for (int i \u003d end - 1; i \u003e\u003d start; i--) {\n                if (es[i] \u003d\u003d null) {\n                    return i;\n                }\n            }\n        } else {\n            for (int i \u003d end - 1; i \u003e\u003d start; i--) {\n                if (o.equals(es[i])) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns a shallow copy of this {@code ArrayList} instance.  (The\n     * elements themselves are not copied.)\n     *\n     * @return a clone of this {@code ArrayList} instance\n     */\n    public Object clone() {\n        try {\n            ArrayList\u003c?\u003e v \u003d (ArrayList\u003c?\u003e) super.clone();\n            v.elementData \u003d Arrays.copyOf(elementData, size);\n            v.modCount \u003d 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // this shouldn\u0027t happen, since we are Cloneable\n            throw new InternalError(e);\n        }\n    }\n\n    /**\n     * Returns an array containing all of the elements in this list\n     * in proper sequence (from first to last element).\n     *\n     * \u003cp\u003eThe returned array will be \"safe\" in that no references to it are\n     * maintained by this list.  (In other words, this method must allocate\n     * a new array).  The caller is thus free to modify the returned array.\n     *\n     * \u003cp\u003eThis method acts as bridge between array-based and collection-based\n     * APIs.\n     *\n     * @return an array containing all of the elements in this list in\n     *         proper sequence\n     */\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * Returns an array containing all of the elements in this list in proper\n     * sequence (from first to last element); the runtime type of the returned\n     * array is that of the specified array.  If the list fits in the\n     * specified array, it is returned therein.  Otherwise, a new array is\n     * allocated with the runtime type of the specified array and the size of\n     * this list.\n     *\n     * \u003cp\u003eIf the list fits in the specified array with room to spare\n     * (i.e., the array has more elements than the list), the element in\n     * the array immediately following the end of the collection is set to\n     * {@code null}.  (This is useful in determining the length of the\n     * list \u003ci\u003eonly\u003c/i\u003e if the caller knows that the list does not contain\n     * any null elements.)\n     *\n     * @param a the array into which the elements of the list are to\n     *          be stored, if it is big enough; otherwise, a new array of the\n     *          same runtime type is allocated for this purpose.\n     * @return an array containing the elements of the list\n     * @throws ArrayStoreException if the runtime type of the specified array\n     *         is not a supertype of the runtime type of every element in\n     *         this list\n     * @throws NullPointerException if the specified array is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public \u003cT\u003e T[] toArray(T[] a) {\n        if (a.length \u003c size)\n            // Make a new array of a\u0027s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length \u003e size)\n            a[size] \u003d null;\n        return a;\n    }\n\n    // Positional Access Operations\n\n    @SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static \u003cE\u003e E elementAt(Object[] es, int index) {\n        return (E) es[index];\n    }\n\n    /**\n     * Returns the element at the specified position in this list.\n     *\n     * @param  index index of the element to return\n     * @return the element at the specified position in this list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E get(int index) {\n        Objects.checkIndex(index, size);\n        return elementData(index);\n    }\n\n    /**\n     * Replaces the element at the specified position in this list with\n     * the specified element.\n     *\n     * @param index index of the element to replace\n     * @param element element to be stored at the specified position\n     * @return the element previously at the specified position\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E set(int index, E element) {\n        Objects.checkIndex(index, size);\n        E oldValue \u003d elementData(index);\n        elementData[index] \u003d element;\n        return oldValue;\n    }\n\n    /**\n     * This helper method split out from add(E) to keep method\n     * bytecode size under 35 (the -XX:MaxInlineSize default value),\n     * which helps when add(E) is called in a C1-compiled loop.\n     */\n    private void add(E e, Object[] elementData, int s) {\n        if (s \u003d\u003d elementData.length)\n            elementData \u003d grow();\n        elementData[s] \u003d e;\n        size \u003d s + 1;\n    }\n\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n        modCount++;\n        add(e, elementData, size);\n        return true;\n    }\n\n    /**\n     * Inserts the specified element at the specified position in this\n     * list. Shifts the element currently at that position (if any) and\n     * any subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n        modCount++;\n        final int s;\n        Object[] elementData;\n        if ((s \u003d size) \u003d\u003d (elementData \u003d this.elementData).length)\n            elementData \u003d grow();\n        System.arraycopy(elementData, index,\n                         elementData, index + 1,\n                         s - index);\n        elementData[index] \u003d element;\n        size \u003d s + 1;\n    }\n\n    /**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their\n     * indices).\n     *\n     * @param index the index of the element to be removed\n     * @return the element that was removed from the list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        Objects.checkIndex(index, size);\n        final Object[] es \u003d elementData;\n\n        @SuppressWarnings(\"unchecked\") E oldValue \u003d (E) es[index];\n        fastRemove(es, index);\n\n        return oldValue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object o) {\n        if (o \u003d\u003d this) {\n            return true;\n        }\n\n        if (!(o instanceof List)) {\n            return false;\n        }\n\n        final int expectedModCount \u003d modCount;\n        // ArrayList can be subclassed and given arbitrary behavior, but we can\n        // still deal with the common case where o is ArrayList precisely\n        boolean equal \u003d (o.getClass() \u003d\u003d ArrayList.class)\n            ? equalsArrayList((ArrayList\u003c?\u003e) o)\n            : equalsRange((List\u003c?\u003e) o, 0, size);\n\n        checkForComodification(expectedModCount);\n        return equal;\n    }\n\n    boolean equalsRange(List\u003c?\u003e other, int from, int to) {\n        final Object[] es \u003d elementData;\n        if (to \u003e es.length) {\n            throw new ConcurrentModificationException();\n        }\n        var oit \u003d other.iterator();\n        for (; from \u003c to; from++) {\n            if (!oit.hasNext() || !Objects.equals(es[from], oit.next())) {\n                return false;\n            }\n        }\n        return !oit.hasNext();\n    }\n\n    private boolean equalsArrayList(ArrayList\u003c?\u003e other) {\n        final int otherModCount \u003d other.modCount;\n        final int s \u003d size;\n        boolean equal;\n        if (equal \u003d (s \u003d\u003d other.size)) {\n            final Object[] otherEs \u003d other.elementData;\n            final Object[] es \u003d elementData;\n            if (s \u003e es.length || s \u003e otherEs.length) {\n                throw new ConcurrentModificationException();\n            }\n            for (int i \u003d 0; i \u003c s; i++) {\n                if (!Objects.equals(es[i], otherEs[i])) {\n                    equal \u003d false;\n                    break;\n                }\n            }\n        }\n        other.checkForComodification(otherModCount);\n        return equal;\n    }\n\n    private void checkForComodification(final int expectedModCount) {\n        if (modCount !\u003d expectedModCount) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        int expectedModCount \u003d modCount;\n        int hash \u003d hashCodeRange(0, size);\n        checkForComodification(expectedModCount);\n        return hash;\n    }\n\n    int hashCodeRange(int from, int to) {\n        final Object[] es \u003d elementData;\n        if (to \u003e es.length) {\n            throw new ConcurrentModificationException();\n        }\n        int hashCode \u003d 1;\n        for (int i \u003d from; i \u003c to; i++) {\n            Object e \u003d es[i];\n            hashCode \u003d 31 * hashCode + (e \u003d\u003d null ? 0 : e.hashCode());\n        }\n        return hashCode;\n    }\n\n    /**\n     * Removes the first occurrence of the specified element from this list,\n     * if it is present.  If the list does not contain the element, it is\n     * unchanged.  More formally, removes the element with the lowest index\n     * {@code i} such that\n     * {@code Objects.equals(o, get(i))}\n     * (if such an element exists).  Returns {@code true} if this list\n     * contained the specified element (or equivalently, if this list\n     * changed as a result of the call).\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if this list contained the specified element\n     */\n    public boolean remove(Object o) {\n        final Object[] es \u003d elementData;\n        final int size \u003d this.size;\n        int i \u003d 0;\n        found: {\n            if (o \u003d\u003d null) {\n                for (; i \u003c size; i++)\n                    if (es[i] \u003d\u003d null)\n                        break found;\n            } else {\n                for (; i \u003c size; i++)\n                    if (o.equals(es[i]))\n                        break found;\n            }\n            return false;\n        }\n        fastRemove(es, i);\n        return true;\n    }\n\n    /**\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */\n    private void fastRemove(Object[] es, int i) {\n        modCount++;\n        final int newSize;\n        if ((newSize \u003d size - 1) \u003e i)\n            System.arraycopy(es, i + 1, es, i, newSize - i);\n        es[size \u003d newSize] \u003d null;\n    }\n\n    /**\n     * Removes all of the elements from this list.  The list will\n     * be empty after this call returns.\n     */\n    public void clear() {\n        modCount++;\n        final Object[] es \u003d elementData;\n        for (int to \u003d size, i \u003d size \u003d 0; i \u003c to; i++)\n            es[i] \u003d null;\n    }\n\n    /**\n     * Appends all of the elements in the specified collection to the end of\n     * this list, in the order that they are returned by the\n     * specified collection\u0027s Iterator.  The behavior of this operation is\n     * undefined if the specified collection is modified while the operation\n     * is in progress.  (This implies that the behavior of this call is\n     * undefined if the specified collection is this list, and this\n     * list is nonempty.)\n     *\n     * @param c collection containing elements to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws NullPointerException if the specified collection is null\n     */\n    public boolean addAll(Collection\u003c? extends E\u003e c) {\n        Object[] a \u003d c.toArray();\n        modCount++;\n        int numNew \u003d a.length;\n        if (numNew \u003d\u003d 0)\n            return false;\n        Object[] elementData;\n        final int s;\n        if (numNew \u003e (elementData \u003d this.elementData).length - (s \u003d size))\n            elementData \u003d grow(s + numNew);\n        System.arraycopy(a, 0, elementData, s, numNew);\n        size \u003d s + numNew;\n        return true;\n    }\n\n    /**\n     * Inserts all of the elements in the specified collection into this\n     * list, starting at the specified position.  Shifts the element\n     * currently at that position (if any) and any subsequent elements to\n     * the right (increases their indices).  The new elements will appear\n     * in the list in the order that they are returned by the\n     * specified collection\u0027s iterator.\n     *\n     * @param index index at which to insert the first element from the\n     *              specified collection\n     * @param c collection containing elements to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     * @throws NullPointerException if the specified collection is null\n     */\n    public boolean addAll(int index, Collection\u003c? extends E\u003e c) {\n        rangeCheckForAdd(index);\n\n        Object[] a \u003d c.toArray();\n        modCount++;\n        int numNew \u003d a.length;\n        if (numNew \u003d\u003d 0)\n            return false;\n        Object[] elementData;\n        final int s;\n        if (numNew \u003e (elementData \u003d this.elementData).length - (s \u003d size))\n            elementData \u003d grow(s + numNew);\n\n        int numMoved \u003d s - index;\n        if (numMoved \u003e 0)\n            System.arraycopy(elementData, index,\n                             elementData, index + numNew,\n                             numMoved);\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size \u003d s + numNew;\n        return true;\n    }\n\n    /**\n     * Removes from this list all of the elements whose index is between\n     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.\n     * Shifts any succeeding elements to the left (reduces their index).\n     * This call shortens the list by {@code (toIndex - fromIndex)} elements.\n     * (If {@code toIndex\u003d\u003dfromIndex}, this operation has no effect.)\n     *\n     * @throws IndexOutOfBoundsException if {@code fromIndex} or\n     *         {@code toIndex} is out of range\n     *         ({@code fromIndex \u003c 0 ||\n     *          toIndex \u003e size() ||\n     *          toIndex \u003c fromIndex})\n     */\n    protected void removeRange(int fromIndex, int toIndex) {\n        if (fromIndex \u003e toIndex) {\n            throw new IndexOutOfBoundsException(\n                    outOfBoundsMsg(fromIndex, toIndex));\n        }\n        modCount++;\n        shiftTailOverGap(elementData, fromIndex, toIndex);\n    }\n\n    /** Erases the gap from lo to hi, by sliding down following elements. */\n    private void shiftTailOverGap(Object[] es, int lo, int hi) {\n        System.arraycopy(es, hi, es, lo, size - hi);\n        for (int to \u003d size, i \u003d (size -\u003d hi - lo); i \u003c to; i++)\n            es[i] \u003d null;\n    }\n\n    /**\n     * A version of rangeCheck used by add and addAll.\n     */\n    private void rangeCheckForAdd(int index) {\n        if (index \u003e size || index \u003c 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * Constructs an IndexOutOfBoundsException detail message.\n     * Of the many possible refactorings of the error handling code,\n     * this \"outlining\" performs best with both server and client VMs.\n     */\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \"+index+\", Size: \"+size;\n    }\n\n    /**\n     * A version used in checking (fromIndex \u003e toIndex) condition\n     */\n    private static String outOfBoundsMsg(int fromIndex, int toIndex) {\n        return \"From Index: \" + fromIndex + \" \u003e To Index: \" + toIndex;\n    }\n\n    /**\n     * Removes from this list all of its elements that are contained in the\n     * specified collection.\n     *\n     * @param c collection containing elements to be removed from this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws ClassCastException if the class of an element of this list\n     *         is incompatible with the specified collection\n     * (\u003ca href\u003d\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\n     * @throws NullPointerException if this list contains a null element and the\n     *         specified collection does not permit null elements\n     * (\u003ca href\u003d\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e),\n     *         or if the specified collection is null\n     * @see Collection#contains(Object)\n     */\n    public boolean removeAll(Collection\u003c?\u003e c) {\n        return batchRemove(c, false, 0, size);\n    }\n\n    /**\n     * Retains only the elements in this list that are contained in the\n     * specified collection.  In other words, removes from this list all\n     * of its elements that are not contained in the specified collection.\n     *\n     * @param c collection containing elements to be retained in this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws ClassCastException if the class of an element of this list\n     *         is incompatible with the specified collection\n     * (\u003ca href\u003d\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\n     * @throws NullPointerException if this list contains a null element and the\n     *         specified collection does not permit null elements\n     * (\u003ca href\u003d\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e),\n     *         or if the specified collection is null\n     * @see Collection#contains(Object)\n     */\n    public boolean retainAll(Collection\u003c?\u003e c) {\n        return batchRemove(c, true, 0, size);\n    }\n\n    boolean batchRemove(Collection\u003c?\u003e c, boolean complement,\n                        final int from, final int end) {\n        Objects.requireNonNull(c);\n        final Object[] es \u003d elementData;\n        int r;\n        // Optimize for initial run of survivors\n        for (r \u003d from;; r++) {\n            if (r \u003d\u003d end)\n                return false;\n            if (c.contains(es[r]) !\u003d complement)\n                break;\n        }\n        int w \u003d r++;\n        try {\n            for (Object e; r \u003c end; r++)\n                if (c.contains(e \u003d es[r]) \u003d\u003d complement)\n                    es[w++] \u003d e;\n        } catch (Throwable ex) {\n            // Preserve behavioral compatibility with AbstractCollection,\n            // even if c.contains() throws.\n            System.arraycopy(es, r, es, w, end - r);\n            w +\u003d end - r;\n            throw ex;\n        } finally {\n            modCount +\u003d end - w;\n            shiftTailOverGap(es, w, end);\n        }\n        return true;\n    }\n\n    /**\n     * Saves the state of the {@code ArrayList} instance to a stream\n     * (that is, serializes it).\n     *\n     * @param s the stream\n     * @throws java.io.IOException if an I/O error occurs\n     * @serialData The length of the array backing the {@code ArrayList}\n     *             instance is emitted (int), followed by all of its elements\n     *             (each an {@code Object}) in the proper order.\n     */\n    @java.io.Serial\n    private void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException {\n        // Write out element count, and any hidden stuff\n        int expectedModCount \u003d modCount;\n        s.defaultWriteObject();\n\n        // Write out size as capacity for behavioral compatibility with clone()\n        s.writeInt(size);\n\n        // Write out all elements in the proper order.\n        for (int i\u003d0; i\u003csize; i++) {\n            s.writeObject(elementData[i]);\n        }\n\n        if (modCount !\u003d expectedModCount) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    /**\n     * Reconstitutes the {@code ArrayList} instance from a stream (that is,\n     * deserializes it).\n     * @param s the stream\n     * @throws ClassNotFoundException if the class of a serialized object\n     *         could not be found\n     * @throws java.io.IOException if an I/O error occurs\n     */\n    @java.io.Serial\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n\n        // Read in size, and any hidden stuff\n        s.defaultReadObject();\n\n        // Read in capacity\n        s.readInt(); // ignored\n\n        if (size \u003e 0) {\n            // like clone(), allocate array based upon size not capacity\n            SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);\n            Object[] elements \u003d new Object[size];\n\n            // Read in all elements in the proper order.\n            for (int i \u003d 0; i \u003c size; i++) {\n                elements[i] \u003d s.readObject();\n            }\n\n            elementData \u003d elements;\n        } else if (size \u003d\u003d 0) {\n            elementData \u003d EMPTY_ELEMENTDATA;\n        } else {\n            throw new java.io.InvalidObjectException(\"Invalid size: \" + size);\n        }\n    }\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper\n     * sequence), starting at the specified position in the list.\n     * The specified index indicates the first element that would be\n     * returned by an initial call to {@link ListIterator#next next}.\n     * An initial call to {@link ListIterator#previous previous} would\n     * return the element with the specified index minus one.\n     *\n     * \u003cp\u003eThe returned list iterator is \u003ca href\u003d\"#fail-fast\"\u003e\u003ci\u003efail-fast\u003c/i\u003e\u003c/a\u003e.\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public ListIterator\u003cE\u003e listIterator(int index) {\n        rangeCheckForAdd(index);\n        return new ListItr(index);\n    }\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper\n     * sequence).\n     *\n     * \u003cp\u003eThe returned list iterator is \u003ca href\u003d\"#fail-fast\"\u003e\u003ci\u003efail-fast\u003c/i\u003e\u003c/a\u003e.\n     *\n     * @see #listIterator(int)\n     */\n    public ListIterator\u003cE\u003e listIterator() {\n        return new ListItr(0);\n    }\n\n    /**\n     * Returns an iterator over the elements in this list in proper sequence.\n     *\n     * \u003cp\u003eThe returned iterator is \u003ca href\u003d\"#fail-fast\"\u003e\u003ci\u003efail-fast\u003c/i\u003e\u003c/a\u003e.\n     *\n     * @return an iterator over the elements in this list in proper sequence\n     */\n    public Iterator\u003cE\u003e iterator() {\n        return new Itr();\n    }\n\n    /**\n     * An optimized version of AbstractList.Itr\n     */\n    private class Itr implements Iterator\u003cE\u003e {\n        int cursor;       // index of next element to return\n        int lastRet \u003d -1; // index of last element returned; -1 if no such\n        int expectedModCount \u003d modCount;\n\n        // prevent creating a synthetic constructor\n        Itr() {}\n\n        public boolean hasNext() {\n            return cursor !\u003d size;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public E next() {\n            checkForComodification();\n            int i \u003d cursor;\n            if (i \u003e\u003d size)\n                throw new NoSuchElementException();\n            Object[] elementData \u003d ArrayList.this.elementData;\n            if (i \u003e\u003d elementData.length)\n                throw new ConcurrentModificationException();\n            cursor \u003d i + 1;\n            return (E) elementData[lastRet \u003d i];\n        }\n\n        public void remove() {\n            if (lastRet \u003c 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try {\n                ArrayList.this.remove(lastRet);\n                cursor \u003d lastRet;\n                lastRet \u003d -1;\n                expectedModCount \u003d modCount;\n            } catch (IndexOutOfBoundsException ex) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        @Override\n        public void forEachRemaining(Consumer\u003c? super E\u003e action) {\n            Objects.requireNonNull(action);\n            final int size \u003d ArrayList.this.size;\n            int i \u003d cursor;\n            if (i \u003c size) {\n                final Object[] es \u003d elementData;\n                if (i \u003e\u003d es.length)\n                    throw new ConcurrentModificationException();\n                for (; i \u003c size \u0026\u0026 modCount \u003d\u003d expectedModCount; i++)\n                    action.accept(elementAt(es, i));\n                // update once at end to reduce heap write traffic\n                cursor \u003d i;\n                lastRet \u003d i - 1;\n                checkForComodification();\n            }\n        }\n\n        final void checkForComodification() {\n            if (modCount !\u003d expectedModCount)\n                throw new ConcurrentModificationException();\n        }\n    }\n\n    /**\n     * An optimized version of AbstractList.ListItr\n     */\n    private class ListItr extends Itr implements ListIterator\u003cE\u003e {\n        ListItr(int index) {\n            super();\n            cursor \u003d index;\n        }\n\n        public boolean hasPrevious() {\n            return cursor !\u003d 0;\n        }\n\n        public int nextIndex() {\n            return cursor;\n        }\n\n        public int previousIndex() {\n            return cursor - 1;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public E previous() {\n            checkForComodification();\n            int i \u003d cursor - 1;\n            if (i \u003c 0)\n                throw new NoSuchElementException();\n            Object[] elementData \u003d ArrayList.this.elementData;\n            if (i \u003e\u003d elementData.length)\n                throw new ConcurrentModificationException();\n            cursor \u003d i;\n            return (E) elementData[lastRet \u003d i];\n        }\n\n        public void set(E e) {\n            if (lastRet \u003c 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try {\n                ArrayList.this.set(lastRet, e);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        public void add(E e) {\n            checkForComodification();\n\n            try {\n                int i \u003d cursor;\n                ArrayList.this.add(i, e);\n                cursor \u003d i + 1;\n                lastRet \u003d -1;\n                expectedModCount \u003d modCount;\n            } catch (IndexOutOfBoundsException ex) {\n                throw new ConcurrentModificationException();\n            }\n        }\n    }\n\n    /**\n     * Returns a view of the portion of this list between the specified\n     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If\n     * {@code fromIndex} and {@code toIndex} are equal, the returned list is\n     * empty.)  The returned list is backed by this list, so non-structural\n     * changes in the returned list are reflected in this list, and vice-versa.\n     * The returned list supports all of the optional list operations.\n     *\n     * \u003cp\u003eThis method eliminates the need for explicit range operations (of\n     * the sort that commonly exist for arrays).  Any operation that expects\n     * a list can be used as a range operation by passing a subList view\n     * instead of a whole list.  For example, the following idiom\n     * removes a range of elements from a list:\n     * \u003cpre\u003e\n     *      list.subList(from, to).clear();\n     * \u003c/pre\u003e\n     * Similar idioms may be constructed for {@link #indexOf(Object)} and\n     * {@link #lastIndexOf(Object)}, and all of the algorithms in the\n     * {@link Collections} class can be applied to a subList.\n     *\n     * \u003cp\u003eThe semantics of the list returned by this method become undefined if\n     * the backing list (i.e., this list) is \u003ci\u003estructurally modified\u003c/i\u003e in\n     * any way other than via the returned list.  (Structural modifications are\n     * those that change the size of this list, or otherwise perturb it in such\n     * a fashion that iterations in progress may yield incorrect results.)\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     */\n    public List\u003cE\u003e subList(int fromIndex, int toIndex) {\n        subListRangeCheck(fromIndex, toIndex, size);\n        return new SubList\u003c\u003e(this, fromIndex, toIndex);\n    }\n\n    private static class SubList\u003cE\u003e extends AbstractList\u003cE\u003e implements RandomAccess {\n        private final ArrayList\u003cE\u003e root;\n        private final SubList\u003cE\u003e parent;\n        private final int offset;\n        private int size;\n\n        /**\n         * Constructs a sublist of an arbitrary ArrayList.\n         */\n        public SubList(ArrayList\u003cE\u003e root, int fromIndex, int toIndex) {\n            this.root \u003d root;\n            this.parent \u003d null;\n            this.offset \u003d fromIndex;\n            this.size \u003d toIndex - fromIndex;\n            this.modCount \u003d root.modCount;\n        }\n\n        /**\n         * Constructs a sublist of another SubList.\n         */\n        private SubList(SubList\u003cE\u003e parent, int fromIndex, int toIndex) {\n            this.root \u003d parent.root;\n            this.parent \u003d parent;\n            this.offset \u003d parent.offset + fromIndex;\n            this.size \u003d toIndex - fromIndex;\n            this.modCount \u003d parent.modCount;\n        }\n\n        public E set(int index, E element) {\n            Objects.checkIndex(index, size);\n            checkForComodification();\n            E oldValue \u003d root.elementData(offset + index);\n            root.elementData[offset + index] \u003d element;\n            return oldValue;\n        }\n\n        public E get(int index) {\n            Objects.checkIndex(index, size);\n            checkForComodification();\n            return root.elementData(offset + index);\n        }\n\n        public int size() {\n            checkForComodification();\n            return size;\n        }\n\n        public void add(int index, E element) {\n            rangeCheckForAdd(index);\n            checkForComodification();\n            root.add(offset + index, element);\n            updateSizeAndModCount(1);\n        }\n\n        public E remove(int index) {\n            Objects.checkIndex(index, size);\n            checkForComodification();\n            E result \u003d root.remove(offset + index);\n            updateSizeAndModCount(-1);\n            return result;\n        }\n\n        protected void removeRange(int fromIndex, int toIndex) {\n            checkForComodification();\n            root.removeRange(offset + fromIndex, offset + toIndex);\n            updateSizeAndModCount(fromIndex - toIndex);\n        }\n\n        public boolean addAll(Collection\u003c? extends E\u003e c) {\n            return addAll(this.size, c);\n        }\n\n        public boolean addAll(int index, Collection\u003c? extends E\u003e c) {\n            rangeCheckForAdd(index);\n            int cSize \u003d c.size();\n            if (cSize\u003d\u003d0)\n                return false;\n            checkForComodification();\n            root.addAll(offset + index, c);\n            updateSizeAndModCount(cSize);\n            return true;\n        }\n\n        public void replaceAll(UnaryOperator\u003cE\u003e operator) {\n            root.replaceAllRange(operator, offset, offset + size);\n        }\n\n        public boolean removeAll(Collection\u003c?\u003e c) {\n            return batchRemove(c, false);\n        }\n\n        public boolean retainAll(Collection\u003c?\u003e c) {\n            return batchRemove(c, true);\n        }\n\n        private boolean batchRemove(Collection\u003c?\u003e c, boolean complement) {\n            checkForComodification();\n            int oldSize \u003d root.size;\n            boolean modified \u003d\n                root.batchRemove(c, complement, offset, offset + size);\n            if (modified)\n                updateSizeAndModCount(root.size - oldSize);\n            return modified;\n        }\n\n        public boolean removeIf(Predicate\u003c? super E\u003e filter) {\n            checkForComodification();\n            int oldSize \u003d root.size;\n            boolean modified \u003d root.removeIf(filter, offset, offset + size);\n            if (modified)\n                updateSizeAndModCount(root.size - oldSize);\n            return modified;\n        }\n\n        public Object[] toArray() {\n            checkForComodification();\n            return Arrays.copyOfRange(root.elementData, offset, offset + size);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public \u003cT\u003e T[] toArray(T[] a) {\n            checkForComodification();\n            if (a.length \u003c size)\n                return (T[]) Arrays.copyOfRange(\n                        root.elementData, offset, offset + size, a.getClass());\n            System.arraycopy(root.elementData, offset, a, 0, size);\n            if (a.length \u003e size)\n                a[size] \u003d null;\n            return a;\n        }\n\n        public boolean equals(Object o) {\n            if (o \u003d\u003d this) {\n                return true;\n            }\n\n            if (!(o instanceof List)) {\n                return false;\n            }\n\n            boolean equal \u003d root.equalsRange((List\u003c?\u003e)o, offset, offset + size);\n            checkForComodification();\n            return equal;\n        }\n\n        public int hashCode() {\n            int hash \u003d root.hashCodeRange(offset, offset + size);\n            checkForComodification();\n            return hash;\n        }\n\n        public int indexOf(Object o) {\n            int index \u003d root.indexOfRange(o, offset, offset + size);\n            checkForComodification();\n            return index \u003e\u003d 0 ? index - offset : -1;\n        }\n\n        public int lastIndexOf(Object o) {\n            int index \u003d root.lastIndexOfRange(o, offset, offset + size);\n            checkForComodification();\n            return index \u003e\u003d 0 ? index - offset : -1;\n        }\n\n        public boolean contains(Object o) {\n            return indexOf(o) \u003e\u003d 0;\n        }\n\n        public Iterator\u003cE\u003e iterator() {\n            return listIterator();\n        }\n\n        public ListIterator\u003cE\u003e listIterator(int index) {\n            checkForComodification();\n            rangeCheckForAdd(index);\n\n            return new ListIterator\u003cE\u003e() {\n                int cursor \u003d index;\n                int lastRet \u003d -1;\n                int expectedModCount \u003d SubList.this.modCount;\n\n                public boolean hasNext() {\n                    return cursor !\u003d SubList.this.size;\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                public E next() {\n                    checkForComodification();\n                    int i \u003d cursor;\n                    if (i \u003e\u003d SubList.this.size)\n                        throw new NoSuchElementException();\n                    Object[] elementData \u003d root.elementData;\n                    if (offset + i \u003e\u003d elementData.length)\n                        throw new ConcurrentModificationException();\n                    cursor \u003d i + 1;\n                    return (E) elementData[offset + (lastRet \u003d i)];\n                }\n\n                public boolean hasPrevious() {\n                    return cursor !\u003d 0;\n                }\n\n                @SuppressWarnings(\"unchecked\")\n                public E previous() {\n                    checkForComodification();\n                    int i \u003d cursor - 1;\n                    if (i \u003c 0)\n                        throw new NoSuchElementException();\n                    Object[] elementData \u003d root.elementData;\n                    if (offset + i \u003e\u003d elementData.length)\n                        throw new ConcurrentModificationException();\n                    cursor \u003d i;\n                    return (E) elementData[offset + (lastRet \u003d i)];\n                }\n\n                public void forEachRemaining(Consumer\u003c? super E\u003e action) {\n                    Objects.requireNonNull(action);\n                    final int size \u003d SubList.this.size;\n                    int i \u003d cursor;\n                    if (i \u003c size) {\n                        final Object[] es \u003d root.elementData;\n                        if (offset + i \u003e\u003d es.length)\n                            throw new ConcurrentModificationException();\n                        for (; i \u003c size \u0026\u0026 root.modCount \u003d\u003d expectedModCount; i++)\n                            action.accept(elementAt(es, offset + i));\n                        // update once at end to reduce heap write traffic\n                        cursor \u003d i;\n                        lastRet \u003d i - 1;\n                        checkForComodification();\n                    }\n                }\n\n                public int nextIndex() {\n                    return cursor;\n                }\n\n                public int previousIndex() {\n                    return cursor - 1;\n                }\n\n                public void remove() {\n                    if (lastRet \u003c 0)\n                        throw new IllegalStateException();\n                    checkForComodification();\n\n                    try {\n                        SubList.this.remove(lastRet);\n                        cursor \u003d lastRet;\n                        lastRet \u003d -1;\n                        expectedModCount \u003d SubList.this.modCount;\n                    } catch (IndexOutOfBoundsException ex) {\n                        throw new ConcurrentModificationException();\n                    }\n                }\n\n                public void set(E e) {\n                    if (lastRet \u003c 0)\n                        throw new IllegalStateException();\n                    checkForComodification();\n\n                    try {\n                        root.set(offset + lastRet, e);\n                    } catch (IndexOutOfBoundsException ex) {\n                        throw new ConcurrentModificationException();\n                    }\n                }\n\n                public void add(E e) {\n                    checkForComodification();\n\n                    try {\n                        int i \u003d cursor;\n                        SubList.this.add(i, e);\n                        cursor \u003d i + 1;\n                        lastRet \u003d -1;\n                        expectedModCount \u003d SubList.this.modCount;\n                    } catch (IndexOutOfBoundsException ex) {\n                        throw new ConcurrentModificationException();\n                    }\n                }\n\n                final void checkForComodification() {\n                    if (root.modCount !\u003d expectedModCount)\n                        throw new ConcurrentModificationException();\n                }\n            };\n        }\n\n        public List\u003cE\u003e subList(int fromIndex, int toIndex) {\n            subListRangeCheck(fromIndex, toIndex, size);\n            return new SubList\u003c\u003e(this, fromIndex, toIndex);\n        }\n\n        private void rangeCheckForAdd(int index) {\n            if (index \u003c 0 || index \u003e this.size)\n                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n        }\n\n        private String outOfBoundsMsg(int index) {\n            return \"Index: \"+index+\", Size: \"+this.size;\n        }\n\n        private void checkForComodification() {\n            if (root.modCount !\u003d modCount)\n                throw new ConcurrentModificationException();\n        }\n\n        private void updateSizeAndModCount(int sizeChange) {\n            SubList\u003cE\u003e slist \u003d this;\n            do {\n                slist.size +\u003d sizeChange;\n                slist.modCount \u003d root.modCount;\n                slist \u003d slist.parent;\n            } while (slist !\u003d null);\n        }\n\n        public Spliterator\u003cE\u003e spliterator() {\n            checkForComodification();\n\n            // ArrayListSpliterator not used here due to late-binding\n            return new Spliterator\u003cE\u003e() {\n                private int index \u003d offset; // current index, modified on advance/split\n                private int fence \u003d -1; // -1 until used; then one past last index\n                private int expectedModCount; // initialized when fence set\n\n                private int getFence() { // initialize fence to size on first use\n                    int hi; // (a specialized variant appears in method forEach)\n                    if ((hi \u003d fence) \u003c 0) {\n                        expectedModCount \u003d modCount;\n                        hi \u003d fence \u003d offset + size;\n                    }\n                    return hi;\n                }\n\n                public ArrayList\u003cE\u003e.ArrayListSpliterator trySplit() {\n                    int hi \u003d getFence(), lo \u003d index, mid \u003d (lo + hi) \u003e\u003e\u003e 1;\n                    // ArrayListSpliterator can be used here as the source is already bound\n                    return (lo \u003e\u003d mid) ? null : // divide range in half unless too small\n                        root.new ArrayListSpliterator(lo, index \u003d mid, expectedModCount);\n                }\n\n                public boolean tryAdvance(Consumer\u003c? super E\u003e action) {\n                    Objects.requireNonNull(action);\n                    int hi \u003d getFence(), i \u003d index;\n                    if (i \u003c hi) {\n                        index \u003d i + 1;\n                        @SuppressWarnings(\"unchecked\") E e \u003d (E)root.elementData[i];\n                        action.accept(e);\n                        if (root.modCount !\u003d expectedModCount)\n                            throw new ConcurrentModificationException();\n                        return true;\n                    }\n                    return false;\n                }\n\n                public void forEachRemaining(Consumer\u003c? super E\u003e action) {\n                    Objects.requireNonNull(action);\n                    int i, hi, mc; // hoist accesses and checks from loop\n                    ArrayList\u003cE\u003e lst \u003d root;\n                    Object[] a;\n                    if ((a \u003d lst.elementData) !\u003d null) {\n                        if ((hi \u003d fence) \u003c 0) {\n                            mc \u003d modCount;\n                            hi \u003d offset + size;\n                        }\n                        else\n                            mc \u003d expectedModCount;\n                        if ((i \u003d index) \u003e\u003d 0 \u0026\u0026 (index \u003d hi) \u003c\u003d a.length) {\n                            for (; i \u003c hi; ++i) {\n                                @SuppressWarnings(\"unchecked\") E e \u003d (E) a[i];\n                                action.accept(e);\n                            }\n                            if (lst.modCount \u003d\u003d mc)\n                                return;\n                        }\n                    }\n                    throw new ConcurrentModificationException();\n                }\n\n                public long estimateSize() {\n                    return getFence() - index;\n                }\n\n                public int characteristics() {\n                    return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;\n                }\n            };\n        }\n    }\n\n    /**\n     * @throws NullPointerException {@inheritDoc}\n     */\n    @Override\n    public void forEach(Consumer\u003c? super E\u003e action) {\n        Objects.requireNonNull(action);\n        final int expectedModCount \u003d modCount;\n        final Object[] es \u003d elementData;\n        final int size \u003d this.size;\n        for (int i \u003d 0; modCount \u003d\u003d expectedModCount \u0026\u0026 i \u003c size; i++)\n            action.accept(elementAt(es, i));\n        if (modCount !\u003d expectedModCount)\n            throw new ConcurrentModificationException();\n    }\n\n    /**\n     * Creates a \u003cem\u003e\u003ca href\u003d\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e\n     * and \u003cem\u003efail-fast\u003c/em\u003e {@link Spliterator} over the elements in this\n     * list.\n     *\n     * \u003cp\u003eThe {@code Spliterator} reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.\n     * Overriding implementations should document the reporting of additional\n     * characteristic values.\n     *\n     * @return a {@code Spliterator} over the elements in this list\n     * @since 1.8\n     */\n    @Override\n    public Spliterator\u003cE\u003e spliterator() {\n        return new ArrayListSpliterator(0, -1, 0);\n    }\n\n    /** Index-based split-by-two, lazily initialized Spliterator */\n    final class ArrayListSpliterator implements Spliterator\u003cE\u003e {\n\n        /*\n         * If ArrayLists were immutable, or structurally immutable (no\n         * adds, removes, etc), we could implement their spliterators\n         * with Arrays.spliterator. Instead we detect as much\n         * interference during traversal as practical without\n         * sacrificing much performance. We rely primarily on\n         * modCounts. These are not guaranteed to detect concurrency\n         * violations, and are sometimes overly conservative about\n         * within-thread interference, but detect enough problems to\n         * be worthwhile in practice. To carry this out, we (1) lazily\n         * initialize fence and expectedModCount until the latest\n         * point that we need to commit to the state we are checking\n         * against; thus improving precision.  (This doesn\u0027t apply to\n         * SubLists, that create spliterators with current non-lazy\n         * values).  (2) We perform only a single\n         * ConcurrentModificationException check at the end of forEach\n         * (the most performance-sensitive method). When using forEach\n         * (as opposed to iterators), we can normally only detect\n         * interference after actions, not before. Further\n         * CME-triggering checks apply to all other possible\n         * violations of assumptions for example null or too-small\n         * elementData array given its size(), that could only have\n         * occurred due to interference.  This allows the inner loop\n         * of forEach to run without any further checks, and\n         * simplifies lambda-resolution. While this does entail a\n         * number of checks, note that in the common case of\n         * list.stream().forEach(a), no checks or other computation\n         * occur anywhere other than inside forEach itself.  The other\n         * less-often-used methods cannot take advantage of most of\n         * these streamlinings.\n         */\n\n        private int index; // current index, modified on advance/split\n        private int fence; // -1 until used; then one past last index\n        private int expectedModCount; // initialized when fence set\n\n        /** Creates new spliterator covering the given range. */\n        ArrayListSpliterator(int origin, int fence, int expectedModCount) {\n            this.index \u003d origin;\n            this.fence \u003d fence;\n            this.expectedModCount \u003d expectedModCount;\n        }\n\n        private int getFence() { // initialize fence to size on first use\n            int hi; // (a specialized variant appears in method forEach)\n            if ((hi \u003d fence) \u003c 0) {\n                expectedModCount \u003d modCount;\n                hi \u003d fence \u003d size;\n            }\n            return hi;\n        }\n\n        public ArrayListSpliterator trySplit() {\n            int hi \u003d getFence(), lo \u003d index, mid \u003d (lo + hi) \u003e\u003e\u003e 1;\n            return (lo \u003e\u003d mid) ? null : // divide range in half unless too small\n                new ArrayListSpliterator(lo, index \u003d mid, expectedModCount);\n        }\n\n        public boolean tryAdvance(Consumer\u003c? super E\u003e action) {\n            if (action \u003d\u003d null)\n                throw new NullPointerException();\n            int hi \u003d getFence(), i \u003d index;\n            if (i \u003c hi) {\n                index \u003d i + 1;\n                @SuppressWarnings(\"unchecked\") E e \u003d (E)elementData[i];\n                action.accept(e);\n                if (modCount !\u003d expectedModCount)\n                    throw new ConcurrentModificationException();\n                return true;\n            }\n            return false;\n        }\n\n        public void forEachRemaining(Consumer\u003c? super E\u003e action) {\n            int i, hi, mc; // hoist accesses and checks from loop\n            Object[] a;\n            if (action \u003d\u003d null)\n                throw new NullPointerException();\n            if ((a \u003d elementData) !\u003d null) {\n                if ((hi \u003d fence) \u003c 0) {\n                    mc \u003d modCount;\n                    hi \u003d size;\n                }\n                else\n                    mc \u003d expectedModCount;\n                if ((i \u003d index) \u003e\u003d 0 \u0026\u0026 (index \u003d hi) \u003c\u003d a.length) {\n                    for (; i \u003c hi; ++i) {\n                        @SuppressWarnings(\"unchecked\") E e \u003d (E) a[i];\n                        action.accept(e);\n                    }\n                    if (modCount \u003d\u003d mc)\n                        return;\n                }\n            }\n            throw new ConcurrentModificationException();\n        }\n\n        public long estimateSize() {\n            return getFence() - index;\n        }\n\n        public int characteristics() {\n            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;\n        }\n    }\n\n    // A tiny bit set implementation\n\n    private static long[] nBits(int n) {\n        return new long[((n - 1) \u003e\u003e 6) + 1];\n    }\n    private static void setBit(long[] bits, int i) {\n        bits[i \u003e\u003e 6] |\u003d 1L \u003c\u003c i;\n    }\n    private static boolean isClear(long[] bits, int i) {\n        return (bits[i \u003e\u003e 6] \u0026 (1L \u003c\u003c i)) \u003d\u003d 0;\n    }\n\n    /**\n     * @throws NullPointerException {@inheritDoc}\n     */\n    @Override\n    public boolean removeIf(Predicate\u003c? super E\u003e filter) {\n        return removeIf(filter, 0, size);\n    }\n\n    /**\n     * Removes all elements satisfying the given predicate, from index\n     * i (inclusive) to index end (exclusive).\n     */\n    boolean removeIf(Predicate\u003c? super E\u003e filter, int i, final int end) {\n        Objects.requireNonNull(filter);\n        int expectedModCount \u003d modCount;\n        final Object[] es \u003d elementData;\n        // Optimize for initial run of survivors\n        for (; i \u003c end \u0026\u0026 !filter.test(elementAt(es, i)); i++)\n            ;\n        // Tolerate predicates that reentrantly access the collection for\n        // read (but writers still get CME), so traverse once to find\n        // elements to delete, a second pass to physically expunge.\n        if (i \u003c end) {\n            final int beg \u003d i;\n            final long[] deathRow \u003d nBits(end - beg);\n            deathRow[0] \u003d 1L;   // set bit 0\n            for (i \u003d beg + 1; i \u003c end; i++)\n                if (filter.test(elementAt(es, i)))\n                    setBit(deathRow, i - beg);\n            if (modCount !\u003d expectedModCount)\n                throw new ConcurrentModificationException();\n            modCount++;\n            int w \u003d beg;\n            for (i \u003d beg; i \u003c end; i++)\n                if (isClear(deathRow, i - beg))\n                    es[w++] \u003d es[i];\n            shiftTailOverGap(es, w, end);\n            return true;\n        } else {\n            if (modCount !\u003d expectedModCount)\n                throw new ConcurrentModificationException();\n            return false;\n        }\n    }\n\n    @Override\n    public void replaceAll(UnaryOperator\u003cE\u003e operator) {\n        replaceAllRange(operator, 0, size);\n        // TODO(8203662): remove increment of modCount from ...\n        modCount++;\n    }\n\n    private void replaceAllRange(UnaryOperator\u003cE\u003e operator, int i, int end) {\n        Objects.requireNonNull(operator);\n        final int expectedModCount \u003d modCount;\n        final Object[] es \u003d elementData;\n        for (; modCount \u003d\u003d expectedModCount \u0026\u0026 i \u003c end; i++)\n            es[i] \u003d operator.apply(elementAt(es, i));\n        if (modCount !\u003d expectedModCount)\n            throw new ConcurrentModificationException();\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void sort(Comparator\u003c? super E\u003e c) {\n        final int expectedModCount \u003d modCount;\n        Arrays.sort((E[]) elementData, 0, size, c);\n        if (modCount !\u003d expectedModCount)\n            throw new ConcurrentModificationException();\n        modCount++;\n    }\n\n    void checkInvariants() {\n        // assert size \u003e\u003d 0;\n        // assert size \u003d\u003d elementData.length || elementData[size] \u003d\u003d null;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

ene 27, 2024 3:31:41 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/util/ArrayList.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/ArrayList.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

ene 27, 2024 3:31:56 P.M. scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 6944, count -1, length 6961
2024.01.27 15:31:59 INFO  compiling root-test (1 scala source)
2024.01.27 15:32:00 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:31:59 INFO  time: compiled root-test in 0.65s
ene 27, 2024 3:32:05 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 369
2024.01.27 15:32:10 INFO  compiling root-test (1 scala source)
ene 27, 2024 3:32:10 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 399
2024.01.27 15:32:10 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 2m 16.662s)
2024.01.27 15:32:10 INFO  compiling root-test (1 scala source)
2024.01.27 15:32:10 INFO  time: compiled root-test in 0.48s
2024.01.27 15:32:11 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:32:11 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:32:11 INFO  Starting debug proxy for [test.scala.Tests(JavaFunctions can't distribute actions)]
2024.01.27 15:32:11 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53234 .
2024.01.27 15:32:11 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:32:11 INFO  Closing debug server tcp://0.0.0.0:53231
2024.01.27 15:32:11 INFO  Canceling debug proxy for [test.scala.Tests(JavaFunctions can't distribute actions)]
2024.01.27 15:33:09 INFO  compiling root-test (1 scala source)
2024.01.27 15:33:09 INFO  time: compiled root-test in 0.18s
ene 27, 2024 3:33:10 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.apply(FutureConvertersImpl.scala:29)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.apply(FutureConvertersImpl.scala:26)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at scala.concurrent.ExecutionContext$parasitic$.execute(ExecutionContext.scala:222)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:504)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$.<clinit>(DebugProvider.scala:912)
	at scala.meta.internal.metals.debug.DebugProvider.ensureNoWorkspaceErrors(DebugProvider.scala:388)
	at scala.meta.internal.metals.debug.DebugProvider.$anonfun$startTestSuite$4(DebugProvider.scala:681)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.01.27 15:33:09 INFO  compiling root-test (1 scala source)
2024.01.27 15:33:09 INFO  time: compiled root-test in 99ms
2024.01.27 15:33:10 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:24 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:24 INFO  compiling root-test (1 scala source)
2024.01.27 15:33:24 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:24 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:24 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:24 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:24 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:24 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:24 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:24 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:24 INFO  time: compiled root-test in 0.13s
2024.01.27 15:33:25 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:26 INFO  compiling root-test (1 scala source)
2024.01.27 15:33:26 INFO  time: compiled root-test in 0.14s
ene 27, 2024 3:33:26 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.apply(FutureConvertersImpl.scala:29)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.apply(FutureConvertersImpl.scala:26)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at scala.concurrent.ExecutionContext$parasitic$.execute(ExecutionContext.scala:222)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:504)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$.<clinit>(DebugProvider.scala:912)
	at scala.meta.internal.metals.debug.DebugProvider.ensureNoWorkspaceErrors(DebugProvider.scala:388)
	at scala.meta.internal.metals.debug.DebugProvider.$anonfun$startTestSuite$4(DebugProvider.scala:681)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.01.27 15:33:27 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:29 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:30 INFO  compiling root-test (1 scala source)
2024.01.27 15:33:30 INFO  time: compiled root-test in 0.12s
2024.01.27 15:33:30 INFO  compiling root-test (1 scala source)
2024.01.27 15:33:30 INFO  time: compiled root-test in 98ms
2024.01.27 15:33:31 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:32 INFO  compiling root-test (1 scala source)
2024.01.27 15:33:32 INFO  time: compiled root-test in 0.12s
ene 27, 2024 3:33:32 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.apply(FutureConvertersImpl.scala:29)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.apply(FutureConvertersImpl.scala:26)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at scala.concurrent.ExecutionContext$parasitic$.execute(ExecutionContext.scala:222)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:504)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$.<clinit>(DebugProvider.scala:912)
	at scala.meta.internal.metals.debug.DebugProvider.ensureNoWorkspaceErrors(DebugProvider.scala:388)
	at scala.meta.internal.metals.debug.DebugProvider.$anonfun$startTestSuite$4(DebugProvider.scala:681)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.01.27 15:33:33 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:41 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:46 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:50 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:51 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:52 INFO  compiling root-test (1 scala source)
2024.01.27 15:33:52 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:33:52 INFO  time: compiled root-test in 0.6s
2024.01.27 15:33:53 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:33:53 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:33:53 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:33:53 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53255 .
2024.01.27 15:33:53 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:33:53 INFO  Closing debug server tcp://0.0.0.0:53252
2024.01.27 15:33:54 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:34:13 INFO  compiling root-test (1 scala source)
Exception in thread "pool-6-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024.01.27 15:34:13 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 4m 20.549s)
2024.01.27 15:34:13 INFO  compiling root-test (1 scala source)
2024.01.27 15:34:13 INFO  time: compiled root-test in 0.29s
2024.01.27 15:34:14 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:34:14 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:34:14 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:34:14 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53264 .
2024.01.27 15:34:14 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:34:14 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:34:14 INFO  Closing debug server tcp://0.0.0.0:53261
2024.01.27 15:35:20 INFO  compiling root-test (1 scala source)
2024.01.27 15:35:20 INFO  time: compiled root-test in 0.11s
2024.01.27 15:35:21 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:35:21 INFO  compiling root-test (1 scala source)
2024.01.27 15:35:21 INFO  time: compiled root-test in 0.12s
ene 27, 2024 3:35:21 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
java.util.concurrent.CompletionException: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.apply(FutureConvertersImpl.scala:29)
	at scala.concurrent.java8.FuturesConvertersImpl$CF.apply(FutureConvertersImpl.scala:26)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at scala.concurrent.ExecutionContext$parasitic$.execute(ExecutionContext.scala:222)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:504)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
Caused by: scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$: Cannot run class, since the workspace has errors.
	at scala.meta.internal.metals.debug.DebugProvider$WorkspaceErrorsException$.<clinit>(DebugProvider.scala:912)
	at scala.meta.internal.metals.debug.DebugProvider.ensureNoWorkspaceErrors(DebugProvider.scala:388)
	at scala.meta.internal.metals.debug.DebugProvider.$anonfun$startTestSuite$4(DebugProvider.scala:681)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.01.27 15:35:22 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:35:30 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:35:31 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:35:31 INFO  compiling root-test (1 scala source)
2024.01.27 15:35:31 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:35:31 INFO  time: compiled root-test in 0.61s
2024.01.27 15:35:42 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:35:42 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:35:42 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:35:42 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53279 .
2024.01.27 15:35:42 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:35:43 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:35:42 INFO  Closing debug server tcp://0.0.0.0:53276
2024.01.27 15:36:52 INFO  compiling root-test (1 scala source)
2024.01.27 15:36:52 INFO  time: compiled root-test in 0.81s
2024.01.27 15:37:00 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:37:00 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:37:01 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:37:01 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53381 .
2024.01.27 15:37:01 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:37:01 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:37:01 INFO  Closing debug server tcp://0.0.0.0:53377
2024.01.27 15:37:10 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:37:10 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:37:10 INFO  Starting debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 15:37:10 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53390 .
2024.01.27 15:37:10 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:37:10 INFO  Canceling debug proxy for [test.scala.Tests(Composite Menu Test)]
2024.01.27 15:37:10 INFO  Closing debug server tcp://0.0.0.0:53387
2024.01.27 15:37:36 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:37:36 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:37:36 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:37:36 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53399 .
2024.01.27 15:37:36 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:37:36 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:37:36 INFO  Closing debug server tcp://0.0.0.0:53396
2024.01.27 15:38:22 INFO  compiling root-test (1 scala source)
2024.01.27 15:38:22 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:38:22 INFO  time: compiled root-test in 0.58s
2024.01.27 15:38:31 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:38:31 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:38:31 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:38:31 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53416 .
2024.01.27 15:38:31 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:38:31 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:38:31 INFO  Closing debug server tcp://0.0.0.0:53413
2024.01.27 15:39:05 INFO  compiling root-test (1 scala source)
2024.01.27 15:39:05 INFO  time: compiled root-test in 0.61s
2024.01.27 15:39:11 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:39:11 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:39:11 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:39:11 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53431 .
2024.01.27 15:39:11 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:39:11 INFO  Closing debug server tcp://0.0.0.0:53428
2024.01.27 15:39:11 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:39:33 INFO  compiling root-test (1 scala source)
2024.01.27 15:39:33 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 9m 39.579s)
2024.01.27 15:39:33 INFO  compiling root-test (1 scala source)
2024.01.27 15:39:33 INFO  time: compiled root-test in 0.46s
2024.01.27 15:39:33 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 9m 40.052s)
2024.01.27 15:39:34 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:39:34 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:39:34 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:39:34 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53443 .
2024.01.27 15:39:34 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:39:34 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:39:34 INFO  Closing debug server tcp://0.0.0.0:53440
2024.01.27 15:39:53 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:39:53 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:39:53 INFO  Starting debug proxy for [test.scala.Tests(word count test)]
2024.01.27 15:39:53 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53453 .
2024.01.27 15:39:53 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:39:53 INFO  Closing debug server tcp://0.0.0.0:53450
2024.01.27 15:39:53 INFO  Canceling debug proxy for [test.scala.Tests(word count test)]
2024.01.27 15:39:55 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:39:55 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:39:55 INFO  Starting debug proxy for [test.scala.Tests()]
2024.01.27 15:39:55 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53461 .
2024.01.27 15:39:55 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:39:55 INFO  Canceling debug proxy for [test.scala.Tests()]
2024.01.27 15:39:55 INFO  Closing debug server tcp://0.0.0.0:53458
2024.01.27 15:40:20 INFO  compiling root-test (1 scala source)
2024.01.27 15:40:21 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:40:20 INFO  time: compiled root-test in 0.56s
2024.01.27 15:40:23 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:40:23 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:40:23 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:40:23 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53471 .
2024.01.27 15:40:23 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:40:23 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:40:23 INFO  Closing debug server tcp://0.0.0.0:53468
2024.01.27 15:40:33 ERROR Failed to tokenize input for semantic tokens for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
scala.meta.tokenizers.TokenizeException: <input>:152: error: unclosed comment
    /*assertEquals(1, invoker.getActions().size());
    ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:842)

2024.01.27 15:40:36 ERROR Failed to tokenize input for semantic tokens for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
scala.meta.tokenizers.TokenizeException: <input>:152: error: unclosed comment
    /*  assertEquals(1, invoker.getActions().size());
    ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:842)

2024.01.27 15:40:40 INFO  compiling root-test (1 scala source)
2024.01.27 15:40:40 INFO  time: compiled root-test in 0.56s
2024.01.27 15:42:20 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:42:20 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:42:20 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:42:20 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53491 .
2024.01.27 15:42:20 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:42:20 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:42:20 INFO  Closing debug server tcp://0.0.0.0:53488
2024.01.27 15:42:29 INFO  compiling root-test (1 scala source)
2024.01.27 15:42:29 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:42:29 INFO  time: compiled root-test in 0.58s
2024.01.27 15:42:31 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:42:31 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:42:31 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:42:31 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53499 .
2024.01.27 15:42:31 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:42:31 INFO  Closing debug server tcp://0.0.0.0:53496
2024.01.27 15:42:31 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:42:36 INFO  compiling root-test (1 scala source)
2024.01.27 15:42:36 INFO  time: compiled root-test in 0.56s
2024.01.27 15:42:38 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:42:38 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:42:38 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:42:38 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53507 .
2024.01.27 15:42:38 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:42:39 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:42:38 INFO  Closing debug server tcp://0.0.0.0:53504
2024.01.27 15:42:55 INFO  compiling root-test (1 scala source)
2024.01.27 15:42:55 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:42:55 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:42:55 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:42:55 INFO  time: compiled root-test in 0.6s
2024.01.27 15:42:56 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:42:56 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:42:57 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:42:57 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53515 .
2024.01.27 15:42:57 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:42:57 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:42:57 INFO  Closing debug server tcp://0.0.0.0:53512
2024.01.27 15:43:10 INFO  compiling root-test (1 scala source)
2024.01.27 15:43:10 INFO  time: compiled root-test in 0.56s
2024.01.27 15:43:12 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:43:12 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:43:12 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:43:12 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53526 .
2024.01.27 15:43:12 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:43:13 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:43:12 INFO  Closing debug server tcp://0.0.0.0:53523
ene 27, 2024 3:43:13 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1062
2024.01.27 15:43:20 INFO  compiling root-test (1 scala source)
2024.01.27 15:43:20 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:43:20 INFO  time: compiled root-test in 0.59s
ene 27, 2024 3:43:20 P.M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.01.27 15:43:20 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 13m 27.1s)
2024.01.27 15:43:20 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 13m 27.109s)
2024.01.27 15:43:20 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:43:20 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:43:20 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:43:20 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53534 .
2024.01.27 15:43:20 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:43:20 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:43:21 INFO  Closing debug server tcp://0.0.0.0:53531
2024.01.27 15:43:28 INFO  compiling root-test (1 scala source)
2024.01.27 15:43:28 INFO  time: compiled root-test in 0.11s
2024.01.27 15:43:39 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:43:39 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:43:39 INFO  Starting debug proxy for [test.scala.Tests()]
2024.01.27 15:43:39 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53542 .
2024.01.27 15:43:39 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:43:39 INFO  Canceling debug proxy for [test.scala.Tests()]
2024.01.27 15:43:39 INFO  Closing debug server tcp://0.0.0.0:53539
ene 27, 2024 3:44:05 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1237
2024.01.27 15:44:49 INFO  compiling root-test (1 scala source)
2024.01.27 15:44:49 INFO  time: compiled root-test in 0.6s
2024.01.27 15:44:49 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.0' (since 14m 55.991s)
2024.01.27 15:44:49 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.2.0' (since 14m 56.014s)
2024.01.27 15:44:49 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:44:49 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:44:49 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:44:49 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53553 .
2024.01.27 15:44:49 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:44:50 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:44:50 INFO  Closing debug server tcp://0.0.0.0:53549
2024.01.27 15:44:57 INFO  compiling root-test (1 scala source)
2024.01.27 15:44:58 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:44:57 INFO  time: compiled root-test in 0.58s
2024.01.27 15:44:59 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:44:59 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:44:59 INFO  Starting debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:44:59 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53563 .
2024.01.27 15:44:59 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:44:59 INFO  Canceling debug proxy for [test.scala.Tests(Java Functions Working)]
2024.01.27 15:44:59 INFO  Closing debug server tcp://0.0.0.0:53560
2024.01.27 15:45:24 INFO  compiling root-test (1 scala source)
2024.01.27 15:45:24 INFO  time: compiled root-test in 0.58s
2024.01.27 15:45:25 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:45:25 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:45:25 INFO  Starting debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:45:25 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53573 .
2024.01.27 15:45:25 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:45:25 INFO  Closing debug server tcp://0.0.0.0:53570
2024.01.27 15:45:25 INFO  Canceling debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:45:38 INFO  compiling root-test (1 scala source)
2024.01.27 15:45:39 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:45:38 INFO  time: compiled root-test in 0.59s
2024.01.27 15:45:41 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:45:41 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:45:41 INFO  Starting debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:45:41 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53581 .
2024.01.27 15:45:41 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:45:42 INFO  Canceling debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:45:41 INFO  Closing debug server tcp://0.0.0.0:53578
2024.01.27 15:45:54 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:45:54 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:45:54 INFO  Starting debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:45:54 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53589 .
2024.01.27 15:45:54 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:45:55 INFO  Canceling debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:45:54 INFO  Closing debug server tcp://0.0.0.0:53586
2024.01.27 15:46:33 INFO  Shutting down server
2024.01.27 15:46:33 INFO  shutting down Metals
2024.01.27 15:46:33 INFO  Shut down connection with build server.
2024.01.27 15:46:33 INFO  Shut down connection with build server.
2024.01.27 15:46:33 INFO  Exiting server
2024.01.27 15:46:40 INFO  Started: Metals version 1.2.0 in folders 'C:\Users\ARNAU\Desktop\TAP\Scala-Projects' for client Visual Studio Code 1.85.2.
2024.01.27 15:46:41 INFO  Attempting to connect to the build server...
2024.01.27 15:46:41 INFO  skipping build import with status 'Installed'
2024.01.27 15:46:41 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 15:46:41 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 15:46:41 INFO  Attempting to connect to the build server...
2024.01.27 15:46:41 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\ARNAU\.bloop\bloop.json
2024.01.27 15:46:41 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\project\.metals\bsp.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.01.27 15:46:41 INFO  time: Connected to build server in 0.33s
2024.01.27 15:46:41 INFO  Connected to Build server: Bloop v1.5.13
2024.01.27 15:46:44 INFO  no build target found for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.27 15:46:47 INFO  time: indexed workspace in 3s
2024.01.27 15:46:50 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:46:50 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:46:50 INFO  Starting debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:46:50 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53667 .
2024.01.27 15:46:50 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:46:50 INFO  Closing debug server tcp://0.0.0.0:53664
2024.01.27 15:46:51 INFO  Canceling debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:47:48 INFO  compiling root-test (1 scala source)
2024.01.27 15:47:48 INFO  time: compiled root-test in 0.64s
2024.01.27 15:47:49 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:47:49 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:47:49 INFO  Starting debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:47:49 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53687 .
2024.01.27 15:47:49 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:47:49 INFO  Canceling debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:47:49 INFO  Closing debug server tcp://0.0.0.0:53684
Exception in thread "pool-6-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:842)
2024.01.27 15:47:55 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:47:55 INFO  compiling root-test (1 scala source)
2024.01.27 15:47:55 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:47:55 WARN  Could not load snapshot text for C:\Users\ARNAU\Desktop\TAP\Scala-Projects\src\test\scala\Tests.scala
2024.01.27 15:47:55 INFO  time: compiled root-test in 0.64s
2024.01.27 15:47:56 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-server.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.01.27 15:47:56 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\ARNAU\Desktop\TAP\Scala-Projects\.metals\dap-client.trace.json or C:\Users\ARNAU\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.01.27 15:47:56 INFO  Starting debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:47:55 INFO  Trying to attach to remote debuggee VM 127.0.0.1:53696 .
2024.01.27 15:47:55 INFO  Attaching to debuggee VM succeeded.
2024.01.27 15:47:56 INFO  Canceling debug proxy for [test.scala.Tests(JavaFunctions Can't distribute)]
2024.01.27 15:47:56 INFO  Closing debug server tcp://0.0.0.0:53693
ene 27, 2024 3:48:00 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 71
